{
  "id": "snapshot_1764388360832_lmb0hlgy8",
  "approvalId": "approval_1764294274047_qabj7k2rr",
  "approvalTitle": "A7-UI design.md - User Interface Architecture",
  "version": 2,
  "timestamp": "2025-11-29T03:52:40.832Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Assignment 7-UI: Design Document\r\n# User Interface (Inventory Screen, Crafting Interface)\r\n\r\n**Version:** 1.0\r\n**Date:** 2025-11-27\r\n**Status:** Design Phase\r\n**Dependencies:** ✅ Requires A7-Core completion (Registry, Inventory, ItemStack systems)\r\n\r\n---\r\n\r\n## Executive Summary\r\n\r\nThis design document provides the technical architecture for A7-UI's implementation of full inventory and crafting user interface. The design covers:\r\n\r\n1. **Full Inventory Screen** - Modal dialog with 36 slots (Minecraft-authentic layout)\r\n2. **Crafting Interface** - 2×2 crafting grid with recipe matching\r\n3. **Mouse Interaction System** - Click, drag, drop, shift-click (Minecraft controls)\r\n4. **Cursor Item Rendering** - Held item following mouse (Minecraft behavior)\r\n5. **WidgetSubsystem Refinements** - Modal dialogs, input routing (if needed)\r\n\r\n**Design Philosophy:**\r\n- **Minecraft UI Fidelity** - Pixel-perfect recreation of Minecraft inventory screen\r\n- **Event-Driven Architecture** - Mouse events propagate through widget hierarchy\r\n- **State Machine Pattern** - Clear cursor item state transitions\r\n- **Reuse A7-Core Systems** - Leverage existing Inventory, ItemStack, RecipeRegistry\r\n\r\n---\r\n\r\n## Table of Contents\r\n\r\n1. [System Architecture Overview](#1-system-architecture-overview)\r\n2. [InventoryWidget Design](#2-inventorywidget-design)\r\n3. [Mouse Interaction System](#3-mouse-interaction-system)\r\n4. [Crafting System Integration](#4-crafting-system-integration)\r\n5. [WidgetSubsystem Refinements](#5-widgetsubsystem-refinements)\r\n6. [UI Layout and Rendering](#6-ui-layout-and-rendering)\r\n7. [State Machines](#7-state-machines)\r\n8. [Implementation Strategy](#8-implementation-strategy)\r\n\r\n---\r\n\r\n## 1. System Architecture Overview\r\n\r\n### Component Architecture\r\n\r\n```\r\n┌─────────────────────────────────────────────┐\r\n│         InventoryWidget (Modal)             │\r\n│  ┌─────────────────────────────────────┐   │\r\n│  │  InventoryGrid (27 slots)           │   │\r\n│  │  HotbarGrid (9 slots)               │   │\r\n│  │  CraftingGrid (4 input + 1 output)  │   │\r\n│  │  CursorItem (held item rendering)   │   │\r\n│  └─────────────────────────────────────┘   │\r\n└─────────────────────────────────────────────┘\r\n                    ↓↑\r\n┌─────────────────────────────────────────────┐\r\n│       WidgetSubsystem (Engine)              │\r\n│    - Modal widget support                   │\r\n│    - Mouse event routing                    │\r\n│    - Input capture                          │\r\n└─────────────────────────────────────────────┘\r\n                    ↓↑\r\n┌─────────────────────────────────────────────┐\r\n│       Player Inventory (A7-Core)            │\r\n│    - 36 slots (27 main + 9 hotbar)          │\r\n│    - ItemStack storage                      │\r\n└─────────────────────────────────────────────┘\r\n```\r\n\r\n### Data Flow\r\n\r\n```\r\nMouse Click Event\r\n     ↓\r\nWidgetSubsystem::OnMouseEvent()\r\n     ↓\r\nInventoryWidget::OnMouseEvent()\r\n     ↓\r\nDetermine Clicked Slot → ClickHandler\r\n     ↓\r\nUpdate Cursor Item State\r\n     ↓\r\nUpdate Player Inventory\r\n     ↓\r\nRender Updated UI\r\n```\r\n\r\n---\r\n\r\n## 2. InventoryWidget Design\r\n\r\n### Class Structure\r\n\r\n**File:** `SimpleMiner\\Code\\Game\\UI\\InventoryWidget.hpp`\r\n\r\n```cpp\r\nclass InventoryWidget : public IWidget\r\n{\r\npublic:\r\n    InventoryWidget(Player* player);\r\n    ~InventoryWidget();\r\n\r\n    // IWidget Interface\r\n    virtual void Update(float deltaSeconds) override;\r\n    virtual void Render() const override;\r\n    virtual bool OnMouseEvent(MouseEvent const& event) override;\r\n    virtual bool OnKeyEvent(KeyEvent const& event) override;\r\n\r\n    // Visibility\r\n    void Show();\r\n    void Hide();\r\n    bool IsVisible() const { return m_isVisible; }\r\n\r\nprivate:\r\n    Player* m_player = nullptr;\r\n    bool m_isVisible = false;\r\n\r\n    // Cursor Item (held by mouse)\r\n    ItemStack m_cursorItem;  // Empty when not holding anything\r\n\r\n    // Layout (calculated in constructor)\r\n    Vec2 m_screenCenter;\r\n    AABB2 m_inventoryGridBounds;   // 27 slots (3×9)\r\n    AABB2 m_hotbarGridBounds;      // 9 slots (1×9)\r\n    AABB2 m_craftingGridBounds;    // 4 slots (2×2)\r\n    AABB2 m_craftingOutputBounds;  // 1 slot\r\n    std::vector<AABB2> m_allSlotBounds;  // All 40 slots (36 inventory + 4 crafting)\r\n\r\n    // Textures\r\n    Texture* m_backgroundTexture = nullptr;\r\n    Texture* m_slotTexture = nullptr;\r\n    Texture* m_arrowTexture = nullptr;  // Crafting arrow\r\n    Texture* m_itemSpriteSheet = nullptr;\r\n\r\n    // Rendering\r\n    void RenderBackground() const;\r\n    void RenderInventoryGrid() const;\r\n    void RenderHotbarGrid() const;\r\n    void RenderCraftingGrid() const;\r\n    void RenderCraftingOutput() const;\r\n    void RenderSlot(AABB2 const& bounds, ItemStack const& item, bool isSelected) const;\r\n    void RenderCursorItem() const;\r\n\r\n    // Input Handling\r\n    int GetSlotIndexAtPosition(Vec2 const& mousePos) const;  // Returns -1 if none\r\n    void HandleLeftClick(int slotIndex);\r\n    void HandleRightClick(int slotIndex);\r\n    void HandleShiftLeftClick(int slotIndex);\r\n    void HandleClickOutside();\r\n\r\n    // Crafting\r\n    void UpdateCraftingOutput();\r\n    Recipe* m_currentRecipe = nullptr;  // Cached recipe match\r\n};\r\n```\r\n\r\n### Layout Calculations\r\n\r\n**Minecraft Inventory Layout (pixels):**\r\n```\r\n┌────────────────────────────────────────────┐\r\n│  Crafting Grid (2×2)      Output Slot      │  ← Top-left\r\n│  [0][1]          →        [OUT]            │\r\n│  [2][3]                                    │\r\n│                                            │\r\n│  Main Inventory (3×9)                      │  ← Center\r\n│  [0 ][1 ][2 ][3 ][4 ][5 ][6 ][7 ][8 ]     │\r\n│  [9 ][10][11][12][13][14][15][16][17]     │\r\n│  [18][19][20][21][22][23][24][25][26]     │\r\n│                                            │\r\n│  Hotbar (1×9)                              │  ← Bottom\r\n│  [27][28][29][30][31][32][33][34][35]     │\r\n└────────────────────────────────────────────┘\r\n\r\nDimensions (Minecraft-style):\r\n- Slot size: 18×18 pixels (16px item + 1px padding)\r\n- Spacing: 2px between slots\r\n- Background: 176×166 pixels\r\n```\r\n\r\n**Code:**\r\n```cpp\r\nvoid InventoryWidget::CalculateLayout()\r\n{\r\n    // Center on screen\r\n    Vec2 screenDims = g_window->GetDimensions();\r\n    m_screenCenter = screenDims * 0.5f;\r\n\r\n    // Background (centered)\r\n    Vec2 backgroundSize(176.0f, 166.0f);\r\n    Vec2 backgroundMin = m_screenCenter - backgroundSize * 0.5f;\r\n\r\n    // Crafting Grid (top-left, 2×2)\r\n    Vec2 craftingStart = backgroundMin + Vec2(30.0f, 17.0f);\r\n    for (int row = 0; row < 2; row++)\r\n    {\r\n        for (int col = 0; col < 2; col++)\r\n        {\r\n            int slotIndex = row * 2 + col;\r\n            Vec2 slotMin = craftingStart + Vec2(col * 20.0f, row * 20.0f);\r\n            m_allSlotBounds[36 + slotIndex] = AABB2(slotMin, slotMin + Vec2(18.0f, 18.0f));\r\n        }\r\n    }\r\n\r\n    // Crafting Output (right of crafting grid)\r\n    Vec2 outputMin = craftingStart + Vec2(94.0f, 9.0f);\r\n    m_craftingOutputBounds = AABB2(outputMin, outputMin + Vec2(18.0f, 18.0f));\r\n\r\n    // Main Inventory (3×9)\r\n    Vec2 inventoryStart = backgroundMin + Vec2(8.0f, 84.0f);\r\n    for (int row = 0; row < 3; row++)\r\n    {\r\n        for (int col = 0; col < 9; col++)\r\n        {\r\n            int slotIndex = row * 9 + col;\r\n            Vec2 slotMin = inventoryStart + Vec2(col * 20.0f, row * 20.0f);\r\n            m_allSlotBounds[slotIndex] = AABB2(slotMin, slotMin + Vec2(18.0f, 18.0f));\r\n        }\r\n    }\r\n\r\n    // Hotbar (1×9)\r\n    Vec2 hotbarStart = backgroundMin + Vec2(8.0f, 142.0f);\r\n    for (int col = 0; col < 9; col++)\r\n    {\r\n        Vec2 slotMin = hotbarStart + Vec2(col * 20.0f, 0.0f);\r\n        m_allSlotBounds[27 + col] = AABB2(slotMin, slotMin + Vec2(18.0f, 18.0f));\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 3. Mouse Interaction System\r\n\r\n### Mouse Event Flow\r\n\r\n```cpp\r\nbool InventoryWidget::OnMouseEvent(MouseEvent const& event)\r\n{\r\n    if (!m_isVisible) return false;\r\n\r\n    Vec2 mousePos = event.position;\r\n    int slotIndex = GetSlotIndexAtPosition(mousePos);\r\n\r\n    if (event.type == eMouseEventType::LEFT_BUTTON_DOWN)\r\n    {\r\n        if (slotIndex >= 0)\r\n        {\r\n            if (event.modifiers & eKeyModifier::SHIFT)\r\n                HandleShiftLeftClick(slotIndex);\r\n            else\r\n                HandleLeftClick(slotIndex);\r\n        }\r\n        else\r\n        {\r\n            HandleClickOutside();\r\n        }\r\n        return true;  // Consume event\r\n    }\r\n    else if (event.type == eMouseEventType::RIGHT_BUTTON_DOWN)\r\n    {\r\n        if (slotIndex >= 0)\r\n        {\r\n            HandleRightClick(slotIndex);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n```\r\n\r\n### Left-Click Handler (Minecraft Behavior)\r\n\r\n```cpp\r\nvoid InventoryWidget::HandleLeftClick(int slotIndex)\r\n{\r\n    // Special case: Crafting output slot\r\n    if (slotIndex == CRAFTING_OUTPUT_SLOT)\r\n    {\r\n        HandleCraftingOutputClick();\r\n        return;\r\n    }\r\n\r\n    ItemStack& slotItem = GetSlotItemStack(slotIndex);\r\n\r\n    // Case 1: Empty cursor + Empty slot → Nothing\r\n    if (m_cursorItem.IsEmpty() && slotItem.IsEmpty())\r\n    {\r\n        return;\r\n    }\r\n\r\n    // Case 2: Empty cursor + Filled slot → Pick up entire stack\r\n    if (m_cursorItem.IsEmpty() && !slotItem.IsEmpty())\r\n    {\r\n        m_cursorItem = slotItem;\r\n        slotItem.Clear();\r\n        return;\r\n    }\r\n\r\n    // Case 3: Held item + Empty slot → Place entire stack\r\n    if (!m_cursorItem.IsEmpty() && slotItem.IsEmpty())\r\n    {\r\n        slotItem = m_cursorItem;\r\n        m_cursorItem.Clear();\r\n        return;\r\n    }\r\n\r\n    // Case 4: Held item + Filled slot (same item) → Merge stacks\r\n    if (!m_cursorItem.IsEmpty() && !slotItem.IsEmpty())\r\n    {\r\n        if (m_cursorItem.itemID == slotItem.itemID)\r\n        {\r\n            ItemDefinition* itemDef = ItemRegistry::GetInstance().Get(m_cursorItem.itemID);\r\n            uint8_t maxStack = itemDef->m_maxStackSize;\r\n\r\n            uint8_t space = maxStack - slotItem.quantity;\r\n            uint8_t toTransfer = std::min(space, m_cursorItem.quantity);\r\n\r\n            slotItem.quantity += toTransfer;\r\n            m_cursorItem.quantity -= toTransfer;\r\n\r\n            if (m_cursorItem.quantity == 0)\r\n                m_cursorItem.Clear();\r\n\r\n            return;\r\n        }\r\n\r\n        // Case 5: Held item + Filled slot (different item) → Swap\r\n        ItemStack temp = m_cursorItem;\r\n        m_cursorItem = slotItem;\r\n        slotItem = temp;\r\n    }\r\n}\r\n```\r\n\r\n### Right-Click Handler (Minecraft Behavior)\r\n\r\n```cpp\r\nvoid InventoryWidget::HandleRightClick(int slotIndex)\r\n{\r\n    ItemStack& slotItem = GetSlotItemStack(slotIndex);\r\n\r\n    // Case 1: Empty cursor + Filled slot → Pick up half stack (rounded up)\r\n    if (m_cursorItem.IsEmpty() && !slotItem.IsEmpty())\r\n    {\r\n        uint8_t half = (slotItem.quantity + 1) / 2;  // Round up\r\n        m_cursorItem.itemID = slotItem.itemID;\r\n        m_cursorItem.quantity = half;\r\n        m_cursorItem.durability = slotItem.durability;\r\n\r\n        slotItem.quantity -= half;\r\n        if (slotItem.quantity == 0)\r\n            slotItem.Clear();\r\n\r\n        return;\r\n    }\r\n\r\n    // Case 2: Held item + Empty slot → Place 1 item\r\n    if (!m_cursorItem.IsEmpty() && slotItem.IsEmpty())\r\n    {\r\n        slotItem.itemID = m_cursorItem.itemID;\r\n        slotItem.quantity = 1;\r\n        slotItem.durability = m_cursorItem.durability;\r\n\r\n        m_cursorItem.quantity--;\r\n        if (m_cursorItem.quantity == 0)\r\n            m_cursorItem.Clear();\r\n\r\n        return;\r\n    }\r\n\r\n    // Case 3: Held item + Filled slot (same item) → Add 1 item to slot\r\n    if (!m_cursorItem.IsEmpty() && !slotItem.IsEmpty())\r\n    {\r\n        if (m_cursorItem.itemID == slotItem.itemID)\r\n        {\r\n            ItemDefinition* itemDef = ItemRegistry::GetInstance().Get(m_cursorItem.itemID);\r\n            if (slotItem.quantity < itemDef->m_maxStackSize)\r\n            {\r\n                slotItem.quantity++;\r\n                m_cursorItem.quantity--;\r\n\r\n                if (m_cursorItem.quantity == 0)\r\n                    m_cursorItem.Clear();\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Case 4: Different item → Swap (same as left-click)\r\n        ItemStack temp = m_cursorItem;\r\n        m_cursorItem = slotItem;\r\n        slotItem = temp;\r\n    }\r\n}\r\n```\r\n\r\n### Shift-Left-Click Handler (Quick Transfer)\r\n\r\n```cpp\r\nvoid InventoryWidget::HandleShiftLeftClick(int slotIndex)\r\n{\r\n    ItemStack& slotItem = GetSlotItemStack(slotIndex);\r\n    if (slotItem.IsEmpty()) return;\r\n\r\n    // Determine source and destination ranges\r\n    bool isHotbar = (slotIndex >= 27 && slotIndex <= 35);\r\n    bool isCrafting = (slotIndex >= 36 && slotIndex <= 39);\r\n\r\n    int destStart, destEnd;\r\n    if (isHotbar || isCrafting)\r\n    {\r\n        // Hotbar/Crafting → Main Inventory\r\n        destStart = 0;\r\n        destEnd = 26;\r\n    }\r\n    else\r\n    {\r\n        // Main Inventory → Hotbar\r\n        destStart = 27;\r\n        destEnd = 35;\r\n    }\r\n\r\n    // Try to merge with existing stacks\r\n    ItemDefinition* itemDef = ItemRegistry::GetInstance().Get(slotItem.itemID);\r\n    for (int i = destStart; i <= destEnd; i++)\r\n    {\r\n        ItemStack& destSlot = GetSlotItemStack(i);\r\n        if (destSlot.itemID == slotItem.itemID && destSlot.quantity < itemDef->m_maxStackSize)\r\n        {\r\n            uint8_t space = itemDef->m_maxStackSize - destSlot.quantity;\r\n            uint8_t toTransfer = std::min(space, slotItem.quantity);\r\n\r\n            destSlot.quantity += toTransfer;\r\n            slotItem.quantity -= toTransfer;\r\n\r\n            if (slotItem.quantity == 0)\r\n            {\r\n                slotItem.Clear();\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Try to find empty slot\r\n    for (int i = destStart; i <= destEnd; i++)\r\n    {\r\n        ItemStack& destSlot = GetSlotItemStack(i);\r\n        if (destSlot.IsEmpty())\r\n        {\r\n            destSlot = slotItem;\r\n            slotItem.Clear();\r\n            return;\r\n        }\r\n    }\r\n\r\n    // No space available, do nothing\r\n}\r\n```\r\n\r\n---\r\n\r\n## 4. Crafting System Integration\r\n\r\n### Recipe Matching Algorithm\r\n\r\n```cpp\r\nvoid InventoryWidget::UpdateCraftingOutput()\r\n{\r\n    // Get crafting grid items\r\n    std::array<ItemStack, 4> craftingGrid;\r\n    for (int i = 0; i < 4; i++)\r\n    {\r\n        craftingGrid[i] = GetSlotItemStack(36 + i);  // Slots 36-39\r\n    }\r\n\r\n    // Convert to itemID array for recipe matching\r\n    std::array<uint16_t, 4> pattern;\r\n    for (int i = 0; i < 4; i++)\r\n    {\r\n        pattern[i] = craftingGrid[i].itemID;\r\n    }\r\n\r\n    // Check all recipes\r\n    RecipeRegistry& recipeReg = RecipeRegistry::GetInstance();\r\n    m_currentRecipe = nullptr;\r\n\r\n    for (Recipe* recipe : recipeReg.GetAll())\r\n    {\r\n        if (recipe->Matches(pattern))\r\n        {\r\n            m_currentRecipe = recipe;\r\n            break;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### Recipe::Matches Implementation\r\n\r\n```cpp\r\nbool Recipe::Matches(std::array<uint16_t, 4> const& craftingGrid) const\r\n{\r\n    if (m_type == eRecipeType::SHAPED)\r\n    {\r\n        // Shaped: Check all 4 possible positions in 2×2 grid\r\n        // (pattern can be anywhere: top-left, top-right, bottom-left, bottom-right)\r\n\r\n        // Position 1: Top-left (no offset)\r\n        if (MatchesShapedPattern(craftingGrid, 0, 0)) return true;\r\n\r\n        // Position 2: Top-right (offset col +1)\r\n        // Position 3: Bottom-left (offset row +1)\r\n        // Position 4: Bottom-right (offset both +1)\r\n        // ... (check all positions)\r\n\r\n        return false;\r\n    }\r\n    else  // SHAPELESS\r\n    {\r\n        // Count ingredients in grid\r\n        std::map<uint16_t, int> gridCounts;\r\n        for (uint16_t itemID : craftingGrid)\r\n        {\r\n            if (itemID != 0)\r\n                gridCounts[itemID]++;\r\n        }\r\n\r\n        // Count required ingredients\r\n        std::map<uint16_t, int> recipeCounts;\r\n        for (uint16_t itemID : m_ingredients)\r\n        {\r\n            recipeCounts[itemID]++;\r\n        }\r\n\r\n        // Must match exactly\r\n        return gridCounts == recipeCounts;\r\n    }\r\n}\r\n```\r\n\r\n### Crafting Output Click Handler\r\n\r\n```cpp\r\nvoid InventoryWidget::HandleCraftingOutputClick()\r\n{\r\n    if (!m_currentRecipe) return;  // No valid recipe\r\n\r\n    // Check if cursor can hold output\r\n    ItemStack output(m_currentRecipe->m_outputItemID, m_currentRecipe->m_outputQuantity);\r\n\r\n    if (!m_cursorItem.IsEmpty() && m_cursorItem.itemID != output.itemID)\r\n        return;  // Cannot merge different items\r\n\r\n    // Consume ingredients from crafting grid\r\n    for (int i = 0; i < 4; i++)\r\n    {\r\n        ItemStack& slot = GetSlotItemStack(36 + i);\r\n        if (!slot.IsEmpty())\r\n        {\r\n            slot.quantity--;\r\n            if (slot.quantity == 0)\r\n                slot.Clear();\r\n        }\r\n    }\r\n\r\n    // Add output to cursor\r\n    if (m_cursorItem.IsEmpty())\r\n    {\r\n        m_cursorItem = output;\r\n    }\r\n    else\r\n    {\r\n        m_cursorItem.quantity += output.quantity;\r\n    }\r\n\r\n    // Update crafting output (re-check recipe with remaining items)\r\n    UpdateCraftingOutput();\r\n}\r\n```\r\n\r\n### Shift-Click Crafting (Craft Multiple)\r\n\r\n```cpp\r\nvoid InventoryWidget::HandleShiftCraftingOutputClick()\r\n{\r\n    if (!m_currentRecipe) return;\r\n\r\n    // Craft as many as possible\r\n    while (m_currentRecipe != nullptr)\r\n    {\r\n        // Try to add output to inventory\r\n        ItemStack output(m_currentRecipe->m_outputItemID, m_currentRecipe->m_outputQuantity);\r\n        if (!m_player->GetInventory().AddItem(output))\r\n            break;  // Inventory full\r\n\r\n        // Consume ingredients\r\n        for (int i = 0; i < 4; i++)\r\n        {\r\n            ItemStack& slot = GetSlotItemStack(36 + i);\r\n            if (!slot.IsEmpty())\r\n            {\r\n                slot.quantity--;\r\n                if (slot.quantity == 0)\r\n                    slot.Clear();\r\n            }\r\n        }\r\n\r\n        // Re-check recipe\r\n        UpdateCraftingOutput();\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 5. WidgetSubsystem Refinements\r\n\r\n### Modal Widget Support (If Needed)\r\n\r\n**File:** `Engine\\Code\\Engine\\Widget\\WidgetSubsystem.hpp`\r\n\r\n```cpp\r\n// Add to IWidget interface (if not already present):\r\nclass IWidget\r\n{\r\npublic:\r\n    virtual bool IsModal() const { return false; }  // Override for modal widgets\r\n    // ...\r\n};\r\n\r\n// Add to WidgetSubsystem:\r\nclass WidgetSubsystem\r\n{\r\nprivate:\r\n    std::vector<IWidget*> m_widgets;  // Sorted by zOrder\r\n\r\npublic:\r\n    bool OnMouseEvent(MouseEvent const& event)\r\n    {\r\n        // Route to topmost modal widget first\r\n        for (auto it = m_widgets.rbegin(); it != m_widgets.rend(); ++it)\r\n        {\r\n            IWidget* widget = *it;\r\n            if (widget->IsModal() && widget->IsVisible())\r\n            {\r\n                if (widget->OnMouseEvent(event))\r\n                    return true;  // Consumed by modal widget\r\n                break;  // Stop at first modal\r\n            }\r\n        }\r\n\r\n        // If no modal consumed, route to all widgets (top to bottom)\r\n        for (auto it = m_widgets.rbegin(); it != m_widgets.rend(); ++it)\r\n        {\r\n            if ((*it)->OnMouseEvent(event))\r\n                return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n};\r\n```\r\n\r\n### Input Capture for Inventory\r\n\r\n```cpp\r\nclass InventoryWidget : public IWidget\r\n{\r\npublic:\r\n    virtual bool IsModal() const override { return m_isVisible; }\r\n\r\n    bool OnKeyEvent(KeyEvent const& event) override\r\n    {\r\n        if (event.key == KEY_E || event.key == KEY_ESCAPE)\r\n        {\r\n            if (event.type == eKeyEventType::KEY_DOWN)\r\n            {\r\n                Hide();\r\n                return true;  // Consume event\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n};\r\n```\r\n\r\n---\r\n\r\n## 6. UI Layout and Rendering\r\n\r\n### Rendering Pipeline\r\n\r\n```cpp\r\nvoid InventoryWidget::Render() const\r\n{\r\n    if (!m_isVisible) return;\r\n\r\n    // 1. Render dark overlay (pause background)\r\n    RenderDarkOverlay();\r\n\r\n    // 2. Render background GUI texture\r\n    RenderBackground();\r\n\r\n    // 3. Render crafting grid slots\r\n    RenderCraftingGrid();\r\n\r\n    // 4. Render crafting arrow\r\n    RenderCraftingArrow();\r\n\r\n    // 5. Render crafting output\r\n    RenderCraftingOutput();\r\n\r\n    // 6. Render main inventory grid\r\n    RenderInventoryGrid();\r\n\r\n    // 7. Render hotbar grid\r\n    RenderHotbarGrid();\r\n\r\n    // 8. Render cursor item (topmost layer)\r\n    RenderCursorItem();\r\n}\r\n```\r\n\r\n### Slot Rendering (Reusable)\r\n\r\n```cpp\r\nvoid InventoryWidget::RenderSlot(AABB2 const& bounds, ItemStack const& item, bool isSelected) const\r\n{\r\n    // Render slot background\r\n    g_renderer->DrawTexturedQuad(bounds, m_slotTexture, AABB2::ZERO_TO_ONE, Rgba8::WHITE);\r\n\r\n    // Render selection highlight (if selected)\r\n    if (isSelected)\r\n    {\r\n        g_renderer->DrawQuadOutline(bounds, 2.0f, Rgba8::WHITE);\r\n    }\r\n\r\n    // Render item icon (if slot not empty)\r\n    if (!item.IsEmpty())\r\n    {\r\n        ItemDefinition* itemDef = ItemRegistry::GetInstance().Get(item.itemID);\r\n        if (itemDef)\r\n        {\r\n            // Get sprite UVs from item definition\r\n            AABB2 uvs = GetUVsForSpriteCoords(itemDef->m_spriteCoords, IntVec2(16, 16));\r\n            Vec2 itemSize(16.0f, 16.0f);\r\n            Vec2 itemPos = bounds.GetCenter() - itemSize * 0.5f;\r\n\r\n            g_renderer->DrawTexturedQuad(AABB2(itemPos, itemPos + itemSize), m_itemSpriteSheet, uvs);\r\n\r\n            // Render quantity (if > 1)\r\n            if (item.quantity > 1)\r\n            {\r\n                Vec2 textPos = bounds.maxs - Vec2(2.0f, 2.0f);  // Bottom-right\r\n                std::string quantityText = std::to_string(item.quantity);\r\n                g_renderer->DrawText2D(textPos, quantityText, 8.0f, Rgba8::WHITE);\r\n            }\r\n\r\n            // Render durability bar (if tool)\r\n            if (itemDef->m_type == eItemType::TOOL && item.durability < itemDef->m_maxDurability)\r\n            {\r\n                float durabilityPercent = (float)item.durability / (float)itemDef->m_maxDurability;\r\n                Vec2 barSize(14.0f, 2.0f);\r\n                Vec2 barPos = bounds.mins + Vec2(2.0f, bounds.GetDimensions().y - 4.0f);\r\n                AABB2 barBounds(barPos, barPos + Vec2(barSize.x * durabilityPercent, barSize.y));\r\n\r\n                Rgba8 barColor = Rgba8::GREEN;\r\n                if (durabilityPercent < 0.3f) barColor = Rgba8::RED;\r\n                else if (durabilityPercent < 0.6f) barColor = Rgba8::YELLOW;\r\n\r\n                g_renderer->DrawQuad(barBounds, barColor);\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### Cursor Item Rendering\r\n\r\n```cpp\r\nvoid InventoryWidget::RenderCursorItem() const\r\n{\r\n    if (m_cursorItem.IsEmpty()) return;\r\n\r\n    Vec2 mousePos = g_inputSystem->GetMousePosition();\r\n\r\n    // Render item icon at mouse position\r\n    ItemDefinition* itemDef = ItemRegistry::GetInstance().Get(m_cursorItem.itemID);\r\n    if (itemDef)\r\n    {\r\n        AABB2 uvs = GetUVsForSpriteCoords(itemDef->m_spriteCoords, IntVec2(16, 16));\r\n        Vec2 itemSize(16.0f, 16.0f);\r\n        AABB2 itemBounds(mousePos - itemSize * 0.5f, mousePos + itemSize * 0.5f);\r\n\r\n        g_renderer->DrawTexturedQuad(itemBounds, m_itemSpriteSheet, uvs);\r\n\r\n        // Render quantity\r\n        if (m_cursorItem.quantity > 1)\r\n        {\r\n            Vec2 textPos = itemBounds.maxs - Vec2(2.0f, 2.0f);\r\n            std::string quantityText = std::to_string(m_cursorItem.quantity);\r\n            g_renderer->DrawText2D(textPos, quantityText, 8.0f, Rgba8::WHITE);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 7. State Machines\r\n\r\n### Inventory Screen State Machine\r\n\r\n```\r\n┌──────────┐\r\n│  CLOSED  │ ◄──────┐\r\n└──────────┘        │\r\n     │              │\r\n     │ Press 'E'    │ Press 'E' or ESC\r\n     ↓              │\r\n┌──────────┐        │\r\n│  OPEN    │────────┘\r\n│ (Modal)  │\r\n└──────────┘\r\n```\r\n\r\n### Cursor Item State Machine\r\n\r\n```\r\n┌─────────────┐\r\n│ EMPTY       │ ◄──────────┐\r\n│ (no item)   │            │\r\n└─────────────┘            │\r\n     │                     │\r\n     │ Left-Click Slot     │ Place All\r\n     ↓                     │\r\n┌─────────────┐            │\r\n│ HOLDING     │────────────┘\r\n│ (has item)  │\r\n└─────────────┘\r\n     │\r\n     │ Right-Click Slot\r\n     ↓\r\n┌─────────────┐\r\n│ HOLDING     │\r\n│ (quantity-1)│\r\n└─────────────┘\r\n```\r\n\r\n---\r\n\r\n## 8. Implementation Strategy\r\n\r\n### Phase 1: InventoryWidget Foundation (4-6 hours)\r\n1. Create `InventoryWidget` class (extends `IWidget`)\r\n2. Implement layout calculations (slot positions)\r\n3. Load UI textures (background, slots, arrow)\r\n4. Implement basic rendering (background, empty slots)\r\n5. Test widget visibility toggle ('E' key)\r\n\r\n### Phase 2: Mouse Interaction (6-8 hours)\r\n1. Implement `GetSlotIndexAtPosition()` (hit testing)\r\n2. Implement `HandleLeftClick()` (all 5 cases)\r\n3. Implement `HandleRightClick()` (all 4 cases)\r\n4. Implement `HandleShiftLeftClick()` (quick transfer)\r\n5. Implement cursor item rendering\r\n6. Test all click interactions with inventory\r\n\r\n### Phase 3: Crafting Integration (4-6 hours)\r\n1. Implement `UpdateCraftingOutput()` (recipe matching)\r\n2. Implement `Recipe::Matches()` (shaped + shapeless)\r\n3. Implement crafting output click handler\r\n4. Implement shift-click crafting (craft multiple)\r\n5. Test all 10 recipes from A7-Core\r\n\r\n### Phase 4: WidgetSubsystem Refinements (2-4 hours, if needed)\r\n1. Add modal widget support to `WidgetSubsystem`\r\n2. Implement input routing for modal widgets\r\n3. Test inventory modal behavior (blocks world input)\r\n4. Test ESC key to close inventory\r\n\r\n### Phase 5: Polish and Testing (2-4 hours)\r\n1. Add durability bars for tools\r\n2. Add hover effects (optional)\r\n3. Test edge cases (full inventory, empty slots, etc.)\r\n4. Visual polish (Minecraft fidelity check)\r\n\r\n### Total Estimated Time: 18-28 hours (1 week)\r\n\r\n---\r\n\r\n**Next Steps:**\r\n1. Approve this design.md via spec-workflow\r\n2. Create tasks.md breaking down implementation into specific tasks\r\n3. Begin Phase 1 (InventoryWidget Foundation)\r\n4. Proceed sequentially through phases\r\n",
  "fileStats": {
    "size": 27349,
    "lines": 899,
    "lastModified": "2025-11-28T01:41:16.650Z"
  },
  "comments": []
}