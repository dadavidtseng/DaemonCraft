{
  "id": "snapshot_1763871638167_qwgyorvz3",
  "approvalId": "approval_1763870722299_3tmfe4esa",
  "approvalTitle": "A6 Design - Updated with Technical Debt Section",
  "version": 3,
  "timestamp": "2025-11-23T04:20:38.167Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document - Assignment 6: Player, Camera, and Physics\r\n\r\n## Overview\r\n\r\nAssignment 6 transforms SimpleMiner from a basic free-fly navigation system into a fully-featured voxel game with realistic player physics, multiple camera modes, and comprehensive collision detection. This design implements a Newtonian physics system at the Entity base class level, enabling all future game objects (Player, NPCs, projectiles) to benefit from consistent physics behavior.\r\n\r\n**Key Design Goals:**\r\n- **Entity-Based Physics**: Physics logic resides in Entity base class, not Player\r\n- **Modular Architecture**: Clean separation of physics, input, camera, and rendering systems\r\n- **Performance**: Maintain 60 FPS with efficient collision detection (raycasts, not brute-force)\r\n- **Extensibility**: Design supports future NPCs, vehicles, projectiles without modification\r\n- **Debug Support**: Multiple camera/physics modes facilitate development and testing\r\n\r\n## Technical Debt and Bug Fixes\r\n\r\nIn addition to the primary A6 implementation, this design addresses two critical technical debt items that can be resolved either before or after the main physics system implementation:\r\n\r\n### Issue 1: OpenSSL vcpkg Dependency Problem\r\n\r\n**Problem:**\r\nThe Engine's `KADIAuthenticationUtility.cpp` contains hardcoded OpenSSL includes that depend on vcpkg installation:\r\n\r\n```cpp\r\n// Current problematic includes in Engine/Code/Engine/Network/KADIAuthenticationUtility.cpp\r\n#include <openssl/evp.h>\r\n#include <openssl/rand.h>\r\n#include <openssl/bio.h>\r\n#include <openssl/buffer.h>\r\n#include <openssl/x509.h>  // For i2d_PUBKEY() and d2i_PUBKEY()\r\n```\r\n\r\n**Impact:**\r\n- Build fails on machines without vcpkg installed at `C:\\vcpkg`\r\n- Non-portable dependency management\r\n- Blocks team collaboration and buddy builds\r\n\r\n**Solution Options:**\r\n\r\n**Option A: NuGet Package Manager (Recommended)**\r\n```xml\r\n<!-- Add to Engine.vcxproj -->\r\n<ItemGroup>\r\n  <PackageReference Include=\"openssl-windows\" Version=\"3.0.0\" />\r\n</ItemGroup>\r\n```\r\n- Pros: Automatic download, version control, Visual Studio integrated\r\n- Cons: Requires NuGet.config setup\r\n\r\n**Option B: Git Submodule with CMake**\r\n```bash\r\n# Add OpenSSL as submodule\r\ngit submodule add https://github.com/openssl/openssl ThirdParty/openssl\r\ncd ThirdParty/openssl\r\ngit checkout OpenSSL_3_0_0\r\n```\r\n- Pros: Full source control, cross-platform\r\n- Cons: Requires CMake integration, longer build times\r\n\r\n**Option C: Prebuild Static Libraries (Fastest)**\r\n- Include precompiled OpenSSL `.lib` files in repository\r\n- Add include directories to project settings\r\n- Pros: Instant build, no external dependencies\r\n- Cons: Larger repository size, manual updates\r\n\r\n**Recommended Approach: Option A (NuGet)**\r\n\r\n**Implementation Steps:**\r\n1. Right-click Engine project → Manage NuGet Packages\r\n2. Install `openssl-windows` package\r\n3. Update include paths in `KADIAuthenticationUtility.cpp`:\r\n   ```cpp\r\n   // Use NuGet package includes (auto-resolved)\r\n   #include <openssl/evp.h>\r\n   #include <openssl/rand.h>\r\n   // ... etc\r\n   ```\r\n4. Test build on clean machine without vcpkg\r\n5. Document dependency in Engine README.md\r\n\r\n**Timing:** Can be fixed independently before or after A6 implementation\r\n\r\n---\r\n\r\n### Issue 2: Missing Hidden Surface Removal (A5 Requirement)\r\n\r\n**Problem:**\r\nAssignment 5 required full hidden surface removal for chunk mesh optimization, but the current implementation may not be correctly eliminating all hidden faces between adjacent solid blocks.\r\n\r\n**Expected Behavior:**\r\nWhen building chunk meshes, faces between two solid blocks should NOT be added to the vertex/index buffers:\r\n```\r\nExample: Two adjacent stone blocks\r\nBlock A (1,2,3) - STONE\r\nBlock B (2,2,3) - STONE\r\n\r\nThe +X face of Block A should NOT be rendered (hidden by Block B)\r\nThe -X face of Block B should NOT be rendered (hidden by Block A)\r\n```\r\n\r\n**Current Implementation Location:**\r\n`Code/Game/Framework/Chunk.cpp` - `AddBlockFacesWithHiddenSurfaceRemoval()` method\r\n\r\n**Verification Steps:**\r\n1. Check if the method queries adjacent block solidity before adding faces\r\n2. Ensure all 6 face directions check neighbors:\r\n   - +X face: Check if block at (x+1, y, z) is solid\r\n   - -X face: Check if block at (x-1, y, z) is solid\r\n   - +Y face: Check if block at (x, y+1, z) is solid\r\n   - -Y face: Check if block at (x, y-1, z) is solid\r\n   - +Z face: Check if block at (x, y, z+1) is solid\r\n   - -Z face: Check if block at (x, y, z-1) is solid\r\n3. Solid blocks should use `BlockDefinition::IsOpaque()` check\r\n4. Cross-chunk boundaries must query neighbor chunks correctly\r\n\r\n**Correct Implementation Pattern:**\r\n```cpp\r\nvoid Chunk::AddBlockFacesWithHiddenSurfaceRemoval(/* ... */) {\r\n    // For each block in chunk\r\n    for (int z = 0; z < CHUNK_SIZE_Z; z++) {\r\n        for (int y = 0; y < CHUNK_SIZE_Y; y++) {\r\n            for (int x = 0; x < CHUNK_SIZE_X; x++) {\r\n                Block block = GetBlock(x, y, z);\r\n                if (block.m_type == 0) continue;  // Skip air\r\n\r\n                // Check each face direction\r\n                // +X face\r\n                IntVec3 neighborCoords = IntVec3(x+1, y, z);\r\n                Block neighborBlock = GetBlockAtLocalCoords(neighborCoords);  // Handles cross-chunk\r\n                if (!IsBlockOpaque(neighborBlock)) {\r\n                    AddQuadToMesh(/* +X face vertices */);\r\n                }\r\n\r\n                // Repeat for -X, +Y, -Y, +Z, -Z faces...\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**Cross-Chunk Handling:**\r\n```cpp\r\nBlock Chunk::GetBlockAtLocalCoords(IntVec3 const& localCoords) const {\r\n    // If coords within chunk bounds, return directly\r\n    if (IsWithinBounds(localCoords)) {\r\n        return GetBlock(localCoords.x, localCoords.y, localCoords.z);\r\n    }\r\n\r\n    // If outside chunk, query neighbor chunk via World\r\n    IntVec3 worldCoords = LocalToWorldCoords(localCoords);\r\n    return m_world->GetBlockAtCoords(worldCoords);\r\n}\r\n```\r\n\r\n**Performance Impact:**\r\n- Properly culled chunks reduce vertex count by 40-60%\r\n- Improves GPU performance (fewer triangles to rasterize)\r\n- Critical for maintaining 60 FPS with large view distances\r\n\r\n**Testing:**\r\n1. Visual: Dig tunnel through solid blocks, ensure no \"internal faces\" visible\r\n2. Performance: Measure vertex count before/after fix (should decrease significantly)\r\n3. Profiling: GPU frame time should improve with fewer triangles\r\n\r\n**Timing:** Should be fixed before A6 if rendering performance is poor, or after A6 if physics is higher priority\r\n\r\n---\r\n\r\n## Steering Document Alignment\r\n\r\n### Technical Standards (tech.md)\r\n\r\n**C++ Best Practices:**\r\n- RAII for Camera resource management\r\n- Virtual functions for polymorphic Entity behavior\r\n- Const correctness for collision query methods\r\n- Enum class for type-safe mode selections\r\n\r\n**Engine Separation:**\r\n- Entity/Player in `Code/Game/Gameplay/` (game-specific)\r\n- Camera uses Engine class (no game code in Engine)\r\n- Physics uses Engine math utilities (AABB3, Vec3, raycasts)\r\n\r\n**Performance Standards:**\r\n- Fixed physics timestep prevents tunneling (120 Hz)\r\n- Corner raycasts O(12 * rayLength) vs brute AABB O(n³)\r\n- Ground detection limited to 0.02m rays (not full height)\r\n\r\n### Project Structure (structure.md)\r\n\r\n**Module Organization:**\r\n```\r\nCode/Game/\r\n├── Framework/\r\n│   ├── GameCommon.hpp         # Physics constants (GRAVITY, FRICTION, JUMP_VELOCITY)\r\n│   └── App.cpp                # Game loop calls Player::Update()\r\n├── Gameplay/\r\n│   ├── Entity.hpp/cpp         # Physics foundation (collision, gravity, friction)\r\n│   ├── Player.hpp/cpp         # Input handling, camera control\r\n│   └── World.hpp/cpp          # Collision queries (IsBlockSolid, PushEntityOutOfBlocks)\r\n└── Definition/\r\n    └── BlockDefinition.hpp    # Block solidity data\r\n```\r\n\r\n**Separation of Concerns:**\r\n- `Entity.cpp`: Physics integration and collision (no input handling)\r\n- `Player.cpp`: Input handling and camera control (no direct physics)\r\n- `World.cpp`: Block queries and collision services (no entity logic)\r\n\r\n## Code Reuse Analysis\r\n\r\n### Existing Components to Leverage\r\n\r\n**Engine Math Utilities:**\r\n- **AABB3**: Entity physics bounds, collision queries\r\n- **Vec3**: Position, velocity, acceleration vectors\r\n- **EulerAngles**: Camera orientation (pitch, yaw, roll)\r\n- **Mat44**: Transform matrices for camera view\r\n\r\n**Engine Systems:**\r\n- **Camera**: Full-featured camera class with FOV, transforms, projection\r\n- **RaycastUtils**: 3D raycast functions for collision detection\r\n- **DebugRenderSystem**: Wireframe visualization for AABB, rays, vectors\r\n\r\n**Game Systems:**\r\n- **World::RaycastVoxel()**: Amanatides & Woo algorithm (A5 implementation)\r\n- **World::GetBlockAtCoords()**: Block type queries for solidity checks\r\n- **Chunk::GetBlock()**: Direct block access for collision detection\r\n- **BlockDefinition::IsOpaque()**: Determines solid vs non-solid blocks\r\n\r\n### Integration Points\r\n\r\n**Entity → World Interface:**\r\n```cpp\r\n// World provides collision services to Entity\r\nbool World::IsBlockSolid(IntVec3 const& coords) const;\r\nvoid World::PushEntityOutOfBlocks(Entity* entity);\r\nbool World::IsEntityOnGround(Entity const* entity) const;\r\nRaycastResult3D World::RaycastVoxel(Vec3 const& start, Vec3 const& direction, float maxDist) const;\r\n```\r\n\r\n**Player → Entity Inheritance:**\r\n```cpp\r\n// Player overrides Entity virtuals\r\nvoid Player::Update(float deltaSeconds) override;    // Calls UpdateFromInput(), then Entity::Update()\r\nvoid Player::Render() const override;                // Renders AABB debug, calls DebugRender\r\n```\r\n\r\n**Player → Camera Integration:**\r\n```cpp\r\n// Player owns and controls Camera position/orientation\r\nCamera* Player::GetCamera() const;                   // Returns m_worldCamera\r\nvoid Player::UpdateCamera();                          // Sets camera transform based on mode\r\n```\r\n\r\n## Architecture\r\n\r\n### Modular Design Principles\r\n\r\n**Single Responsibility:**\r\n- **Entity**: Physics simulation only (gravity, friction, collision resolution)\r\n- **Player**: Input interpretation and camera control only\r\n- **World**: Voxel data and collision queries only\r\n- **GameCommon.hpp**: Physics constants centralized (no magic numbers)\r\n\r\n**Open/Closed Principle:**\r\n- Entity physics system is closed for modification (final methods)\r\n- Player extends Entity behavior through virtual Update() override\r\n- Future NPCs extend Entity without modifying Entity.cpp\r\n\r\n**Dependency Inversion:**\r\n- Entity depends on World interface (not Chunk implementation)\r\n- Player depends on Camera abstraction (not rendering details)\r\n- World provides abstract collision queries (not internal structures)\r\n\r\n### System Interaction Diagram\r\n\r\n```mermaid\r\ngraph TD\r\n    A[App::Update] --> B[Player::Update]\r\n    B --> C[Player::UpdateFromInput]\r\n    C --> D[Build Acceleration from WASD]\r\n    B --> E[Entity::Update]\r\n    E --> F[Entity::UpdatePhysics]\r\n    F --> G[Apply Gravity]\r\n    F --> H[Apply Friction]\r\n    F --> I[Integrate Velocity]\r\n    F --> J[World::PushEntityOutOfBlocks]\r\n    J --> K[Corner Raycast Collision]\r\n    K --> L[Zero Blocked Velocities]\r\n    E --> M[Entity::UpdateIsGrounded]\r\n    M --> N[World::IsEntityOnGround]\r\n    N --> O[4-Corner Downward Raycasts]\r\n    B --> P[Player::UpdateCamera]\r\n    P --> Q[Calculate Camera Position by Mode]\r\n    P --> R[Set Camera Transform]\r\n```\r\n\r\n### Physics Mode State Machine\r\n\r\n```mermaid\r\nstateDiagram-v2\r\n    [*] --> WALKING\r\n    WALKING --> FLYING: V key pressed\r\n    FLYING --> NOCLIP: V key pressed\r\n    NOCLIP --> WALKING: V key pressed\r\n\r\n    note right of WALKING\r\n        Gravity: ON\r\n        Collision: ON\r\n        Jump: Enabled when grounded\r\n    end note\r\n\r\n    note right of FLYING\r\n        Gravity: OFF\r\n        Collision: ON\r\n        Jump: Disabled, Q/E for vertical\r\n    end note\r\n\r\n    note right of NOCLIP\r\n        Gravity: OFF\r\n        Collision: OFF\r\n        Jump: Disabled, Q/E for vertical\r\n    end note\r\n```\r\n\r\n### Camera Mode State Machine\r\n\r\n```mermaid\r\nstateDiagram-v2\r\n    [*] --> FIRST_PERSON\r\n    FIRST_PERSON --> OVER_SHOULDER: C key pressed\r\n    OVER_SHOULDER --> SPECTATOR: C key pressed\r\n    SPECTATOR --> SPECTATOR_XY: C key pressed\r\n    SPECTATOR_XY --> INDEPENDENT: C key pressed\r\n    INDEPENDENT --> FIRST_PERSON: C key pressed\r\n\r\n    note right of FIRST_PERSON\r\n        Camera at Player eye (1.65m)\r\n        Player hidden\r\n        Mouse controls Player orientation\r\n    end note\r\n\r\n    note right of OVER_SHOULDER\r\n        Camera 4m behind Player\r\n        Player visible\r\n        Raycast prevents wall clipping\r\n    end note\r\n\r\n    note right of SPECTATOR\r\n        Player frozen\r\n        Camera moves with WASD (free 3D)\r\n        Mouse controls Camera orientation\r\n    end note\r\n\r\n    note right of SPECTATOR_XY\r\n        Player frozen\r\n        Camera XY movement only\r\n        Z position locked\r\n    end note\r\n\r\n    note right of INDEPENDENT\r\n        Player moves normally\r\n        Camera stays at spectator position\r\n        Decoupled control\r\n    end note\r\n```\r\n\r\n## Components and Interfaces\r\n\r\n### Component 1: Entity (Physics Foundation)\r\n\r\n**Purpose:** Base class providing Newtonian physics simulation for all moving game objects\r\n\r\n**File:** `Code/Game/Gameplay/Entity.hpp`, `Entity.cpp`\r\n\r\n**New Fields:**\r\n```cpp\r\nclass Entity {\r\npublic:\r\n    // Existing fields (A5)\r\n    Vec3        m_position;\r\n    Vec3        m_velocity;\r\n    EulerAngles m_orientation;\r\n\r\n    // NEW: Physics fields (A6)\r\n    AABB3       m_physicsAABB;        // Collision bounds (local space)\r\n    Vec3        m_acceleration;       // Accumulated forces this frame\r\n    bool        m_isOnGround;         // Grounded state for jump/gravity\r\n    PhysicsMode m_physicsMode;        // WALKING, FLYING, or NOCLIP\r\n\r\n    // NEW: Physics configuration\r\n    bool        m_physicsEnabled;     // Static objects disable physics\r\n    float       m_gravityCoefficient; // Multiplier for gravity (1.0 default)\r\n    float       m_frictionCoefficient;// Multiplier for friction (1.0 default)\r\n};\r\n```\r\n\r\n**Public Interface:**\r\n```cpp\r\n// Virtual methods (derived classes override)\r\nvirtual void Update(float deltaSeconds) = 0;        // Game loop calls this\r\nvirtual void Render() const = 0;                     // Rendering\r\n\r\n// Physics methods (final - derived classes cannot override)\r\nvoid UpdatePhysics(float deltaSeconds);              // Applies gravity, friction, collision\r\nvoid UpdateIsGrounded();                             // Updates m_isOnGround via raycasts\r\nvoid AddForce(Vec3 const& force);                    // Accumulates into m_acceleration\r\nvoid AddImpulse(Vec3 const& impulse);                // Instant velocity change (jump)\r\n\r\n// Configuration\r\nvoid SetPhysicsMode(PhysicsMode mode);\r\nvoid SetPhysicsEnabled(bool enabled);\r\nAABB3 GetWorldAABB() const;                          // Returns m_physicsAABB + m_position\r\n```\r\n\r\n**Dependencies:**\r\n- World (for collision queries: `IsBlockSolid`, `PushEntityOutOfBlocks`, `IsEntityOnGround`)\r\n- AABB3 (for physics bounds)\r\n- Vec3, EulerAngles (for transforms)\r\n\r\n**Reuses:**\r\n- Engine::AABB3 for collision bounds\r\n- Engine::RaycastUtils (indirectly through World)\r\n- GameCommon physics constants\r\n\r\n### Component 2: Player (Input and Camera Control)\r\n\r\n**Purpose:** Handles player-specific input interpretation and camera management\r\n\r\n**File:** `Code/Game/Gameplay/Player.hpp`, `Player.cpp`\r\n\r\n**New Fields:**\r\n```cpp\r\nclass Player : public Entity {\r\nprivate:\r\n    // Existing fields (A5)\r\n    Camera* m_worldCamera;\r\n    float   m_moveSpeed;\r\n\r\n    // NEW: Extended camera system (A6)\r\n    CameraMode  m_cameraMode;         // 5 modes: FIRST_PERSON, OVER_SHOULDER, etc.\r\n    Vec3        m_spectatorPosition;  // Camera position when in spectator modes\r\n    EulerAngles m_spectatorOrientation; // Camera orientation when in spectator modes\r\n\r\n    // NEW: Input state tracking\r\n    bool m_wasCKeyPressed;            // Debounce camera mode toggle\r\n    bool m_wasVKeyPressed;            // Debounce physics mode toggle\r\n\r\n    // NEW: Player dimensions\r\n    static constexpr float PLAYER_HEIGHT = 1.80f;\r\n    static constexpr float PLAYER_WIDTH = 0.60f;\r\n    static constexpr float PLAYER_EYE_HEIGHT = 1.65f;\r\n};\r\n```\r\n\r\n**Public Interface:**\r\n```cpp\r\n// Override Entity virtuals\r\nvoid Update(float deltaSeconds) override;            // Calls UpdateFromInput, then Entity::Update\r\nvoid Render() const override;                        // Renders AABB wireframe, debug info\r\n\r\n// Player-specific methods\r\nvoid UpdateFromInput(float deltaSeconds);            // Builds acceleration from WASD\r\nvoid UpdateCamera();                                 // Updates camera position/orientation\r\nCamera* GetCamera() const;                           // Returns m_worldCamera pointer\r\nVec3 GetEyePosition() const;                         // Returns m_position + Vec3(0,0,1.65f)\r\n\r\n// Mode controls\r\nvoid CycleCameraMode();                              // C key: cycles through 5 camera modes\r\nvoid CyclePhysicsMode();                             // V key: cycles through 3 physics modes\r\n```\r\n\r\n**Dependencies:**\r\n- Entity (base class)\r\n- Camera (Engine class, owned pointer)\r\n- InputSystem (for key states)\r\n- Game (for world access, block interaction)\r\n\r\n**Reuses:**\r\n- Entity physics system (inherits Update, collision, grounded checks)\r\n- Engine Camera class (no custom camera implementation)\r\n- World::RaycastVoxel (for OVER_SHOULDER wall clipping prevention)\r\n\r\n### Component 3: World (Collision Services)\r\n\r\n**Purpose:** Provides collision detection and block query services to Entity\r\n\r\n**File:** `Code/Game/Gameplay/World.hpp`, `World.cpp`\r\n\r\n**New Methods:**\r\n```cpp\r\nclass World {\r\npublic:\r\n    // NEW: Entity collision services (A6)\r\n    bool IsBlockSolid(IntVec3 const& coords) const;\r\n    void PushEntityOutOfBlocks(Entity* entity);\r\n    bool IsEntityOnGround(Entity const* entity) const;\r\n\r\n    // Existing raycast (A5)\r\n    RaycastResult3D RaycastVoxel(Vec3 const& start, Vec3 const& direction, float maxDist) const;\r\n\r\n    // Existing block queries (A5)\r\n    Block GetBlockAtCoords(IntVec3 const& coords) const;\r\n    BlockDefinition const* GetBlockDefAtCoords(IntVec3 const& coords) const;\r\n};\r\n```\r\n\r\n**IsBlockSolid() Algorithm:**\r\n```\r\n1. Get Block at coords using GetBlockAtCoords()\r\n2. If block.m_type == AIR (0), return false\r\n3. Get BlockDefinition* using GetBlockDefAtCoords()\r\n4. Return blockDef->IsOpaque() (solid blocks are opaque)\r\n```\r\n\r\n**PushEntityOutOfBlocks() Algorithm:**\r\n```\r\n1. Get entity world AABB (entity->GetWorldAABB())\r\n2. Calculate IntVec3 min/max coords overlapping AABB\r\n3. For each block coord in AABB range:\r\n   a. If !IsBlockSolid(coord), skip\r\n   b. Calculate block AABB (1x1x1 at coord)\r\n   c. Calculate penetration depth on X, Y, Z axes\r\n   d. Find minimum penetration axis\r\n   e. Push entity position along that axis\r\n4. Repeat until no overlaps (max 3 iterations)\r\n5. Zero entity velocity on pushed axes\r\n```\r\n\r\n**IsEntityOnGround() Algorithm:**\r\n```\r\n1. Get entity bottom AABB corners (4 corners at Z_min)\r\n2. For each corner:\r\n   a. Start ray slightly above corner (+ Vec3(0,0,0.01f))\r\n   b. Cast downward ray (direction = -Vec3::Z_AXIS)\r\n   c. Ray length = 2 * RAYCAST_OFFSET (0.02m total)\r\n   d. If RaycastVoxel hits solid block, return true\r\n3. If no rays hit, return false\r\n```\r\n\r\n**Dependencies:**\r\n- Chunk (for block data access)\r\n- BlockDefinition (for block properties)\r\n- Entity (parameter type for collision services)\r\n- RaycastUtils (for voxel raycasts)\r\n\r\n**Reuses:**\r\n- Existing chunk management system\r\n- Existing RaycastVoxel implementation (A5)\r\n- BlockDefinition::IsOpaque() for solidity checks\r\n\r\n### Component 4: GameCamera (Camera Management)\r\n\r\n**Purpose:** Manages camera positioning and orientation based on active camera mode\r\n\r\n**Implementation:** Embedded in `Player.cpp` (not a separate class)\r\n\r\n**Camera Mode Behavior:**\r\n\r\n**FIRST_PERSON:**\r\n- Position: `player.m_position + Vec3(0, 0, PLAYER_EYE_HEIGHT)`\r\n- Orientation: `player.m_orientation` (controlled by mouse)\r\n- Player rendering: Disabled (self not visible)\r\n\r\n**OVER_SHOULDER:**\r\n- Target position: Eye position - (forward * 4.0f)\r\n- Actual position: Raycast from eye to target, place at impact point\r\n- Orientation: `player.m_orientation`\r\n- Player rendering: Enabled (see self from behind)\r\n\r\n**SPECTATOR:**\r\n- Position: `m_spectatorPosition` (independent from player)\r\n- Orientation: `m_spectatorOrientation`\r\n- Movement: WASD moves camera directly (full 3D freedom)\r\n- Player: Frozen (no input applied to player)\r\n\r\n**SPECTATOR_XY:**\r\n- Position: `Vec3(m_spectatorPosition.x, m_spectatorPosition.y, lockedZ)`\r\n- Orientation: `m_spectatorOrientation`\r\n- Movement: WASD moves camera in XY plane only\r\n- Player: Frozen\r\n\r\n**INDEPENDENT:**\r\n- Position: `m_spectatorPosition` (stays at last spectator position)\r\n- Orientation: `m_spectatorOrientation`\r\n- Player: Moves normally with input\r\n- Camera: Static, does not track player\r\n\r\n**Camera Update Flow:**\r\n```cpp\r\nvoid Player::UpdateCamera() {\r\n    switch (m_cameraMode) {\r\n        case FIRST_PERSON:\r\n            m_worldCamera->SetTransform(GetEyePosition(), m_orientation);\r\n            break;\r\n\r\n        case OVER_SHOULDER:\r\n            Vec3 targetPos = GetEyePosition() - (GetForward() * 4.0f);\r\n            RaycastResult3D result = m_game->GetWorld()->RaycastVoxel(\r\n                GetEyePosition(), -GetForward(), 4.0f\r\n            );\r\n            Vec3 cameraPos = result.m_didImpact ? result.m_impactPos : targetPos;\r\n            m_worldCamera->SetTransform(cameraPos, m_orientation);\r\n            break;\r\n\r\n        case SPECTATOR:\r\n        case SPECTATOR_XY:\r\n        case INDEPENDENT:\r\n            m_worldCamera->SetTransform(m_spectatorPosition, m_spectatorOrientation);\r\n            break;\r\n    }\r\n}\r\n```\r\n\r\n## Data Models\r\n\r\n### PhysicsMode Enum\r\n\r\n```cpp\r\nenum class PhysicsMode : uint8_t {\r\n    WALKING,    // Full physics: gravity ON, collision ON, jump enabled\r\n    FLYING,     // Creative mode: gravity OFF, collision ON, Q/E vertical\r\n    NOCLIP      // Debug mode: gravity OFF, collision OFF, pass through blocks\r\n};\r\n```\r\n\r\n### CameraMode Enum\r\n\r\n```cpp\r\nenum class CameraMode : uint8_t {\r\n    FIRST_PERSON,   // Camera at eye, player hidden\r\n    OVER_SHOULDER,  // Camera 4m behind, player visible\r\n    SPECTATOR,      // Player frozen, camera free 3D movement\r\n    SPECTATOR_XY,   // Player frozen, camera XY movement only\r\n    INDEPENDENT     // Player moves, camera stays at spectator position\r\n};\r\n```\r\n\r\n### Entity Physics State\r\n\r\n```cpp\r\nstruct EntityPhysicsState {\r\n    Vec3        position;           // World position (feet)\r\n    Vec3        velocity;           // Current velocity (m/s)\r\n    Vec3        acceleration;       // Accumulated forces (m/s²)\r\n    AABB3       physicsAABB;        // Collision bounds (local space)\r\n    bool        isOnGround;         // Grounded state\r\n    PhysicsMode physicsMode;        // Current physics mode\r\n};\r\n```\r\n\r\n### Player Dimensions\r\n\r\n```cpp\r\nstruct PlayerDimensions {\r\n    static constexpr float HEIGHT = 1.80f;      // Total height (meters)\r\n    static constexpr float WIDTH = 0.60f;       // XY width (meters)\r\n    static constexpr float EYE_HEIGHT = 1.65f;  // Eye offset from feet\r\n    static constexpr float HALF_WIDTH = 0.30f;  // Half-extents for AABB\r\n    static constexpr float HALF_HEIGHT = 0.90f; // Half-extents for AABB\r\n};\r\n\r\n// Player AABB construction:\r\n// Center: Vec3(0, 0, 0.90f) relative to m_position\r\n// Half-extents: Vec3(0.30f, 0.30f, 0.90f)\r\n```\r\n\r\n## Physics Constants (GameCommon.hpp)\r\n\r\n```cpp\r\n//----------------------------------------------------------------------------------------------------\r\n// Physics System Constants (Assignment 6)\r\n//----------------------------------------------------------------------------------------------------\r\n\r\n// Gravity\r\nconstexpr float GRAVITY_ACCELERATION = -20.0f;  // m/s² (downward)\r\n\r\n// Friction coefficients\r\nconstexpr float FRICTION_GROUND = 10.0f;        // Strong damping when grounded\r\nconstexpr float FRICTION_AIR = 1.0f;            // Weak damping when airborne\r\n\r\n// Player movement\r\nconstexpr float PLAYER_WALK_ACCELERATION = 40.0f;    // m/s²\r\nconstexpr float PLAYER_SPRINT_MULTIPLIER = 20.0f;    // Shift key multiplier\r\nconstexpr float PLAYER_JUMP_VELOCITY = 8.5f;         // Instant Z velocity boost\r\nconstexpr float PLAYER_MAX_HORIZONTAL_SPEED = 20.0f; // Speed cap\r\n\r\n// Player dimensions\r\nconstexpr float PLAYER_HEIGHT = 1.80f;          // Meters\r\nconstexpr float PLAYER_WIDTH = 0.60f;           // Meters\r\nconstexpr float PLAYER_EYE_HEIGHT = 1.65f;      // Eye offset from feet\r\n\r\n// Collision detection\r\nconstexpr float RAYCAST_OFFSET = 0.01f;         // Epsilon for corner raycasts\r\nconstexpr float GROUND_CHECK_DISTANCE = 0.02f;  // Ground detection ray length\r\nconstexpr int MAX_PUSH_ITERATIONS = 3;          // Max iterations for PushEntityOutOfBlocks\r\n\r\n// Camera\r\nconstexpr float CAMERA_OVER_SHOULDER_DISTANCE = 4.0f;  // Meters behind player\r\nconstexpr float CAMERA_MOUSE_SENSITIVITY = 0.075f;     // Degrees per pixel\r\nconstexpr float CAMERA_PITCH_CLAMP_MIN = -85.0f;       // Prevent gimbal lock\r\nconstexpr float CAMERA_PITCH_CLAMP_MAX = 85.0f;\r\n\r\n// Physics timestep\r\nconstexpr float PHYSICS_FIXED_TIMESTEP = 1.0f / 120.0f; // 120 Hz (prevents tunneling)\r\n```\r\n\r\n## Algorithms\r\n\r\n### Algorithm 1: Corner Raycast Collision Detection\r\n\r\n**Purpose:** Detect and resolve entity-block collisions using 12-corner raycast method\r\n\r\n**Input:**\r\n- Entity AABB (world space)\r\n- Desired delta position (movement this frame)\r\n\r\n**Output:**\r\n- Corrected delta position (blocked axes zeroed)\r\n- Updated entity velocity (blocked axes zeroed)\r\n\r\n**Steps:**\r\n```\r\n1. Calculate 12 corner positions from entity AABB:\r\n   - 4 bottom corners (Z_min)\r\n   - 4 mid-body corners (Z_center)\r\n   - 4 top corners (Z_max)\r\n   - For XY: (X_min, Y_min), (X_max, Y_min), (X_min, Y_max), (X_max, Y_max)\r\n\r\n2. For each corner:\r\n   a. Ray start = corner + (raycastOffset in delta direction)\r\n   b. Ray direction = deltaPosition.GetNormalized()\r\n   c. Ray length = deltaPosition.GetLength() + raycastOffset\r\n   d. Cast ray using World::RaycastVoxel()\r\n   e. If impact with solid block:\r\n      - Store impact distance\r\n      - Store impact normal\r\n\r\n3. Analyze impacts per axis:\r\n   X-axis: Find closest impact with normal.x != 0\r\n   Y-axis: Find closest impact with normal.y != 0\r\n   Z-axis: Find closest impact with normal.z != 0\r\n\r\n4. For each blocked axis:\r\n   a. Zero deltaPosition component\r\n   b. Zero entity velocity component\r\n\r\n5. Apply remaining (unblocked) deltaPosition to entity position\r\n```\r\n\r\n**Complexity:** O(12 * rayLength) - Linear in ray distance, constant in block count\r\n\r\n**Advantages over AABB Sweep:**\r\n- No tunneling through thin walls (raycasts always detect)\r\n- Cheaper than swept AABB (no continuous collision detection)\r\n- Works with non-axis-aligned movement\r\n\r\n### Algorithm 2: Ground Detection (4-Corner Raycast)\r\n\r\n**Purpose:** Determine if entity is standing on solid ground\r\n\r\n**Input:**\r\n- Entity AABB (world space)\r\n\r\n**Output:**\r\n- Boolean: true if grounded, false if airborne\r\n\r\n**Steps:**\r\n```\r\n1. Get bottom 4 corners of entity AABB:\r\n   corners = [\r\n       (AABB.min.x, AABB.min.y, AABB.min.z),\r\n       (AABB.max.x, AABB.min.y, AABB.min.z),\r\n       (AABB.min.x, AABB.max.y, AABB.min.z),\r\n       (AABB.max.x, AABB.max.y, AABB.min.z)\r\n   ]\r\n\r\n2. For each corner:\r\n   a. Ray start = corner + Vec3(0, 0, RAYCAST_OFFSET)  // Lift slightly above floor\r\n   b. Ray direction = Vec3(0, 0, -1)  // Straight down\r\n   c. Ray length = 2 * RAYCAST_OFFSET  // Very short ray (0.02m total)\r\n   d. Cast ray using World::RaycastVoxel()\r\n   e. If ray hits solid block:\r\n      return true  // Grounded\r\n\r\n3. If no rays hit:\r\n   return false  // Airborne\r\n```\r\n\r\n**Rationale for 4 Corners:**\r\n- Detects grounded when standing on edge of block\r\n- Detects grounded when straddling 2+ blocks\r\n- Single center point would fail on edges\r\n\r\n**Rationale for Short Rays:**\r\n- Performance: Only checks immediate vicinity (not full height)\r\n- Accuracy: Prevents false positives from blocks far below\r\n\r\n### Algorithm 3: Newtonian Physics Integration (Euler Method)\r\n\r\n**Purpose:** Update entity position and velocity based on forces\r\n\r\n**Input:**\r\n- Current position, velocity, acceleration\r\n- Delta time\r\n\r\n**Output:**\r\n- Updated position and velocity\r\n\r\n**Steps:**\r\n```\r\n1. Apply gravity (if applicable):\r\n   IF (physicsMode == WALKING && !isOnGround):\r\n       acceleration.z += GRAVITY_ACCELERATION\r\n\r\n2. Apply friction:\r\n   Vec2 horizontalVelocity = Vec2(velocity.x, velocity.y)\r\n   float frictionCoeff = isOnGround ? FRICTION_GROUND : FRICTION_AIR\r\n   Vec2 frictionForce = -horizontalVelocity * frictionCoeff\r\n   acceleration.x += frictionForce.x\r\n   acceleration.y += frictionForce.y\r\n\r\n3. Integrate velocity (Euler method):\r\n   velocity += acceleration * deltaTime\r\n\r\n4. Clamp horizontal speed:\r\n   Vec2 horizontalVel = Vec2(velocity.x, velocity.y)\r\n   IF (horizontalVel.GetLength() > PLAYER_MAX_HORIZONTAL_SPEED):\r\n       horizontalVel = horizontalVel.GetNormalized() * PLAYER_MAX_HORIZONTAL_SPEED\r\n       velocity.x = horizontalVel.x\r\n       velocity.y = horizontalVel.y\r\n\r\n5. Calculate delta position:\r\n   deltaPosition = velocity * deltaTime\r\n\r\n6. Collision detection and resolution:\r\n   IF (physicsMode != NOCLIP):\r\n       PerformCornerRaycastCollision(deltaPosition)  // Modifies deltaPosition and velocity\r\n\r\n7. Integrate position:\r\n   position += deltaPosition\r\n\r\n8. Reset acceleration for next frame:\r\n   acceleration = Vec3::ZERO\r\n```\r\n\r\n**Why Euler (not Verlet/RK4):**\r\n- Simple and fast (good for 60 FPS target)\r\n- Sufficient accuracy for gameplay (not scientific simulation)\r\n- Industry standard for game physics\r\n\r\n### Algorithm 4: Push Entity Out of Blocks\r\n\r\n**Purpose:** Resolve entity stuck in blocks (e.g., after teleport, chunk load)\r\n\r\n**Input:**\r\n- Entity with world AABB\r\n\r\n**Output:**\r\n- Entity position adjusted to nearest non-overlapping position\r\n\r\n**Steps:**\r\n```\r\n1. Get entity world AABB bounds\r\n2. Calculate IntVec3 min/max block coords overlapping AABB\r\n3. iterations = 0\r\n4. WHILE (overlaps exist && iterations < MAX_PUSH_ITERATIONS):\r\n   a. FOR each block coord in [min, max] range:\r\n      - IF !IsBlockSolid(coord), continue\r\n      - Calculate block AABB (1x1x1 cube at coord)\r\n      - IF entity AABB intersects block AABB:\r\n         * Calculate penetration on X, Y, Z axes\r\n         * Find minimum penetration axis\r\n         * Push entity position along that axis to resolve\r\n         * Break (only fix one overlap per iteration)\r\n   b. Zero entity velocity on pushed axes\r\n   c. iterations++\r\n5. IF (iterations >= MAX_PUSH_ITERATIONS):\r\n   DebugLog(\"Entity stuck in blocks after max iterations\")\r\n```\r\n\r\n**Why Iterative:**\r\n- Single push may create new overlaps\r\n- Max 3 iterations prevents infinite loops\r\n- Each iteration resolves shortest penetration (optimal)\r\n\r\n## Error Handling\r\n\r\n### Error Scenario 1: Entity Tunneling Through Blocks\r\n\r\n**Description:** Fast-moving entity skips over thin walls (deltaPosition > block thickness)\r\n\r\n**Handling:**\r\n- Use fixed physics timestep (120 Hz) to limit max deltaPosition per step\r\n- At 120 Hz with max speed 20 m/s: max distance = 20 / 120 = 0.166m per step\r\n- This prevents skipping 1-block (1m) thick walls\r\n- Corner raycasts detect all intermediate blocks along path\r\n\r\n**User Impact:**\r\n- None (prevented by design)\r\n- Worst case: entity slows down slightly when approaching max speed\r\n\r\n### Error Scenario 2: Camera Clipping Through Walls (OVER_SHOULDER)\r\n\r\n**Description:** Camera placed 4m behind player ends up inside blocks\r\n\r\n**Handling:**\r\n```cpp\r\n// Raycast from eye to desired camera position\r\nVec3 eyePos = GetEyePosition();\r\nVec3 desiredCameraPos = eyePos - (GetForward() * 4.0f);\r\nRaycastResult3D result = World::RaycastVoxel(eyePos, -GetForward(), 4.0f);\r\n\r\nif (result.m_didImpact) {\r\n    // Wall detected - place camera at impact point (slightly offset)\r\n    Vec3 actualCameraPos = result.m_impactPos + (result.m_impactNormal * 0.1f);\r\n    m_worldCamera->SetTransform(actualCameraPos, m_orientation);\r\n} else {\r\n    // No wall - use full 4m distance\r\n    m_worldCamera->SetTransform(desiredCameraPos, m_orientation);\r\n}\r\n```\r\n\r\n**User Impact:**\r\n- Camera automatically pulls forward when backing into walls\r\n- Prevents seeing \"inside\" of blocks (immersion maintained)\r\n\r\n### Error Scenario 3: Entity Falls While Chunk Below is Loading\r\n\r\n**Description:** Player walks off edge of loaded chunks, chunk below not yet activated\r\n\r\n**Handling:**\r\n```cpp\r\nvoid Entity::UpdatePhysics(float deltaSeconds) {\r\n    // Check if chunk below exists\r\n    IntVec3 chunkCoordsBelow = World::GetChunkCoordsForWorldPos(m_position + Vec3(0,0,-5));\r\n    Chunk* chunkBelow = m_game->GetWorld()->GetChunkAtCoords(chunkCoordsBelow);\r\n\r\n    if (chunkBelow == nullptr || chunkBelow->GetState() != ChunkState::ACTIVE) {\r\n        // Chunk not loaded - freeze vertical velocity\r\n        m_velocity.z = 0.0f;\r\n        m_acceleration.z = 0.0f;\r\n        return;  // Skip physics this frame\r\n    }\r\n\r\n    // Normal physics continues...\r\n}\r\n```\r\n\r\n**User Impact:**\r\n- Player hovers at chunk boundary until chunk loads\r\n- Better than falling into void or crashing\r\n- Visual feedback: \"Loading chunks...\" message\r\n\r\n### Error Scenario 4: Getting Stuck in Blocks After Mode Switch\r\n\r\n**Description:** Switching from NOCLIP to WALKING/FLYING while inside blocks\r\n\r\n**Handling:**\r\n```cpp\r\nvoid Player::CyclePhysicsMode() {\r\n    // Old mode\r\n    PhysicsMode oldMode = m_physicsMode;\r\n\r\n    // Cycle to next mode\r\n    m_physicsMode = static_cast<PhysicsMode>((static_cast<int>(m_physicsMode) + 1) % 3);\r\n\r\n    // If switching from NOCLIP to collision-enabled mode\r\n    if (oldMode == PhysicsMode::NOCLIP && m_physicsMode != PhysicsMode::NOCLIP) {\r\n        // Attempt to push out of blocks\r\n        m_game->GetWorld()->PushEntityOutOfBlocks(this);\r\n\r\n        // If still stuck after push, revert to NOCLIP\r\n        if (IsStuckInBlocks()) {\r\n            m_physicsMode = PhysicsMode::NOCLIP;\r\n            DebugLog(\"Cannot exit NOCLIP - stuck in blocks\");\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**User Impact:**\r\n- Safe mode switching (no instant death)\r\n- Clear feedback when stuck\r\n- Must navigate to free space before exiting NOCLIP\r\n\r\n### Error Scenario 5: Diagonal Movement Speed Exploit\r\n\r\n**Description:** Pressing W+D simultaneously gives √2 faster movement (vector addition)\r\n\r\n**Handling:**\r\n```cpp\r\nvoid Player::UpdateFromInput(float deltaSeconds) {\r\n    Vec3 localMovement = Vec3::ZERO;\r\n\r\n    if (IsKeyDown('W')) localMovement.x += 1.0f;  // Forward\r\n    if (IsKeyDown('S')) localMovement.x -= 1.0f;  // Backward\r\n    if (IsKeyDown('D')) localMovement.y += 1.0f;  // Right\r\n    if (IsKeyDown('A')) localMovement.y -= 1.0f;  // Left\r\n\r\n    // FIX: Normalize before applying speed\r\n    if (localMovement.GetLengthSquared() > 0.0f) {\r\n        localMovement = localMovement.GetNormalized();  // Length = 1.0\r\n    }\r\n\r\n    // Transform to world space and apply acceleration\r\n    Vec3 worldMovement = TransformToWorldSpace(localMovement);\r\n    m_acceleration += worldMovement * PLAYER_WALK_ACCELERATION;\r\n}\r\n```\r\n\r\n**User Impact:**\r\n- Fair movement speed in all directions\r\n- No exploits or advantages from diagonal movement\r\n\r\n## Testing Strategy\r\n\r\n### Unit Testing\r\n\r\n**Entity Physics Tests:**\r\n```cpp\r\n// Test 1: Gravity applies only when not grounded in WALKING mode\r\nEntity* entity = new Entity(game);\r\nentity->SetPhysicsMode(PhysicsMode::WALKING);\r\nentity->m_isOnGround = false;\r\nentity->UpdatePhysics(0.1f);  // 100ms\r\nEXPECT_EQ(entity->m_velocity.z, GRAVITY_ACCELERATION * 0.1f);\r\n\r\n// Test 2: Friction decelerates horizontal velocity\r\nentity->m_velocity = Vec3(10.0f, 0.0f, 0.0f);\r\nentity->m_isOnGround = true;\r\nentity->UpdatePhysics(0.1f);\r\nEXPECT_LT(entity->m_velocity.x, 10.0f);  // Should slow down\r\n\r\n// Test 3: NOCLIP mode skips collision\r\nentity->SetPhysicsMode(PhysicsMode::NOCLIP);\r\nentity->m_position = Vec3(0, 0, 0);  // Inside ground\r\nentity->UpdatePhysics(0.1f);\r\nEXPECT_EQ(entity->m_position.z, entity->m_velocity.z * 0.1f);  // Moved without collision\r\n```\r\n\r\n**Ground Detection Tests:**\r\n```cpp\r\n// Test 4: Grounded when standing on block\r\nWorld* world = CreateTestWorld();  // World with flat ground at Z=0\r\nEntity* entity = new Entity(game);\r\nentity->m_position = Vec3(0, 0, 1.0f);  // Standing on ground\r\nentity->UpdateIsGrounded();\r\nEXPECT_TRUE(entity->m_isOnGround);\r\n\r\n// Test 5: Airborne when no blocks below\r\nentity->m_position = Vec3(0, 0, 10.0f);  // High in air\r\nentity->UpdateIsGrounded();\r\nEXPECT_FALSE(entity->m_isOnGround);\r\n\r\n// Test 6: Grounded when on edge of block\r\nentity->m_position = Vec3(0.95f, 0.95f, 1.0f);  // Corner of block\r\nentity->UpdateIsGrounded();\r\nEXPECT_TRUE(entity->m_isOnGround);  // 4-corner detection catches this\r\n```\r\n\r\n**Collision Detection Tests:**\r\n```cpp\r\n// Test 7: Entity stops when hitting wall\r\nentity->m_position = Vec3(5.5f, 0, 1);  // Next to wall at X=6\r\nentity->m_velocity = Vec3(2.0f, 0, 0);  // Moving toward wall\r\nentity->UpdatePhysics(1.0f);\r\nEXPECT_LT(entity->m_position.x, 6.0f);  // Stopped before wall\r\nEXPECT_EQ(entity->m_velocity.x, 0.0f);  // Velocity zeroed\r\n\r\n// Test 8: Entity slides along walls\r\nentity->m_velocity = Vec3(1.0f, 1.0f, 0);  // Diagonal into wall\r\nentity->UpdatePhysics(1.0f);\r\nEXPECT_LT(entity->m_velocity.x, 1.0f);  // X blocked\r\nEXPECT_EQ(entity->m_velocity.y, 1.0f);  // Y unblocked, continues\r\n```\r\n\r\n### Integration Testing\r\n\r\n**Player Movement Integration:**\r\n```cpp\r\n// Test 9: Jump only works when grounded in WALKING mode\r\nPlayer* player = new Player(game);\r\nplayer->SetPhysicsMode(PhysicsMode::WALKING);\r\nplayer->m_position = Vec3(0, 0, 1);\r\nplayer->UpdateIsGrounded();  // Should be grounded on flat world\r\n\r\n// Simulate spacebar press\r\nplayer->m_isJumpKeyPressed = true;\r\nplayer->UpdateFromInput(0.016f);  // 60 FPS frame\r\nEXPECT_EQ(player->m_velocity.z, PLAYER_JUMP_VELOCITY);\r\n\r\n// Test 10: Jump doesn't work when airborne\r\nplayer->m_velocity.z = 0.0f;\r\nplayer->m_isOnGround = false;\r\nplayer->UpdateFromInput(0.016f);\r\nEXPECT_EQ(player->m_velocity.z, 0.0f);  // No double-jump\r\n```\r\n\r\n**Camera Mode Integration:**\r\n```cpp\r\n// Test 11: FIRST_PERSON camera at eye position\r\nplayer->SetCameraMode(CameraMode::FIRST_PERSON);\r\nplayer->m_position = Vec3(0, 0, 0);\r\nplayer->UpdateCamera();\r\nVec3 expectedCameraPos = Vec3(0, 0, PLAYER_EYE_HEIGHT);\r\nEXPECT_VEC3_NEAR(player->GetCamera()->GetPosition(), expectedCameraPos, 0.01f);\r\n\r\n// Test 12: OVER_SHOULDER camera 4m behind (no walls)\r\nplayer->SetCameraMode(CameraMode::OVER_SHOULDER);\r\nplayer->m_orientation = EulerAngles(0, 0, 0);  // Facing +X\r\nplayer->UpdateCamera();\r\nVec3 expectedCameraPos = Vec3(-4.0f, 0, PLAYER_EYE_HEIGHT);\r\nEXPECT_VEC3_NEAR(player->GetCamera()->GetPosition(), expectedCameraPos, 0.01f);\r\n```\r\n\r\n**World Collision Service Integration:**\r\n```cpp\r\n// Test 13: PushEntityOutOfBlocks resolves overlaps\r\nEntity* entity = new Entity(game);\r\nentity->m_physicsAABB = AABB3(Vec3(-0.3f, -0.3f, 0), Vec3(0.3f, 0.3f, 1.8f));\r\nentity->m_position = Vec3(5.5f, 5.5f, 0.5f);  // Overlapping block at (5,5,0)\r\n\r\nworld->PushEntityOutOfBlocks(entity);\r\nAABB3 worldAABB = entity->GetWorldAABB();\r\n// Entity should be pushed out - no longer overlapping solid blocks\r\nEXPECT_FALSE(WorldAABBOverlapsSolidBlocks(world, worldAABB));\r\n```\r\n\r\n### End-to-End Testing\r\n\r\n**E2E Test 1: Player Navigation**\r\n```\r\n1. Start game in WALKING mode, FIRST_PERSON camera\r\n2. Press W key for 2 seconds → Player moves forward smoothly\r\n3. Press Space → Player jumps ~1.2m high, lands smoothly\r\n4. Walk off cliff → Player falls with gravity, lands with impact (velocity zeroed)\r\n5. Expected: Smooth movement, no jitter, no tunneling through blocks\r\n```\r\n\r\n**E2E Test 2: Camera Mode Cycling**\r\n```\r\n1. Press C key → Camera switches to OVER_SHOULDER\r\n   - Verify: See player model from behind\r\n2. Press C key → Camera switches to SPECTATOR\r\n   - Verify: Player frozen, WASD moves camera freely\r\n3. Press C key → Camera switches to SPECTATOR_XY\r\n   - Verify: WASD moves camera in XY only, Z locked\r\n4. Press C key → Camera switches to INDEPENDENT\r\n   - Verify: Player moves, camera stays at spectator position\r\n5. Press C key → Camera switches back to FIRST_PERSON\r\nExpected: All 5 modes work correctly, smooth transitions\r\n```\r\n\r\n**E2E Test 3: Physics Mode Cycling**\r\n```\r\n1. Start in WALKING mode → Walk on ground, affected by gravity\r\n2. Press V → Switch to FLYING mode\r\n   - Verify: No gravity, can press Q/E to move up/down\r\n   - Verify: Still collides with blocks (cannot enter walls)\r\n3. Press V → Switch to NOCLIP mode\r\n   - Verify: Can fly through walls and blocks\r\n   - Verify: Q/E still work for vertical movement\r\n4. Press V → Switch back to WALKING mode\r\n   - Verify: Gravity resumes, falls if airborne\r\nExpected: All 3 modes work correctly, no crashes or stuck states\r\n```\r\n\r\n**E2E Test 4: Stress Test (Performance)**\r\n```\r\n1. Generate world with many chunks active\r\n2. Jump off tall mountain (100+ meter fall)\r\n3. Hold Sprint (Shift) and run diagonally across terrain\r\n4. Rapidly toggle between camera modes (mash C key)\r\n5. Rapidly toggle between physics modes (mash V key)\r\nExpected: 60 FPS maintained, no crashes, no tunneling\r\n```\r\n\r\n**E2E Test 5: Edge Case Coverage**\r\n```\r\n1. Enable NOCLIP, fly into solid blocks\r\n2. Switch to WALKING while inside blocks\r\n   - Expected: Either pushed out, or mode switch prevented\r\n3. Stand on 1-block-wide pillar edge\r\n   - Expected: Grounded detection works (4-corner method)\r\n4. Back into wall in OVER_SHOULDER mode\r\n   - Expected: Camera pulls forward, doesn't clip through wall\r\n5. Walk off chunk boundary (unloaded chunks)\r\n   - Expected: Player freezes or falls gracefully (no crash)\r\n```\r\n\r\n## Performance Optimizations\r\n\r\n### Optimization 1: Fixed Physics Timestep\r\n\r\n**Problem:** Variable delta time causes inconsistent physics, tunneling at high framerates\r\n\r\n**Solution:**\r\n```cpp\r\nvoid Player::Update(float deltaSeconds) {\r\n    // Clamp delta time to prevent physics instability\r\n    float clampedDelta = Clamp(deltaSeconds, 1.0f/120.0f, 1.0f/15.0f);\r\n\r\n    UpdateFromInput(clampedDelta);\r\n    Entity::Update(clampedDelta);  // Calls UpdatePhysics internally\r\n    UpdateCamera();\r\n}\r\n```\r\n\r\n**Benefit:**\r\n- Prevents tunneling (max deltaPosition = 0.166m at 20 m/s)\r\n- Consistent physics regardless of framerate\r\n- Overhead: <1ms per frame\r\n\r\n### Optimization 2: Ground Detection Ray Length\r\n\r\n**Problem:** Full-height raycasts (1.8m) every frame wasteful\r\n\r\n**Solution:**\r\n- Use 0.02m rays (2 * RAYCAST_OFFSET)\r\n- Only detect immediate ground contact\r\n- 90x shorter rays = 90x faster raycasts\r\n\r\n**Benefit:**\r\n- Reduces ground check from ~2ms to <0.05ms\r\n- Still accurate (detects all grounded cases)\r\n\r\n### Optimization 3: Corner Raycast vs AABB Overlap\r\n\r\n**Problem:** Checking every block in AABB range is O(n³)\r\n\r\n**Solution:**\r\n- 12 corner raycasts = O(12 * rayLength)\r\n- Typical rayLength ~0.3m at 60 FPS → ~4 blocks checked per ray\r\n- Total: 48 block checks vs 1000+ for brute AABB\r\n\r\n**Benefit:**\r\n- 20x faster collision detection\r\n- No false negatives (raycasts always detect)\r\n\r\n### Optimization 4: Early Exit for NOCLIP\r\n\r\n**Problem:** Running full physics logic when collision disabled\r\n\r\n**Solution:**\r\n```cpp\r\nvoid Entity::UpdatePhysics(float deltaSeconds) {\r\n    if (m_physicsMode == PhysicsMode::NOCLIP) {\r\n        // Skip gravity, friction, collision\r\n        m_position += m_velocity * deltaSeconds;\r\n        m_acceleration = Vec3::ZERO;\r\n        return;\r\n    }\r\n\r\n    // Full physics for WALKING/FLYING modes...\r\n}\r\n```\r\n\r\n**Benefit:**\r\n- NOCLIP mode runs at <0.1ms (vs 1-2ms for full physics)\r\n- Useful for spectator cameras, debug flying\r\n\r\n### Optimization 5: Camera Update Only When Active\r\n\r\n**Problem:** Updating camera transform every frame wasteful if not rendering\r\n\r\n**Solution:**\r\n```cpp\r\nvoid Player::UpdateCamera() {\r\n    // Only update if camera is the active view camera\r\n    if (m_worldCamera != m_game->GetActiveCamera()) {\r\n        return;\r\n    }\r\n\r\n    // Calculate and set camera transform...\r\n}\r\n```\r\n\r\n**Benefit:**\r\n- Saves ~0.2ms when player camera not active\r\n- Useful for splitscreen or cinematic cameras\r\n\r\n## Migration and Deployment\r\n\r\n### Phase 1: Entity Physics Foundation (Week 1)\r\n\r\n**Tasks:**\r\n1. Add physics fields to Entity.hpp (AABB3, acceleration, isOnGround, physicsMode)\r\n2. Implement Entity::UpdatePhysics() (gravity, friction, Euler integration)\r\n3. Implement Entity::UpdateIsGrounded() (4-corner raycast)\r\n4. Add physics constants to GameCommon.hpp\r\n5. Test: Entity falls with gravity, friction decelerates\r\n\r\n**Deliverable:** Entity class with working physics simulation\r\n\r\n### Phase 2: World Collision Services (Week 1)\r\n\r\n**Tasks:**\r\n1. Implement World::IsBlockSolid() (block type + opacity check)\r\n2. Implement World::PushEntityOutOfBlocks() (iterative push algorithm)\r\n3. Implement World::IsEntityOnGround() (4 downward raycasts)\r\n4. Test: Entity stops at walls, doesn't tunnel, detects ground correctly\r\n\r\n**Deliverable:** World provides collision services to Entity\r\n\r\n### Phase 3: Player Input and Movement (Week 2)\r\n\r\n**Tasks:**\r\n1. Update Player::UpdateFromInput() (build acceleration from WASD)\r\n2. Add jump logic (Space key, only when grounded)\r\n3. Add sprint modifier (Shift key, 20x multiplier)\r\n4. Implement physics mode cycling (V key)\r\n5. Test: Player moves smoothly, jumps work, modes switch correctly\r\n\r\n**Deliverable:** Player with full input-driven movement\r\n\r\n### Phase 4: Camera System (Week 2)\r\n\r\n**Tasks:**\r\n1. Add CameraMode enum and m_cameraMode field\r\n2. Implement 5 camera modes in UpdateCamera()\r\n3. Add camera mode cycling (C key)\r\n4. Implement OVER_SHOULDER wall clipping prevention\r\n5. Test: All 5 camera modes work, smooth transitions\r\n\r\n**Deliverable:** Complete camera system with all modes\r\n\r\n### Phase 5: Debug Visualization (Week 3)\r\n\r\n**Tasks:**\r\n1. Render Entity AABB wireframe (cyan)\r\n2. Render ground detection rays (green/red)\r\n3. Add on-screen mode display (camera, physics)\r\n4. Add FPS counter\r\n5. Test: Debug visuals help diagnose issues\r\n\r\n**Deliverable:** Full debug visualization suite\r\n\r\n### Phase 6: Polish and Performance (Week 3)\r\n\r\n**Tasks:**\r\n1. Add DebugInline and FastBreak build configs\r\n2. Profile physics system (target <2ms per frame)\r\n3. Fix any jitter or tunneling issues\r\n4. Validate 60 FPS in Release mode\r\n5. Final testing and bug fixes\r\n\r\n**Deliverable:** Production-ready A6 implementation\r\n\r\n## Acceptance Criteria Summary\r\n\r\n### Functional Requirements\r\n- ✅ Entity base class provides physics for all moving objects\r\n- ✅ Player derives from Entity, inherits physics behavior\r\n- ✅ Newtonian physics (gravity, friction, acceleration)\r\n- ✅ Entity-world collision detection prevents entering blocks\r\n- ✅ Ground detection enables jumping and gravity\r\n- ✅ WASD controls with sprint (Shift) and jump (Space)\r\n- ✅ 5 camera modes cycle with C key\r\n- ✅ 3 physics modes cycle with V key\r\n- ✅ Debug visualization (AABB, rays, on-screen info)\r\n\r\n### Non-Functional Requirements\r\n- ✅ 60 FPS in Release mode during gameplay\r\n- ✅ No compiler warnings\r\n- ✅ Clean Entity→Player inheritance (physics in base class)\r\n- ✅ All 4 build configs build successfully\r\n- ✅ No tunneling through blocks (up to 50m fall)\r\n- ✅ No jitter when standing or walking\r\n\r\n### Code Quality\r\n- ✅ Physics constants in GameCommon.hpp (no magic numbers)\r\n- ✅ Single responsibility (Entity=physics, Player=input, World=collision)\r\n- ✅ Clean interfaces (World provides collision services)\r\n- ✅ Extensible design (NPCs use same physics system)\r\n- ✅ Comprehensive debug visualization for development\r\n",
  "fileStats": {
    "size": 47829,
    "lines": 1377,
    "lastModified": "2025-11-23T04:05:12.222Z"
  },
  "comments": []
}