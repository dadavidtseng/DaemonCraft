{
  "id": "snapshot_1763981393388_lxm9c98s3",
  "approvalId": "approval_1763979153637_h573vy3m7",
  "approvalTitle": "Review A7 Requirements: Registry, Inventory, UI, and AI Agents",
  "version": 2,
  "timestamp": "2025-11-24T10:49:53.387Z",
  "trigger": "revision_requested",
  "status": "pending",
  "content": "# Assignment 7: Registry System, Inventory, UI, and AI Agent Integration\r\n\r\n**Due Date:** December 12, 2025\r\n**Estimated Duration:** 3-4 weeks\r\n**Complexity:** High (Multi-system integration)\r\n\r\n---\r\n\r\n## Executive Summary\r\n\r\nAssignment 7 implements a comprehensive gameplay and AI integration system for SimpleMiner, featuring:\r\n\r\n1. **Minecraft-style Registry System** - Data-driven architecture for blocks, items, and entities\r\n2. **Inventory System** - Player item storage with hotbar and full inventory management\r\n3. **Mining & Placement Mechanics** - Progressive block breaking and item-based placement\r\n4. **Minecraft-style UI** - HUD with hotbar, full inventory screen, and crafting interface\r\n5. **AI Agent Framework** - KADI-integrated agents that can autonomously play the game\r\n\r\nThis assignment transforms SimpleMiner from a terrain exploration sandbox into a playable voxel game with intelligent AI agents that can mine, build, and interact with the world through Claude Desktop/Code commands.\r\n\r\n---\r\n\r\n## Project Context\r\n\r\n### Current State (Post-A6)\r\n\r\n**Existing Systems:**\r\n- ✅ Newtonian physics with gravity, friction, collision detection (Entity.cpp)\r\n- ✅ 5 camera modes (FIRST_PERSON, OVER_SHOULDER, SPECTATOR, etc.)\r\n- ✅ 3 physics modes (WALKING, FLYING, NOCLIP)\r\n- ✅ BlockDefinition system with XML loading\r\n- ✅ Chunk-based world with async generation/loading\r\n- ✅ WidgetSubsystem for DirectX 11 UI rendering (Engine)\r\n- ✅ V8 JavaScript integration (currently unused)\r\n\r\n**Available Infrastructure:**\r\n- Engine WidgetSubsystem: DX11-based UI rendering with z-ordering, owner-based grouping\r\n- BlockDefinition: Static XML-driven block properties (s_definitions vector)\r\n- Entity system: Physics-enabled base class for dynamic objects\r\n- Player: Entity with camera and input handling\r\n- Existing KADI prototype: ProtogameJS3D + Agent_TypeScript + kadi-broker working integration\r\n\r\n### Target State (Post-A7)\r\n\r\n**New Systems:**\r\n- ✅ Registry<T> template for type-safe ID management\r\n- ✅ ItemRegistry, enhanced BlockRegistry, RecipeRegistry\r\n- ✅ ItemStack data structure with quantity and type\r\n- ✅ Player inventory (36 slots: 27 main + 9 hotbar)\r\n- ✅ Mining mechanics (progressive break, block → item drop)\r\n- ✅ Placement mechanics (consume inventory, place block)\r\n- ✅ HUD with hotbar, crosshair, item counts\r\n- ✅ Inventory screen with mouse interaction\r\n- ✅ 2×2 crafting system with recipe matching\r\n- ✅ AIAgent entity class with command queue\r\n- ✅ KADI broker C++ integration for game state exposure\r\n- ✅ TypeScript agent framework for autonomous behavior\r\n\r\n---\r\n\r\n## Goals and Objectives\r\n\r\n### Primary Goals\r\n\r\n1. **Registry Architecture** - Establish Minecraft-inspired data-driven foundation\r\n2. **Core Gameplay Loop** - Enable mine → collect → craft → build cycle\r\n3. **UI Polish** - Create intuitive Minecraft-style interface with WidgetSubsystem\r\n4. **AI Integration** - Allow Claude Desktop to control in-game agents via KADI\r\n\r\n### Secondary Goals\r\n\r\n1. **Debug UI Enhancement** - Transform F3 debug overlay to Minecraft style\r\n2. **Performance** - Maintain 60 FPS with inventory UI and multiple AI agents\r\n3. **Extensibility** - Design for future expansion (more items, recipes, agent behaviors)\r\n4. **Code Quality** - Clean separation between data (Registry) and logic (Game systems)\r\n\r\n### Non-Goals (Explicitly Out of Scope)\r\n\r\n- ❌ Mob AI system (deferred to A8)\r\n- ❌ Combat/damage system\r\n- ❌ Advanced crafting (3×3 grid, workbench)\r\n- ❌ Health/hunger bars\r\n- ❌ Armor system\r\n- ❌ Sound effects for mining/placing/crafting\r\n- ❌ Particle effects\r\n- ❌ Multiplayer networking\r\n\r\n---\r\n\r\n## Functional Requirements\r\n\r\n### FR-1: Registry System\r\n\r\n#### FR-1.1: Generic Registry Template\r\n**Description**: Implement type-safe registry pattern for managing game objects with persistent IDs.\r\n\r\n**Requirements**:\r\n- Template class `Registry<T>` supporting any type\r\n- Numeric ID assignment (uint16_t for 65,535 entries)\r\n- String name → ID lookup (case-insensitive)\r\n- ID → Object pointer lookup\r\n- Registration order preservation\r\n- Thread-safe read access (write happens during startup only)\r\n\r\n**Acceptance Criteria**:\r\n```cpp\r\nRegistry<BlockDefinition> blockRegistry;\r\nblockRegistry.Register(\"stone\", stoneDefPtr);\r\nuint16_t stoneID = blockRegistry.GetID(\"stone\");  // Returns stable ID\r\nBlockDefinition* def = blockRegistry.Get(stoneID); // O(1) lookup\r\n```\r\n\r\n#### FR-1.2: Block Registry\r\n**Description**: Migrate existing BlockDefinition system to Registry pattern.\r\n\r\n**Requirements**:\r\n- Replace static `s_definitions` vector with `BlockRegistry` singleton\r\n- Preserve AIR as ID 0\r\n- Maintain XML loading order for compatibility\r\n- Support by-name and by-ID lookup\r\n- No breaking changes to existing Chunk code\r\n\r\n**Acceptance Criteria**:\r\n- All existing block types (GRASS, STONE, DIRT, etc.) load correctly\r\n- `Block::GetDefinition()` still works via registry lookup\r\n- XML definitions load in same order as before\r\n\r\n#### FR-1.3: Item Registry\r\n**Description**: Create item system with registry for tools, resources, and placeable blocks.\r\n\r\n**Requirements**:\r\n- `ItemDefinition` class with properties:\r\n  - String name, description\r\n  - Texture/sprite coordinates\r\n  - ItemType enum (RESOURCE, TOOL, BLOCK, CONSUMABLE)\r\n  - BlockType reference (for placeable items)\r\n  - Tool properties (mining speed, durability)\r\n  - Max stack size\r\n- XML loading from `ItemDefinitions.xml`\r\n- Item ID range separate from block IDs\r\n- Support for block items (e.g., \"Stone Block\" item places STONE block)\r\n\r\n**Acceptance Criteria**:\r\n```xml\r\n<ItemDefinition name=\"Stone Block\"\r\n                type=\"BLOCK\"\r\n                blockType=\"STONE\"\r\n                maxStackSize=\"64\"\r\n                spriteCoords=\"1,0\"/>\r\n<ItemDefinition name=\"Wooden Pickaxe\"\r\n                type=\"TOOL\"\r\n                miningSpeed=\"2.0\"\r\n                durability=\"60\"\r\n                maxStackSize=\"1\"\r\n                spriteCoords=\"0,3\"/>\r\n```\r\n\r\n#### FR-1.4: Recipe Registry\r\n**Description**: Define crafting recipes for 2×2 crafting grid.\r\n\r\n**Requirements**:\r\n- `Recipe` class with input/output patterns\r\n- 2×2 grid support (4 input slots)\r\n- Shaped recipes (pattern matters)\r\n- Shapeless recipes (pattern doesn't matter)\r\n- Recipe validation (check if inventory matches)\r\n- XML or code-based recipe definitions\r\n\r\n**Example Recipes**:\r\n```cpp\r\n// Shaped: 4 logs → 1 crafting table\r\nRecipe craftingTableRecipe = {\r\n  {{LOG, LOG}, {LOG, LOG}},\r\n  {CRAFTING_TABLE, 1}\r\n};\r\n\r\n// Shapeless: 1 log → 4 planks\r\nRecipe planksRecipe = {\r\n  {{LOG, EMPTY}, {EMPTY, EMPTY}},\r\n  {PLANKS, 4},\r\n  shapeless = true\r\n};\r\n```\r\n\r\n---\r\n\r\n### FR-2: Inventory System\r\n\r\n#### FR-2.1: ItemStack Data Structure\r\n**Description**: Represent item quantity and type in a single slot.\r\n\r\n**Requirements**:\r\n- `ItemStack` struct:\r\n  - `uint16_t itemID` (ItemRegistry ID)\r\n  - `uint8_t quantity` (1-255)\r\n  - `uint16_t durability` (for tools, optional)\r\n- Empty stack representation (itemID = 0)\r\n- Stack merging logic (same item, below max stack size)\r\n- Stack splitting (take N from stack)\r\n\r\n**Acceptance Criteria**:\r\n```cpp\r\nItemStack stack(STONE_BLOCK_ITEM, 32);\r\nbool canMerge = stack.CanMergeWith(otherStack);\r\nItemStack split = stack.TakeQuantity(16); // Now has 16, split has 16\r\n```\r\n\r\n#### FR-2.2: Player Inventory\r\n**Description**: Player storage for collected items.\r\n\r\n**Requirements**:\r\n- 36 total slots:\r\n  - Slots 0-26: Main inventory (27 slots, 3 rows × 9 columns)\r\n  - Slots 27-35: Hotbar (9 slots, bottom row)\r\n- Current selected hotbar slot (0-8)\r\n- Add item (find empty/matching slot)\r\n- Remove item by slot\r\n- Transfer items between slots\r\n- Serialize/deserialize for save system\r\n\r\n**Acceptance Criteria**:\r\n- Picking up items fills inventory automatically\r\n- Hotbar slots 1-9 map to keyboard keys 1-9\r\n- Full inventory prevents further pickups\r\n- Inventory persists across save/load\r\n\r\n#### FR-2.3: Item Pickup System\r\n**Description**: World items can be collected into inventory.\r\n\r\n**Requirements**:\r\n- `ItemEntity` class (extends Entity):\r\n  - Position, velocity (affected by gravity)\r\n  - ItemStack contents\r\n  - Pickup cooldown (0.5 seconds after drop)\r\n  - Magnetic attraction to nearby player (3 block radius)\r\n- Collision detection with player\r\n- Inventory space check before pickup\r\n- Visual feedback (item entity disappears)\r\n- Item entity despawn timer (5 minutes)\r\n\r\n**Acceptance Criteria**:\r\n- Breaking a block spawns ItemEntity at block center\r\n- Player walks near ItemEntity, it flies toward player\r\n- On collision, item added to inventory, entity destroyed\r\n- If inventory full, item remains in world\r\n\r\n---\r\n\r\n### FR-3: Mining & Placement Mechanics\r\n\r\n#### FR-3.1: Progressive Block Breaking\r\n**Description**: Blocks take time to break, showing visual progress.\r\n\r\n**Requirements**:\r\n- Raycast from player camera to detect targeted block (6 block range)\r\n- Hold left mouse button to mine\r\n- Mining progress (0.0 to 1.0) based on:\r\n  - Block hardness (BlockDefinition property)\r\n  - Tool effectiveness (ToolDefinition property)\r\n  - Time held\r\n- Visual crack overlay (10 stages, 0-9)\r\n- Cancel mining if:\r\n  - Player releases mouse\r\n  - Player looks away from block\r\n  - Player moves too far (7 block range)\r\n- On completion:\r\n  - Block removed from world (set to AIR)\r\n  - ItemEntity spawned with block drop\r\n\r\n**Break Time Formula**:\r\n```cpp\r\nfloat breakTime = blockHardness / (toolEffectiveness * globalMultiplier);\r\n// Example: Stone (hardness 1.5) with wooden pickaxe (effectiveness 2.0)\r\n// breakTime = 1.5 / 2.0 = 0.75 seconds\r\n```\r\n\r\n**Acceptance Criteria**:\r\n- Holding left mouse on stone block shows progressive cracks\r\n- After ~0.75s (with pickaxe), block breaks and drops item\r\n- Without tool, takes 3x longer\r\n- Breaking GRASS drops DIRT_BLOCK item (block type transformation)\r\n\r\n#### FR-3.2: Block Placement\r\n**Description**: Place blocks from hotbar into world.\r\n\r\n**Requirements**:\r\n- Raycast to find placement position (adjacent to targeted block face)\r\n- Right mouse button to place\r\n- Consume 1 item from selected hotbar slot\r\n- Check placement validity:\r\n  - Target position not occupied by solid block\r\n  - Player not intersecting placed block position\r\n  - Within reach (6 block range)\r\n- Update chunk mesh after placement\r\n- Visual preview (ghost block) before placement (optional, nice-to-have)\r\n\r\n**Acceptance Criteria**:\r\n- With STONE_BLOCK in hotbar, right-click places stone block\r\n- Item quantity decreases by 1\r\n- Cannot place block inside player\r\n- Can place blocks on ground, walls, ceilings\r\n\r\n#### FR-3.3: Tool Effectiveness System\r\n**Description**: Different tools break blocks at different speeds.\r\n\r\n**Requirements**:\r\n- `ToolDefinition` properties:\r\n  - Tool tier (WOOD, STONE, IRON, DIAMOND)\r\n  - Effectiveness multiplier per block type\r\n  - Durability (uses before breaking)\r\n- Preferred tool for each block:\r\n  - STONE → Pickaxe (2x speed)\r\n  - DIRT/GRASS → Shovel (2x speed)\r\n  - WOOD → Axe (2x speed)\r\n- Wrong tool or no tool: 0.5x speed (penalty)\r\n- Tool durability decreases on block break\r\n\r\n**Example**:\r\n```cpp\r\n// Breaking stone with wooden pickaxe: 0.75s\r\n// Breaking stone with stone pickaxe: 0.5s\r\n// Breaking stone with hand (no tool): 2.25s\r\n```\r\n\r\n---\r\n\r\n### FR-4: User Interface (WidgetSubsystem Integration)\r\n\r\n#### FR-4.1: HUD (Heads-Up Display)\r\n**Description**: Always-visible UI elements during gameplay.\r\n\r\n**Requirements**:\r\n- **Hotbar Widget** (bottom-center):\r\n  - 9 slots displayed horizontally\r\n  - Selected slot highlighted (white border, 2px)\r\n  - Item icons rendered in each slot\r\n  - Item quantity displayed (bottom-right corner, if > 1)\r\n  - Transparent background (alpha 0.5)\r\n- **Crosshair Widget** (center):\r\n  - Simple white cross (2px lines, 16px total size)\r\n  - Always visible, no alpha fade\r\n- **Debug Text** (F3 toggle):\r\n  - Minecraft-style debug overlay (top-left)\r\n  - Position, chunk coords, FPS, biome, light level\r\n  - Black background with white/yellow text\r\n  - Rendered using existing debug text system\r\n\r\n**WidgetSubsystem Integration**:\r\n- Create custom `HotbarWidget` class (extends `IWidget`)\r\n- Use `WidgetSubsystem::AddWidget()` with zOrder=100 (above world)\r\n- Render with orthographic projection (screen-space coordinates)\r\n\r\n**Acceptance Criteria**:\r\n- Hotbar visible at all times during gameplay\r\n- Selecting different slots (1-9 keys) updates highlight\r\n- Item icons and quantities render correctly\r\n- F3 toggles debug overlay (Minecraft style)\r\n\r\n#### FR-4.2: Inventory Screen\r\n**Description**: Full inventory UI opened with 'E' key.\r\n\r\n**Requirements**:\r\n- **Main Inventory Grid** (center):\r\n  - 27 slots (3 rows × 9 columns)\r\n  - Slot size: 32×32 pixels (scaled for screen resolution)\r\n  - 2px padding between slots\r\n- **Hotbar Section** (bottom):\r\n  - 9 slots mirroring HUD hotbar\r\n  - Visual connection showing it's the same inventory\r\n- **Crafting Grid** (left side):\r\n  - 2×2 input grid (4 slots)\r\n  - 1 output slot (right of grid)\r\n  - Arrow icon between input and output\r\n- **Mouse Interaction**:\r\n  - Left-click slot: Pick up entire stack or place held stack\r\n  - Right-click slot: Pick up/place single item\r\n  - Shift-left-click: Quick transfer to/from hotbar\r\n- **Cursor Item** (held item):\r\n  - Render item icon following mouse cursor\r\n  - Stack quantity displayed\r\n- **Pause Gameplay**:\r\n  - World updates freeze\r\n  - Player cannot move\r\n  - Mouse cursor visible\r\n\r\n**WidgetSubsystem Integration**:\r\n- Create `InventoryWidget` class (extends `IWidget`)\r\n- Register with owner ID = player entity ID\r\n- Modal widget (blocks input to world)\r\n\r\n**Acceptance Criteria**:\r\n- 'E' key toggles inventory screen\r\n- Can drag-and-drop items between slots\r\n- Shift-click moves items quickly\r\n- Crafting grid functional (see FR-4.3)\r\n- Inventory screen pauses gameplay\r\n\r\n#### FR-4.3: Crafting Interface\r\n**Description**: 2×2 crafting grid with recipe matching.\r\n\r\n**Requirements**:\r\n- 2×2 input grid (part of inventory screen)\r\n- Output slot shows craftable item (if valid recipe)\r\n- Recipe matching:\r\n  - Check all registered recipes\r\n  - Match shaped recipes (pattern exact)\r\n  - Match shapeless recipes (any arrangement)\r\n- Clicking output slot:\r\n  - Consume input items (1 of each)\r\n  - Add output item to cursor\r\n  - If shift-clicked, add directly to inventory\r\n- Recipe preview (optional nice-to-have):\r\n  - Hover over output shows recipe in tooltip\r\n\r\n**Starter Recipes** (implement these 3):\r\n```\r\n1. LOG → 4 PLANKS (shapeless, any 1 log)\r\n2. 4 PLANKS (2×2 grid) → CRAFTING_TABLE\r\n3. 2 PLANKS (vertical stack) → 4 STICKS\r\n```\r\n\r\n**Acceptance Criteria**:\r\n- Placing log in any slot shows 4 planks as output\r\n- Placing 4 planks in 2×2 shows crafting table\r\n- Clicking output consumes inputs, gives output\r\n- Invalid arrangements show no output\r\n\r\n---\r\n\r\n### FR-5: AI Agent Framework\r\n\r\n#### FR-5.1: AIAgent Entity Class\r\n**Description**: Entity subclass for AI-controlled agents.\r\n\r\n**Requirements**:\r\n- Extend `Entity` base class\r\n- Properties:\r\n  - `std::string m_agentName` (unique identifier)\r\n  - `uint64_t m_agentID` (for KADI tracking)\r\n  - `std::queue<AgentCommand> m_commandQueue`\r\n  - `Inventory m_inventory` (36 slots, same as player)\r\n  - `float m_visionRange` (blocks agent can \"see\")\r\n- Command queue processing:\r\n  - Pop one command per frame\r\n  - Execute command logic\r\n  - Send completion status to KADI\r\n- Rendering:\r\n  - Distinct color/appearance from player\r\n  - Name tag above agent (using debug text)\r\n  - Optional: Velocity vectors (debug mode)\r\n\r\n**Acceptance Criteria**:\r\n```cpp\r\nAIAgent* agent = world->SpawnAgent(\"MinerBot\", Vec3(100, 100, 70));\r\nagent->QueueCommand(AgentCommand::MOVE, {direction: Vec3(1,0,0), duration: 2.0f});\r\nagent->QueueCommand(AgentCommand::MINE, {x: 101, y: 100, z: 70});\r\n// Agent executes commands sequentially\r\n```\r\n\r\n#### FR-5.2: Agent Command System\r\n**Description**: Define agent action primitives.\r\n\r\n**Requirements**:\r\n- `AgentCommand` enum:\r\n  - `MOVE` - Move in direction for duration\r\n  - `MINE` - Break block at coordinates\r\n  - `PLACE` - Place block from inventory\r\n  - `CRAFT` - Execute crafting recipe\r\n  - `WAIT` - Idle for duration\r\n- Command parameters (variant/union struct):\r\n  - Vec3 direction, float duration (MOVE)\r\n  - IntVec3 blockCoords (MINE, PLACE)\r\n  - uint16_t recipeID (CRAFT)\r\n  - float duration (WAIT)\r\n- Command execution state machine:\r\n  - QUEUED → IN_PROGRESS → COMPLETED/FAILED\r\n- Failure conditions:\r\n  - Out of reach\r\n  - Invalid target\r\n  - Inventory full (MINE)\r\n  - Missing items (PLACE, CRAFT)\r\n\r\n**Acceptance Criteria**:\r\n- Agent can execute all 5 command types\r\n- Commands report completion status\r\n- Failed commands don't crash, return error code\r\n\r\n#### FR-5.3: Agent Vision System\r\n**Description**: Agents can query nearby blocks and entities.\r\n\r\n**Requirements**:\r\n- `AgentVision::GetNearbyBlocks(radius)`:\r\n  - Returns vector of block types in sphere around agent\r\n  - Includes block coordinates\r\n  - Sorted by distance (nearest first)\r\n- `AgentVision::GetNearbyEntities(radius)`:\r\n  - Returns other agents, player, item entities\r\n  - Includes entity position, type\r\n- Vision caching (update every 0.5 seconds, not every frame)\r\n- Expose vision data to KADI broker\r\n\r\n**Acceptance Criteria**:\r\n```cpp\r\nstd::vector<BlockInfo> blocks = agent->GetNearbyBlocks(10.0f);\r\n// Returns all blocks within 10-block sphere\r\n// BlockInfo: {IntVec3 coords, uint8_t blockType, float distance}\r\n```\r\n\r\n#### FR-5.4: KADI Broker Integration (C++ Side)\r\n**Description**: Expose SimpleMiner game state and control to KADI broker.\r\n\r\n**Requirements**:\r\n- WebSocket server or stdio communication with kadi-broker\r\n- MCP tool registration (SimpleMiner exposes these tools to KADI):\r\n  - `simpleminer_spawn_agent(name, x, y, z)` → agentID\r\n  - `simpleminer_move_agent(agentID, dirX, dirY, dirZ, duration)`\r\n  - `simpleminer_mine_block(agentID, x, y, z)`\r\n  - `simpleminer_place_block(agentID, blockType, x, y, z)`\r\n  - `simpleminer_get_agent_vision(agentID)` → {blocks, entities}\r\n  - `simpleminer_get_agent_inventory(agentID)` → {itemStacks}\r\n  - `simpleminer_craft_item(agentID, recipeID)`\r\n- JSON serialization for all data types\r\n- Non-blocking communication (don't freeze game)\r\n\r\n**Protocol Example**:\r\n```json\r\n{\r\n  \"jsonrpc\": \"2.0\",\r\n  \"method\": \"tools/call\",\r\n  \"params\": {\r\n    \"name\": \"simpleminer_spawn_agent\",\r\n    \"arguments\": {\r\n      \"name\": \"MinerBot\",\r\n      \"x\": 100,\r\n      \"y\": 100,\r\n      \"z\": 70\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n**Acceptance Criteria**:\r\n- SimpleMiner registers 7 MCP tools with kadi-broker\r\n- Claude Desktop can discover tools via `/mcp` command\r\n- Calling tools from Claude executes in-game actions\r\n- Tool results return to Claude (success/failure, data)\r\n\r\n#### FR-5.5: TypeScript Agent Framework\r\n**Description**: Create example agent behaviors in Agent_TypeScript project.\r\n\r\n**Requirements**:\r\n- `MinerAgent.ts`:\r\n  - Spawn at specified coordinates\r\n  - Scan for nearest stone blocks (vision system)\r\n  - Navigate to stone block\r\n  - Mine block\r\n  - Collect dropped item\r\n  - Return to start position\r\n- `BuilderAgent.ts`:\r\n  - Given list of block coordinates and types\r\n  - Place blocks sequentially to build structure\r\n  - Handle inventory management (swap items in hotbar)\r\n- Agent utilities:\r\n  - Pathfinding helper (simple A* or greedy)\r\n  - Inventory query helper\r\n  - Vision query helper\r\n\r\n**Acceptance Criteria**:\r\n- From Claude Desktop: \"Spawn a miner agent and mine 10 stone blocks\"\r\n- MinerAgent.ts executes autonomously\r\n- Agent appears in SimpleMiner game\r\n- Agent mines blocks and collects items\r\n- Claude receives completion message\r\n\r\n---\r\n\r\n## Non-Functional Requirements\r\n\r\n### NFR-1: Performance\r\n- **Target FPS**: 60 FPS sustained with inventory UI open\r\n- **UI Rendering**: < 2ms per frame for all widgets\r\n- **Agent Update**: < 0.5ms per agent per frame\r\n- **Max Concurrent Agents**: Support 10 agents without frame drops\r\n\r\n### NFR-2: Memory\r\n- **Registry Overhead**: < 1MB for all registries combined\r\n- **Inventory Storage**: 36 slots × 64 bytes = 2.3KB per player/agent\r\n- **UI Texture Memory**: < 10MB for all UI sprites\r\n\r\n### NFR-3: Usability\r\n- **Input Responsiveness**: < 16ms (one frame) from input to action\r\n- **Visual Feedback**: All interactions show immediate feedback (highlight, sound ready, animations)\r\n- **Error Messages**: Clear error messages for KADI tool failures\r\n- **F3 Debug**: Comprehensive debug info for troubleshooting\r\n\r\n### NFR-4: Extensibility\r\n- **Registry Design**: Easy to add new blocks, items, recipes via XML\r\n- **Agent Commands**: New commands added with minimal code changes\r\n- **UI Widgets**: New widgets inherit from IWidget base\r\n- **KADI Tools**: New tools registered with simple function mapping\r\n\r\n### NFR-5: Code Quality\r\n- **SOLID Principles**: Registry pattern demonstrates Single Responsibility\r\n- **DRY**: No duplicate inventory logic between Player and AIAgent\r\n- **YAGNI**: Only implement 2×2 crafting, not 3×3 yet\r\n- **KISS**: Simple command queue for agents, not complex behavior trees\r\n\r\n---\r\n\r\n## Constraints and Assumptions\r\n\r\n### Technical Constraints\r\n1. **DirectX 11**: All UI must use existing WidgetSubsystem and DX11 rendering\r\n2. **Windows Only**: No cross-platform support required\r\n3. **Single-threaded Gameplay**: Game logic runs on main thread (rendering on main thread, chunk gen on workers)\r\n4. **V8 JavaScript**: Already integrated but not required for this assignment (KADI uses stdio/WebSocket instead)\r\n\r\n### Assumptions\r\n1. **KADI Broker Running**: Assumes `kadi-broker` is started separately (not embedded in SimpleMiner)\r\n2. **Claude Desktop Available**: Assumes user has Claude Desktop or Claude Code with KADI MCP server configured\r\n3. **Existing Assets**: Assumes UI sprite sheets exist or can be created (hotbar background, slot borders, icons)\r\n4. **Save System**: Inventory serialization piggybacks on existing chunk save system\r\n\r\n### Dependencies\r\n1. **Engine WidgetSubsystem**: Must use existing widget architecture (WidgetSubsystem.hpp/cpp)\r\n2. **KADI Broker**: Must connect to existing `C:\\p4\\Personal\\SD\\kadi\\kadi-broker` instance\r\n3. **Agent_TypeScript**: Must work with existing `C:\\p4\\Personal\\SD\\Agent_TypeScript` framework\r\n4. **BlockDefinition XML**: Must extend existing `BlockDefinitions.xml` structure\r\n\r\n---\r\n\r\n## Success Criteria\r\n\r\n### Minimum Viable Product (MVP)\r\n**These features MUST work for assignment credit**:\r\n\r\n1. ✅ Registry system (Block, Item, Recipe) functional\r\n2. ✅ Player inventory with 36 slots\r\n3. ✅ Mining mechanics (progressive break, item drop, pickup)\r\n4. ✅ Placement mechanics (consume inventory, place block)\r\n5. ✅ HUD with hotbar and item display\r\n6. ✅ Inventory screen with mouse interaction\r\n7. ✅ 2×2 crafting with 3 starter recipes\r\n8. ✅ AIAgent spawning and basic commands (MOVE, MINE, PLACE)\r\n9. ✅ KADI integration (at least 3 tools: spawn, move, mine)\r\n\r\n**Demo Scenario**:\r\n```\r\n1. Player mines 4 logs (break blocks, collect items)\r\n2. Opens inventory (E key)\r\n3. Crafts planks from logs (2×2 grid)\r\n4. Places planks to build structure (right-click)\r\n5. From Claude Desktop: \"Spawn miner agent and mine 5 stone\"\r\n6. Agent appears in game, executes command autonomously\r\n7. Claude Desktop receives completion confirmation\r\n```\r\n\r\n### Stretch Goals (Nice-to-Have)\r\n**These features are bonus, not required**:\r\n\r\n- ⭐ Shift-click quick transfer\r\n- ⭐ Tool durability display\r\n- ⭐ Item tooltips on hover\r\n- ⭐ Ghost block preview before placement\r\n- ⭐ Agent pathfinding (A* algorithm)\r\n- ⭐ Multiple agent coordination (builder + miner working together)\r\n- ⭐ Recipe preview in crafting grid\r\n- ⭐ Item entity stacking (multiple same items in one entity)\r\n\r\n---\r\n\r\n## Questions for User\r\n\r\nBefore proceeding to design phase, please clarify:\r\n\r\n1. **UI Sprites**: Do you have UI sprite sheets for hotbar, slots, icons, or should I plan to create placeholder textures?\r\n\r\n2. **KADI Communication**: Should SimpleMiner use stdio (like ProtogameJS3D) or WebSocket for KADI broker? What's your preference?\r\n\r\n3. **Tool Durability**: Should we implement tool durability in A7, or defer to future assignment?\r\n\r\n4. **Agent Count**: How many concurrent AI agents should we design for? 10? 50?\r\n\r\n5. **Crafting Recipes**: Beyond the 3 starter recipes (planks, sticks, crafting table), how many total recipes should we implement?\r\n\r\n6. **Save System**: Should inventory persist across game sessions (serialize to disk with player data)?\r\n\r\n7. **Item Drops**: Should items stack in world (e.g., 64 stone in one entity) or spawn individually?\r\n\r\n8. **Agent Intelligence**: Should agents have goal-based AI (high-level: \"build a house\") or just command execution (low-level: \"place block at X,Y,Z\")?\r\n\r\n---\r\n\r\n## References\r\n\r\n### Minecraft Systems (Inspiration)\r\n- [Minecraft Wiki: Inventory](https://minecraft.wiki/w/Inventory)\r\n- [Minecraft Wiki: Crafting](https://minecraft.wiki/w/Crafting)\r\n- [Minecraft Wiki: Mining](https://minecraft.wiki/w/Mining)\r\n- [Minecraft Wiki: Debug Screen (F3)](https://minecraft.wiki/w/Debug_screen)\r\n\r\n### SimpleMiner Codebase\r\n- **Engine**: `C:\\p4\\Personal\\SD\\Engine\\Code\\Engine\\Widget\\`\r\n- **SimpleMiner**: `C:\\p4\\Personal\\SD\\SimpleMiner\\Code\\Game\\`\r\n- **KADI**: `C:\\p4\\Personal\\SD\\kadi\\kadi-broker\\`\r\n- **Agent**: `C:\\p4\\Personal\\SD\\Agent_TypeScript\\`\r\n- **Prototype**: `C:\\p4\\Personal\\SD\\ProtogameJS3D\\`\r\n\r\n### Documentation\r\n- SimpleMiner CLAUDE.md files (Root, Framework, Gameplay, Definition modules)\r\n- Assignment 6 (Physics & Camera) - archived in `.spec-workflow/archive/specs/A6`\r\n- WidgetSubsystem.hpp - Engine UI rendering system\r\n- BlockDefinition system - existing registry pattern\r\n\r\n---\r\n\r\n## Revision History\r\n\r\n| Version | Date | Author | Changes |\r\n|---------|------|--------|---------|\r\n| 1.0 | 2025-11-24 | Claude Code | Initial requirements document |\r\n\r\n---\r\n\r\n**Next Steps**: After user review and question answers, proceed to create `design.md` with detailed architecture, class diagrams, and implementation strategy.\r\n",
  "fileStats": {
    "size": 26111,
    "lines": 726,
    "lastModified": "2025-11-24T10:07:34.652Z"
  },
  "comments": []
}