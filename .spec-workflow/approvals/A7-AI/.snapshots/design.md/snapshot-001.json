{
  "id": "snapshot_1764294284119_rmctc2fgk",
  "approvalId": "approval_1764294284091_7jvw191op",
  "approvalTitle": "A7-AI design.md - AI Agent Architecture",
  "version": 1,
  "timestamp": "2025-11-28T01:44:44.119Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Assignment 7-AI: Design Document\r\n# AI Agent Integration (KADI WebSocket, Agent Framework)\r\n\r\n**Version:** 1.0\r\n**Date:** 2025-11-27\r\n**Status:** Design Phase\r\n**Dependencies:** ✅ Requires A7-Core completion (Registry, Inventory systems)\r\n\r\n---\r\n\r\n## Executive Summary\r\n\r\nThis design document provides the technical architecture for A7-AI's implementation of AI agent framework and KADI WebSocket integration. The design covers:\r\n\r\n1. **AIAgent Entity Class** - Autonomous entity with inventory and command queue\r\n2. **Agent Command System** - MOVE, MINE, PLACE, CRAFT, WAIT commands\r\n3. **Agent Vision System** - Query nearby blocks and entities\r\n4. **KADI WebSocket Integration** - 7 MCP tools using KADIWebSocketSubsystem\r\n5. **TypeScript Agent Framework** - Example agent behaviors (MinerAgent, BuilderAgent)\r\n\r\n**Design Philosophy:**\r\n- **Command Execution Only** - No goal-based AI (defer to future assignment)\r\n- **Reuse Player Logic** - Share mining/placement code with Player class\r\n- **Non-Blocking Network** - KADI communication doesn't freeze game\r\n- **MCP Tool Naming** - PascalCase_With_Underscores (per user request)\r\n\r\n---\r\n\r\n## Table of Contents\r\n\r\n1. [System Architecture Overview](#1-system-architecture-overview)\r\n2. [AIAgent Class Design](#2-aiagent-class-design)\r\n3. [Agent Command System](#3-agent-command-system)\r\n4. [Agent Vision System](#4-agent-vision-system)\r\n5. [KADI WebSocket Integration](#5-kadi-websocket-integration)\r\n6. [TypeScript Agent Framework](#6-typescript-agent-framework)\r\n7. [Data Flow Diagrams](#7-data-flow-diagrams)\r\n8. [Implementation Strategy](#8-implementation-strategy)\r\n\r\n---\r\n\r\n## 1. System Architecture Overview\r\n\r\n### Component Architecture\r\n\r\n```\r\n┌─────────────────────────────────────────────┐\r\n│      TypeScript Agents (DigitalOcean)       │\r\n│   MinerAgent.ts, BuilderAgent.ts            │\r\n└─────────────────────────────────────────────┘\r\n                    ↓↑ WebSocket (JSON-RPC)\r\n┌─────────────────────────────────────────────┐\r\n│         KADI Broker (localhost)             │\r\n│   - Tool discovery                          │\r\n│   - Message routing                         │\r\n└─────────────────────────────────────────────┘\r\n                    ↓↑ WebSocket\r\n┌─────────────────────────────────────────────┐\r\n│    KADIWebSocketSubsystem (Engine)          │\r\n│   - 7 MCP tools registered                  │\r\n│   - JSON serialization                      │\r\n└─────────────────────────────────────────────┘\r\n                    ↓↑\r\n┌─────────────────────────────────────────────┐\r\n│         SimpleMiner Game Logic              │\r\n│   AIAgent, AgentCommand, AgentVision        │\r\n└─────────────────────────────────────────────┘\r\n```\r\n\r\n### Entity Hierarchy\r\n\r\n```\r\nEntity (base class)\r\n├── Player\r\n├── ItemEntity\r\n└── AIAgent (new)\r\n```\r\n\r\n### Data Flow: Spawning Agent via KADI\r\n\r\n```\r\nClaude Desktop: \"Spawn a miner agent at (100, 100, 70)\"\r\n     ↓\r\nTypeScript Agent (MinerAgent.ts):\r\n  SimpleMiner_Spawn_Agent(\"MinerBot\", 100, 100, 70)\r\n     ↓\r\nKADI Broker: Route to SimpleMiner\r\n     ↓\r\nKADIWebSocketSubsystem: Receive JSON-RPC request\r\n     ↓\r\nSimpleMiner::OnKADIToolCall(\"SimpleMiner_Spawn_Agent\", {...})\r\n     ↓\r\nWorld::SpawnAgent(\"MinerBot\", Vec3(100, 100, 70))\r\n     ↓\r\nAIAgent* agent = new AIAgent(\"MinerBot\", agentID, position)\r\n     ↓\r\nReturn agentID to KADI\r\n     ↓\r\nTypeScript Agent receives agentID: 1234567890\r\n```\r\n\r\n---\r\n\r\n## 2. AIAgent Class Design\r\n\r\n### Class Structure\r\n\r\n**File:** `SimpleMiner\\Code\\Game\\Gameplay\\AIAgent.hpp`\r\n\r\n```cpp\r\nclass AIAgent : public Entity\r\n{\r\npublic:\r\n    AIAgent(std::string const& name, uint64_t agentID, Vec3 const& position);\r\n    ~AIAgent();\r\n\r\n    // Entity Overrides\r\n    virtual void Update(float deltaSeconds) override;\r\n    virtual void Render() const override;\r\n    virtual void OnCollision(Entity* other) override;\r\n\r\n    // Agent Properties\r\n    std::string GetName() const { return m_agentName; }\r\n    uint64_t GetAgentID() const { return m_agentID; }\r\n\r\n    // Command Queue\r\n    void QueueCommand(AgentCommand* command);\r\n    AgentCommand* GetCurrentCommand() const { return m_currentCommand; }\r\n    bool IsIdle() const { return m_commandQueue.empty() && !m_currentCommand; }\r\n\r\n    // Inventory (reuse from A7-Core)\r\n    Inventory& GetInventory() { return m_inventory; }\r\n    ItemStack& GetSelectedItemStack();\r\n\r\n    // Vision\r\n    std::vector<BlockInfo> GetNearbyBlocks(float radius);\r\n    std::vector<EntityInfo> GetNearbyEntities(float radius);\r\n\r\nprivate:\r\n    std::string m_agentName;          // \"MinerBot\"\r\n    uint64_t m_agentID;               // For KADI tracking\r\n    Inventory m_inventory;            // 36 slots (same as player)\r\n    int m_selectedHotbarSlot = 0;     // 0-8\r\n\r\n    // Command Queue\r\n    std::queue<AgentCommand*> m_commandQueue;\r\n    AgentCommand* m_currentCommand = nullptr;\r\n\r\n    // Vision Cache (updated every 0.5s)\r\n    float m_visionUpdateTimer = 0.0f;\r\n    float m_visionUpdateInterval = 0.5f;\r\n    std::vector<BlockInfo> m_cachedBlocks;\r\n    std::vector<EntityInfo> m_cachedEntities;\r\n\r\n    // Rendering\r\n    Rgba8 m_color = Rgba8::BLUE;      // Distinct from player (green)\r\n\r\n    void UpdateCommandQueue(float deltaSeconds);\r\n    void UpdateVisionCache(float deltaSeconds);\r\n};\r\n```\r\n\r\n### Agent Update Loop\r\n\r\n```cpp\r\nvoid AIAgent::Update(float deltaSeconds)\r\n{\r\n    // 1. Update physics (inherited from Entity)\r\n    Entity::Update(deltaSeconds);\r\n\r\n    // 2. Update command queue\r\n    UpdateCommandQueue(deltaSeconds);\r\n\r\n    // 3. Update vision cache (every 0.5s)\r\n    UpdateVisionCache(deltaSeconds);\r\n}\r\n\r\nvoid AIAgent::UpdateCommandQueue(float deltaSeconds)\r\n{\r\n    // If no current command, pop from queue\r\n    if (!m_currentCommand && !m_commandQueue.empty())\r\n    {\r\n        m_currentCommand = m_commandQueue.front();\r\n        m_commandQueue.pop();\r\n        m_currentCommand->OnStart(this);\r\n    }\r\n\r\n    // Execute current command\r\n    if (m_currentCommand)\r\n    {\r\n        m_currentCommand->Execute(this, deltaSeconds);\r\n\r\n        // Check if complete or failed\r\n        if (m_currentCommand->IsComplete() || m_currentCommand->IsFailed())\r\n        {\r\n            // Send completion notification to KADI\r\n            SendCommandCompletionToKADI(m_currentCommand);\r\n\r\n            // Delete command\r\n            delete m_currentCommand;\r\n            m_currentCommand = nullptr;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### Agent Rendering\r\n\r\n```cpp\r\nvoid AIAgent::Render() const\r\n{\r\n    // Render agent cube (blue color)\r\n    Vec3 cubeSize(0.8f, 0.8f, 1.8f);  // Slightly smaller than player\r\n    g_renderer->DrawCube(m_position, cubeSize, m_color);\r\n\r\n    // Render name tag above agent\r\n    Vec3 nameTagPos = m_position + Vec3(0.0f, 0.0f, 2.0f);\r\n    g_renderer->DrawText3D(nameTagPos, m_agentName, 0.2f, Rgba8::WHITE);\r\n\r\n    // DEBUG: Render command queue status\r\n    if (g_debugMode)\r\n    {\r\n        std::string commandText = \"Idle\";\r\n        if (m_currentCommand)\r\n        {\r\n            commandText = m_currentCommand->GetTypeName();\r\n        }\r\n        Vec3 commandTextPos = m_position + Vec3(0.0f, 0.0f, 2.5f);\r\n        g_renderer->DrawText3D(commandTextPos, commandText, 0.15f, Rgba8::YELLOW);\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 3. Agent Command System\r\n\r\n### AgentCommand Base Class\r\n\r\n**File:** `SimpleMiner\\Code\\Game\\Gameplay\\AgentCommand.hpp`\r\n\r\n```cpp\r\nenum class eAgentCommandType\r\n{\r\n    MOVE,\r\n    MINE,\r\n    PLACE,\r\n    CRAFT,\r\n    WAIT\r\n};\r\n\r\nclass AgentCommand\r\n{\r\npublic:\r\n    virtual ~AgentCommand() = default;\r\n\r\n    // Lifecycle\r\n    virtual void OnStart(AIAgent* agent) {}\r\n    virtual void Execute(AIAgent* agent, float deltaSeconds) = 0;\r\n    virtual bool IsComplete() const = 0;\r\n    virtual bool IsFailed() const { return false; }\r\n\r\n    // Info\r\n    virtual eAgentCommandType GetType() const = 0;\r\n    virtual std::string GetTypeName() const = 0;\r\n    virtual std::string GetErrorMessage() const { return \"\"; }\r\n\r\nprotected:\r\n    bool m_isComplete = false;\r\n    bool m_isFailed = false;\r\n    std::string m_errorMessage;\r\n};\r\n```\r\n\r\n### MOVE Command\r\n\r\n```cpp\r\nclass AgentCommand_Move : public AgentCommand\r\n{\r\npublic:\r\n    AgentCommand_Move(Vec3 const& direction, float duration)\r\n        : m_direction(direction.GetNormalized())\r\n        , m_duration(duration)\r\n    {}\r\n\r\n    void Execute(AIAgent* agent, float deltaSeconds) override\r\n    {\r\n        m_elapsed += deltaSeconds;\r\n\r\n        // Apply movement velocity\r\n        float moveSpeed = 4.0f;  // Blocks/second (same as player)\r\n        agent->SetVelocity(m_direction * moveSpeed);\r\n\r\n        // Check completion\r\n        if (m_elapsed >= m_duration)\r\n        {\r\n            agent->SetVelocity(Vec3::ZERO);  // Stop movement\r\n            m_isComplete = true;\r\n        }\r\n    }\r\n\r\n    bool IsComplete() const override { return m_isComplete; }\r\n    eAgentCommandType GetType() const override { return eAgentCommandType::MOVE; }\r\n    std::string GetTypeName() const override { return \"MOVE\"; }\r\n\r\nprivate:\r\n    Vec3 m_direction;\r\n    float m_duration;\r\n    float m_elapsed = 0.0f;\r\n};\r\n```\r\n\r\n### MINE Command\r\n\r\n```cpp\r\nclass AgentCommand_Mine : public AgentCommand\r\n{\r\npublic:\r\n    AgentCommand_Mine(IntVec3 const& blockCoords)\r\n        : m_blockCoords(blockCoords)\r\n    {}\r\n\r\n    void OnStart(AIAgent* agent) override\r\n    {\r\n        // Check if block in reach\r\n        Vec3 agentPos = agent->GetPosition();\r\n        Vec3 blockPos = Vec3((float)m_blockCoords.x, (float)m_blockCoords.y, (float)m_blockCoords.z);\r\n        float distance = (blockPos - agentPos).GetLength();\r\n\r\n        if (distance > 6.0f)\r\n        {\r\n            m_isFailed = true;\r\n            m_errorMessage = \"Block out of reach (>6 blocks)\";\r\n            return;\r\n        }\r\n\r\n        // Check if block is solid (not AIR)\r\n        Block* block = agent->GetWorld()->GetBlock(m_blockCoords);\r\n        if (!block || block->m_typeIndex == BLOCK_AIR)\r\n        {\r\n            m_isFailed = true;\r\n            m_errorMessage = \"Block is already AIR\";\r\n            return;\r\n        }\r\n\r\n        // Calculate break time (reuse player logic)\r\n        BlockDefinition* blockDef = BlockRegistry::GetInstance().Get(block->m_typeIndex);\r\n        ItemStack& tool = agent->GetSelectedItemStack();\r\n        m_breakTime = CalculateBreakTime(blockDef->m_hardness, tool);\r\n    }\r\n\r\n    void Execute(AIAgent* agent, float deltaSeconds) override\r\n    {\r\n        if (m_isFailed) return;\r\n\r\n        // Increment mining progress\r\n        m_miningProgress += deltaSeconds / m_breakTime;\r\n\r\n        if (m_miningProgress >= 1.0f)\r\n        {\r\n            // Break block\r\n            agent->GetWorld()->SetBlock(m_blockCoords, BLOCK_AIR);\r\n\r\n            // Spawn ItemEntity with block drop\r\n            Vec3 spawnPos = Vec3((float)m_blockCoords.x + 0.5f,\r\n                                 (float)m_blockCoords.y + 0.5f,\r\n                                 (float)m_blockCoords.z + 0.5f);\r\n            ItemStack droppedItem = GetBlockDropItem(m_blockCoords);\r\n            agent->GetWorld()->SpawnItemEntity(spawnPos, droppedItem);\r\n\r\n            // Decrease tool durability\r\n            ItemStack& tool = agent->GetSelectedItemStack();\r\n            if (!tool.IsEmpty() && tool.durability > 0)\r\n            {\r\n                tool.durability--;\r\n                if (tool.durability == 0)\r\n                    tool.Clear();\r\n            }\r\n\r\n            // Rebuild chunk mesh\r\n            Chunk* chunk = agent->GetWorld()->GetChunkAtWorldCoords(m_blockCoords);\r\n            chunk->SetDirty();\r\n\r\n            m_isComplete = true;\r\n        }\r\n    }\r\n\r\n    bool IsComplete() const override { return m_isComplete; }\r\n    eAgentCommandType GetType() const override { return eAgentCommandType::MINE; }\r\n    std::string GetTypeName() const override { return \"MINE\"; }\r\n\r\nprivate:\r\n    IntVec3 m_blockCoords;\r\n    float m_miningProgress = 0.0f;\r\n    float m_breakTime = 0.0f;\r\n};\r\n```\r\n\r\n### PLACE Command\r\n\r\n```cpp\r\nclass AgentCommand_Place : public AgentCommand\r\n{\r\npublic:\r\n    AgentCommand_Place(IntVec3 const& blockCoords, uint16_t blockType)\r\n        : m_blockCoords(blockCoords)\r\n        , m_blockType(blockType)\r\n    {}\r\n\r\n    void OnStart(AIAgent* agent) override\r\n    {\r\n        // Check if position in reach\r\n        Vec3 agentPos = agent->GetPosition();\r\n        Vec3 blockPos = Vec3((float)m_blockCoords.x, (float)m_blockCoords.y, (float)m_blockCoords.z);\r\n        float distance = (blockPos - agentPos).GetLength();\r\n\r\n        if (distance > 6.0f)\r\n        {\r\n            m_isFailed = true;\r\n            m_errorMessage = \"Position out of reach (>6 blocks)\";\r\n            return;\r\n        }\r\n\r\n        // Check if position not occupied\r\n        Block* existingBlock = agent->GetWorld()->GetBlock(m_blockCoords);\r\n        if (existingBlock && existingBlock->IsSolid())\r\n        {\r\n            m_isFailed = true;\r\n            m_errorMessage = \"Position occupied by solid block\";\r\n            return;\r\n        }\r\n\r\n        // Check if agent not intersecting placed block\r\n        AABB3 blockAABB = AABB3::MakeFromMinMaxInts(m_blockCoords, m_blockCoords + IntVec3(1,1,1));\r\n        if (blockAABB.IsPointInside(agentPos))\r\n        {\r\n            m_isFailed = true;\r\n            m_errorMessage = \"Cannot place block inside agent\";\r\n            return;\r\n        }\r\n\r\n        // Check if agent has block item in inventory\r\n        ItemStack& selectedItem = agent->GetSelectedItemStack();\r\n        if (selectedItem.IsEmpty())\r\n        {\r\n            m_isFailed = true;\r\n            m_errorMessage = \"No item in selected hotbar slot\";\r\n            return;\r\n        }\r\n\r\n        ItemDefinition* itemDef = ItemRegistry::GetInstance().Get(selectedItem.itemID);\r\n        if (itemDef->m_type != eItemType::BLOCK || itemDef->m_blockTypeID != m_blockType)\r\n        {\r\n            m_isFailed = true;\r\n            m_errorMessage = \"Selected item is not the correct block type\";\r\n            return;\r\n        }\r\n    }\r\n\r\n    void Execute(AIAgent* agent, float deltaSeconds) override\r\n    {\r\n        if (m_isFailed) return;\r\n\r\n        // Place block\r\n        agent->GetWorld()->SetBlock(m_blockCoords, m_blockType);\r\n\r\n        // Consume item\r\n        ItemStack& selectedItem = agent->GetSelectedItemStack();\r\n        selectedItem.Take(1);\r\n\r\n        // Rebuild chunk mesh\r\n        Chunk* chunk = agent->GetWorld()->GetChunkAtWorldCoords(m_blockCoords);\r\n        chunk->SetDirty();\r\n\r\n        m_isComplete = true;\r\n    }\r\n\r\n    bool IsComplete() const override { return m_isComplete; }\r\n    eAgentCommandType GetType() const override { return eAgentCommandType::PLACE; }\r\n    std::string GetTypeName() const override { return \"PLACE\"; }\r\n\r\nprivate:\r\n    IntVec3 m_blockCoords;\r\n    uint16_t m_blockType;\r\n};\r\n```\r\n\r\n### CRAFT and WAIT Commands\r\n\r\n```cpp\r\nclass AgentCommand_Craft : public AgentCommand\r\n{\r\n    // Similar to PLACE, check ingredients, execute recipe, add to inventory\r\n};\r\n\r\nclass AgentCommand_Wait : public AgentCommand\r\n{\r\npublic:\r\n    AgentCommand_Wait(float duration) : m_duration(duration) {}\r\n\r\n    void Execute(AIAgent* agent, float deltaSeconds) override\r\n    {\r\n        m_elapsed += deltaSeconds;\r\n        if (m_elapsed >= m_duration)\r\n            m_isComplete = true;\r\n    }\r\n\r\n    bool IsComplete() const override { return m_isComplete; }\r\n    eAgentCommandType GetType() const override { return eAgentCommandType::WAIT; }\r\n    std::string GetTypeName() const override { return \"WAIT\"; }\r\n\r\nprivate:\r\n    float m_duration;\r\n    float m_elapsed = 0.0f;\r\n};\r\n```\r\n\r\n---\r\n\r\n## 4. Agent Vision System\r\n\r\n### BlockInfo and EntityInfo Structures\r\n\r\n```cpp\r\nstruct BlockInfo\r\n{\r\n    IntVec3 coords;        // World block coordinates\r\n    uint8_t blockType;     // Block type index\r\n    float distance;        // Distance from agent\r\n\r\n    // JSON serialization\r\n    Json::Value ToJSON() const\r\n    {\r\n        Json::Value json;\r\n        json[\"coords\"] = Json::arrayValue;\r\n        json[\"coords\"].append(coords.x);\r\n        json[\"coords\"].append(coords.y);\r\n        json[\"coords\"].append(coords.z);\r\n\r\n        BlockDefinition* blockDef = BlockRegistry::GetInstance().Get(blockType);\r\n        json[\"blockType\"] = blockDef ? blockDef->m_name : \"unknown\";\r\n        json[\"distance\"] = distance;\r\n\r\n        return json;\r\n    }\r\n};\r\n\r\nstruct EntityInfo\r\n{\r\n    uint64_t entityID;     // Entity unique ID\r\n    eEntityType type;      // PLAYER, AI_AGENT, ITEM_ENTITY\r\n    Vec3 position;         // World position\r\n    float distance;        // Distance from agent\r\n\r\n    // JSON serialization\r\n    Json::Value ToJSON() const\r\n    {\r\n        Json::Value json;\r\n        json[\"id\"] = (Json::UInt64)entityID;\r\n        json[\"type\"] = EntityTypeToString(type);\r\n        json[\"position\"] = Json::arrayValue;\r\n        json[\"position\"].append(position.x);\r\n        json[\"position\"].append(position.y);\r\n        json[\"position\"].append(position.z);\r\n        json[\"distance\"] = distance;\r\n\r\n        return json;\r\n    }\r\n};\r\n```\r\n\r\n### Vision Query Implementation\r\n\r\n```cpp\r\nstd::vector<BlockInfo> AIAgent::GetNearbyBlocks(float radius)\r\n{\r\n    std::vector<BlockInfo> results;\r\n\r\n    // Query blocks in sphere around agent\r\n    IntVec3 agentBlockCoords = IntVec3((int)m_position.x, (int)m_position.y, (int)m_position.z);\r\n    int radiusInt = (int)std::ceil(radius);\r\n\r\n    for (int dx = -radiusInt; dx <= radiusInt; dx++)\r\n    {\r\n        for (int dy = -radiusInt; dy <= radiusInt; dy++)\r\n        {\r\n            for (int dz = -radiusInt; dz <= radiusInt; dz++)\r\n            {\r\n                IntVec3 blockCoords = agentBlockCoords + IntVec3(dx, dy, dz);\r\n                Vec3 blockPos = Vec3((float)blockCoords.x, (float)blockCoords.y, (float)blockCoords.z);\r\n                float distance = (blockPos - m_position).GetLength();\r\n\r\n                if (distance <= radius)\r\n                {\r\n                    Block* block = m_world->GetBlock(blockCoords);\r\n                    if (block && block->m_typeIndex != BLOCK_AIR)\r\n                    {\r\n                        BlockInfo info;\r\n                        info.coords = blockCoords;\r\n                        info.blockType = block->m_typeIndex;\r\n                        info.distance = distance;\r\n                        results.push_back(info);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Sort by distance (nearest first)\r\n    std::sort(results.begin(), results.end(), [](BlockInfo const& a, BlockInfo const& b) {\r\n        return a.distance < b.distance;\r\n    });\r\n\r\n    return results;\r\n}\r\n\r\nstd::vector<EntityInfo> AIAgent::GetNearbyEntities(float radius)\r\n{\r\n    std::vector<EntityInfo> results;\r\n\r\n    // Query all entities in world\r\n    for (Entity* entity : m_world->GetEntities())\r\n    {\r\n        if (entity == this) continue;  // Skip self\r\n\r\n        float distance = (entity->GetPosition() - m_position).GetLength();\r\n        if (distance <= radius)\r\n        {\r\n            EntityInfo info;\r\n            info.entityID = entity->GetID();\r\n            info.type = entity->GetEntityType();\r\n            info.position = entity->GetPosition();\r\n            info.distance = distance;\r\n            results.push_back(info);\r\n        }\r\n    }\r\n\r\n    // Sort by distance\r\n    std::sort(results.begin(), results.end(), [](EntityInfo const& a, EntityInfo const& b) {\r\n        return a.distance < b.distance;\r\n    });\r\n\r\n    return results;\r\n}\r\n```\r\n\r\n---\r\n\r\n## 5. KADI WebSocket Integration\r\n\r\n### KADIWebSocketSubsystem Setup\r\n\r\n**File:** `SimpleMiner\\Code\\Game\\Framework\\App.cpp`\r\n\r\n```cpp\r\nvoid App::Startup()\r\n{\r\n    // ... existing startup code ...\r\n\r\n    // Initialize KADI WebSocket\r\n    g_kadiWebSocket = new KADIWebSocketSubsystem(\"localhost\", 9876);\r\n    g_kadiWebSocket->Startup();\r\n\r\n    // Register 7 MCP tools\r\n    RegisterKADITools();\r\n}\r\n\r\nvoid App::RegisterKADITools()\r\n{\r\n    // 1. SimpleMiner_Spawn_Agent\r\n    g_kadiWebSocket->RegisterTool(\"SimpleMiner_Spawn_Agent\",\r\n        \"Spawn a new AI agent at specified coordinates\",\r\n        {{\"name\", \"string\"}, {\"x\", \"float\"}, {\"y\", \"float\"}, {\"z\", \"float\"}},\r\n        [](Json::Value const& params) -> Json::Value {\r\n            std::string name = params[\"name\"].asString();\r\n            Vec3 position(params[\"x\"].asFloat(), params[\"y\"].asFloat(), params[\"z\"].asFloat());\r\n\r\n            AIAgent* agent = g_theWorld->SpawnAgent(name, position);\r\n\r\n            Json::Value result;\r\n            result[\"agentID\"] = (Json::UInt64)agent->GetAgentID();\r\n            return result;\r\n        }\r\n    );\r\n\r\n    // 2. SimpleMiner_Move_Agent\r\n    g_kadiWebSocket->RegisterTool(\"SimpleMiner_Move_Agent\",\r\n        \"Queue a MOVE command for agent\",\r\n        {{\"agentID\", \"uint64\"}, {\"dirX\", \"float\"}, {\"dirY\", \"float\"}, {\"dirZ\", \"float\"}, {\"duration\", \"float\"}},\r\n        [](Json::Value const& params) -> Json::Value {\r\n            uint64_t agentID = params[\"agentID\"].asUInt64();\r\n            Vec3 direction(params[\"dirX\"].asFloat(), params[\"dirY\"].asFloat(), params[\"dirZ\"].asFloat());\r\n            float duration = params[\"duration\"].asFloat();\r\n\r\n            AIAgent* agent = g_theWorld->GetAgentByID(agentID);\r\n            if (!agent) return CreateError(\"Agent not found\");\r\n\r\n            agent->QueueCommand(new AgentCommand_Move(direction, duration));\r\n\r\n            Json::Value result;\r\n            result[\"success\"] = true;\r\n            return result;\r\n        }\r\n    );\r\n\r\n    // 3. SimpleMiner_Mine_Block\r\n    g_kadiWebSocket->RegisterTool(\"SimpleMiner_Mine_Block\",\r\n        \"Queue a MINE command for agent\",\r\n        {{\"agentID\", \"uint64\"}, {\"x\", \"int\"}, {\"y\", \"int\"}, {\"z\", \"int\"}},\r\n        [](Json::Value const& params) -> Json::Value {\r\n            uint64_t agentID = params[\"agentID\"].asUInt64();\r\n            IntVec3 blockCoords(params[\"x\"].asInt(), params[\"y\"].asInt(), params[\"z\"].asInt());\r\n\r\n            AIAgent* agent = g_theWorld->GetAgentByID(agentID);\r\n            if (!agent) return CreateError(\"Agent not found\");\r\n\r\n            agent->QueueCommand(new AgentCommand_Mine(blockCoords));\r\n\r\n            Json::Value result;\r\n            result[\"success\"] = true;\r\n            return result;\r\n        }\r\n    );\r\n\r\n    // 4-7: Similar implementations for PLACE, GET_VISION, GET_INVENTORY, CRAFT\r\n}\r\n```\r\n\r\n### SimpleMiner_Get_Agent_Vision Implementation\r\n\r\n```cpp\r\ng_kadiWebSocket->RegisterTool(\"SimpleMiner_Get_Agent_Vision\",\r\n    \"Get agent's nearby blocks and entities\",\r\n    {{\"agentID\", \"uint64\"}},\r\n    [](Json::Value const& params) -> Json::Value {\r\n        uint64_t agentID = params[\"agentID\"].asUInt64();\r\n        AIAgent* agent = g_theWorld->GetAgentByID(agentID);\r\n        if (!agent) return CreateError(\"Agent not found\");\r\n\r\n        // Get vision data\r\n        std::vector<BlockInfo> blocks = agent->GetNearbyBlocks(10.0f);\r\n        std::vector<EntityInfo> entities = agent->GetNearbyEntities(10.0f);\r\n\r\n        // Serialize to JSON\r\n        Json::Value result;\r\n        result[\"blocks\"] = Json::arrayValue;\r\n        for (BlockInfo const& block : blocks)\r\n        {\r\n            result[\"blocks\"].append(block.ToJSON());\r\n        }\r\n\r\n        result[\"entities\"] = Json::arrayValue;\r\n        for (EntityInfo const& entity : entities)\r\n        {\r\n            result[\"entities\"].append(entity.ToJSON());\r\n        }\r\n\r\n        return result;\r\n    }\r\n);\r\n```\r\n\r\n---\r\n\r\n## 6. TypeScript Agent Framework\r\n\r\n### MinerAgent.ts Example\r\n\r\n```typescript\r\n// File: Agent_TypeScript/src/agents/MinerAgent.ts\r\n\r\nimport { SimpleMinerAPI } from '../api/SimpleMinerAPI';\r\n\r\nexport class MinerAgent {\r\n    private api: SimpleMinerAPI;\r\n    private agentID: number;\r\n\r\n    constructor(api: SimpleMinerAPI) {\r\n        this.api = api;\r\n    }\r\n\r\n    async spawn(name: string, x: number, y: number, z: number): Promise<void> {\r\n        const result = await this.api.spawnAgent(name, x, y, z);\r\n        this.agentID = result.agentID;\r\n        console.log(`Agent spawned with ID: ${this.agentID}`);\r\n    }\r\n\r\n    async mineStoneBlocks(count: number): Promise<void> {\r\n        for (let i = 0; i < count; i++) {\r\n            // Get vision\r\n            const vision = await this.api.getAgentVision(this.agentID);\r\n\r\n            // Find nearest stone block\r\n            const stoneBlock = vision.blocks.find(b => b.blockType === \"stone\");\r\n            if (!stoneBlock) {\r\n                console.log(\"No stone blocks in range\");\r\n                return;\r\n            }\r\n\r\n            // Move toward stone\r\n            const direction = this.calculateDirection(stoneBlock.coords);\r\n            await this.api.moveAgent(this.agentID, direction.x, direction.y, direction.z, 2.0);\r\n\r\n            // Wait for movement to complete\r\n            await this.sleep(2000);\r\n\r\n            // Mine stone\r\n            await this.api.mineBlock(this.agentID, stoneBlock.coords.x, stoneBlock.coords.y, stoneBlock.coords.z);\r\n\r\n            // Wait for mining to complete (assume 1 second with pickaxe)\r\n            await this.sleep(1000);\r\n\r\n            console.log(`Mined stone block ${i + 1}/${count}`);\r\n        }\r\n\r\n        console.log(`Finished mining ${count} stone blocks`);\r\n    }\r\n\r\n    private calculateDirection(targetCoords: { x: number, y: number, z: number }): { x: number, y: number, z: number } {\r\n        // Simplified: just return normalized direction (no pathfinding)\r\n        const inventory = await this.api.getAgentInventory(this.agentID);\r\n        const agentPos = inventory.position;  // Assume API returns agent position\r\n\r\n        const dx = targetCoords.x - agentPos.x;\r\n        const dy = targetCoords.y - agentPos.y;\r\n        const dz = 0;  // Don't move vertically for now\r\n\r\n        const length = Math.sqrt(dx * dx + dy * dy);\r\n        return { x: dx / length, y: dy / length, z: dz };\r\n    }\r\n\r\n    private sleep(ms: number): Promise<void> {\r\n        return new Promise(resolve => setTimeout(resolve, ms));\r\n    }\r\n}\r\n```\r\n\r\n### SimpleMinerAPI.ts (WebSocket Client)\r\n\r\n```typescript\r\n// File: Agent_TypeScript/src/api/SimpleMinerAPI.ts\r\n\r\nexport class SimpleMinerAPI {\r\n    private ws: WebSocket;\r\n    private requestID = 0;\r\n\r\n    constructor(brokerURL: string) {\r\n        this.ws = new WebSocket(brokerURL);\r\n    }\r\n\r\n    async spawnAgent(name: string, x: number, y: number, z: number): Promise<{ agentID: number }> {\r\n        return this.callTool(\"SimpleMiner_Spawn_Agent\", { name, x, y, z });\r\n    }\r\n\r\n    async moveAgent(agentID: number, dirX: number, dirY: number, dirZ: number, duration: number): Promise<{ success: boolean }> {\r\n        return this.callTool(\"SimpleMiner_Move_Agent\", { agentID, dirX, dirY, dirZ, duration });\r\n    }\r\n\r\n    async mineBlock(agentID: number, x: number, y: number, z: number): Promise<{ success: boolean }> {\r\n        return this.callTool(\"SimpleMiner_Mine_Block\", { agentID, x, y, z });\r\n    }\r\n\r\n    async getAgentVision(agentID: number): Promise<{ blocks: any[], entities: any[] }> {\r\n        return this.callTool(\"SimpleMiner_Get_Agent_Vision\", { agentID });\r\n    }\r\n\r\n    async getAgentInventory(agentID: number): Promise<{ slots: any[] }> {\r\n        return this.callTool(\"SimpleMiner_Get_Agent_Inventory\", { agentID });\r\n    }\r\n\r\n    private async callTool(toolName: string, params: any): Promise<any> {\r\n        return new Promise((resolve, reject) => {\r\n            const id = this.requestID++;\r\n            const request = {\r\n                jsonrpc: \"2.0\",\r\n                method: \"tools/call\",\r\n                params: { name: toolName, arguments: params },\r\n                id\r\n            };\r\n\r\n            this.ws.send(JSON.stringify(request));\r\n\r\n            // Listen for response\r\n            const listener = (event: MessageEvent) => {\r\n                const response = JSON.parse(event.data);\r\n                if (response.id === id) {\r\n                    this.ws.removeEventListener(\"message\", listener);\r\n                    if (response.error) {\r\n                        reject(new Error(response.error.message));\r\n                    } else {\r\n                        resolve(response.result);\r\n                    }\r\n                }\r\n            };\r\n\r\n            this.ws.addEventListener(\"message\", listener);\r\n        });\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 7. Data Flow Diagrams\r\n\r\n### Agent Command Execution Flow\r\n\r\n```\r\nKADI Tool Call (SimpleMiner_Mine_Block)\r\n     ↓\r\nAgentCommand_Mine created\r\n     ↓\r\nAIAgent::QueueCommand() → Add to queue\r\n     ↓\r\nAIAgent::Update() → Pop from queue\r\n     ↓\r\nAgentCommand::OnStart() → Validate (range, block exists)\r\n     ↓ (each frame)\r\nAgentCommand::Execute() → Increment mining progress\r\n     ↓\r\nMining progress >= 1.0\r\n     ↓\r\nBreakBlock() → World::SetBlock(AIR)\r\n     ↓\r\nSpawnItemEntity(block drop)\r\n     ↓\r\nChunk::SetDirty() → Rebuild mesh\r\n     ↓\r\nAgentCommand::IsComplete() → true\r\n     ↓\r\nSendCommandCompletionToKADI()\r\n     ↓\r\nTypeScript Agent receives completion\r\n```\r\n\r\n---\r\n\r\n## 8. Implementation Strategy\r\n\r\n### Phase 1: AIAgent Entity Class (4-6 hours)\r\n1. Create `AIAgent` class (extends Entity)\r\n2. Add inventory, command queue, vision cache\r\n3. Implement `Update()` loop (command queue processing)\r\n4. Implement `Render()` (blue cube, name tag)\r\n5. Test agent spawning in World\r\n\r\n### Phase 2: Agent Command System (8-10 hours)\r\n1. Create `AgentCommand` base class\r\n2. Implement `AgentCommand_Move`\r\n3. Implement `AgentCommand_Mine` (reuse player mining logic)\r\n4. Implement `AgentCommand_Place` (reuse player placement logic)\r\n5. Implement `AgentCommand_Wait`\r\n6. Implement `AgentCommand_Craft` (optional, may defer)\r\n7. Test all 5 commands\r\n\r\n### Phase 3: Agent Vision System (4-6 hours)\r\n1. Implement `GetNearbyBlocks()` (3D sphere query)\r\n2. Implement `GetNearbyEntities()` (entity list query)\r\n3. Implement vision caching (update every 0.5s)\r\n4. Implement JSON serialization for BlockInfo/EntityInfo\r\n5. Test vision queries\r\n\r\n### Phase 4: KADI WebSocket Integration (6-8 hours)\r\n1. Initialize KADIWebSocketSubsystem in App::Startup()\r\n2. Register 7 MCP tools\r\n3. Implement tool handlers (spawn, move, mine, place, vision, inventory, craft)\r\n4. Test tool calls from Claude Desktop\r\n5. Test error handling (invalid agentID, out of reach, etc.)\r\n\r\n### Phase 5: TypeScript Agent Framework (4-6 hours)\r\n1. Create `SimpleMinerAPI.ts` (WebSocket client)\r\n2. Create `MinerAgent.ts` (example agent behavior)\r\n3. Deploy to DigitalOcean\r\n4. Test MinerAgent from Claude Desktop\r\n5. Create `BuilderAgent.ts` (optional, stretch goal)\r\n\r\n### Total Estimated Time: 26-36 hours (1 week)\r\n\r\n---\r\n\r\n**Next Steps:**\r\n1. Approve this design.md via spec-workflow\r\n2. Create tasks.md breaking down implementation into specific tasks\r\n3. Begin Phase 1 (AIAgent Entity Class)\r\n4. Proceed sequentially through phases\r\n",
  "fileStats": {
    "size": 31424,
    "lines": 986,
    "lastModified": "2025-11-28T01:43:21.964Z"
  },
  "comments": []
}