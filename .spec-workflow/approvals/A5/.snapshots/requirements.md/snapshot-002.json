{
  "id": "snapshot_1763186038662_lbe74tvcj",
  "approvalId": "approval_1763185056893_kdzc23xot",
  "approvalTitle": "Assignment 5 Requirements - Updated with Tree Variation and Mesh Fixes",
  "version": 2,
  "timestamp": "2025-11-15T05:53:58.662Z",
  "trigger": "revision_requested",
  "status": "pending",
  "content": "# Requirements Document - Assignment 5: Rendering and Lighting\r\n\r\n## Introduction\r\n\r\nAssignment 5 (SDST-A05) introduces volumetric voxel lighting, advanced rendering optimizations, and interactive block manipulation to SimpleMiner, a Minecraft-inspired procedurally-generated 3D voxel world. This assignment transforms the visual experience from a basic textured terrain into a dynamically-lit, immersive environment with day/night cycles, atmospheric effects, and light-emitting blocks.\r\n\r\n### Purpose\r\nEnable realistic volumetric lighting that propagates through the voxel world, providing visual feedback for underground exploration, surface/cave contrast, and player-placed light sources.\r\n\r\n### Value to Users\r\n- **Visual Clarity**: Light influences help players navigate underground caves and understand spatial relationships\r\n- **Atmosphere**: Day/night cycles and weather effects create a more immersive gameplay experience\r\n- **Player Agency**: Glowstone placement allows players to customize their environment and solve lighting challenges\r\n- **Performance**: Optimized rendering ensures smooth 60 FPS gameplay even during chunk activation\r\n\r\n## Alignment with Product Vision\r\n\r\nSimpleMiner aims to be a technically sophisticated voxel game engine demonstrating professional game architecture patterns. Assignment 5 advances this vision by:\r\n\r\n- **Technical Excellence**: Implementing industry-standard influence map algorithms (Minecraft-style lighting)\r\n- **Performance First**: Maintaining 60 FPS through multi-threaded processing and optimized data structures\r\n- **Player-Centric Design**: Precise raycasting and visual feedback improve block interaction UX\r\n- **Educational Value**: Demonstrating advanced graphics programming (shaders, fog, mipmapping)\r\n\r\n## Requirements\r\n\r\n### Requirement 1: Block Data Structure Expansion\r\n\r\n**User Story:** As a game engine, I need to store lighting data per-block so that each voxel can display correct light values without excessive memory overhead.\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN the Block class is defined THEN it SHALL contain exactly 3 bytes total\r\n   - 1 byte: `m_typeIndex` (block type 0-255)\r\n   - 1 byte: `m_lightingData` with outdoor light (high nibble 0-15) and indoor light (low nibble 0-15)\r\n   - 1 byte: `m_bitFlags` for up to 8 boolean properties\r\n\r\n2. WHEN accessing light values THEN Block SHALL provide inline getter/setter methods:\r\n   - `uint8_t GetOutdoorLight() const` - extract high nibble (bits 4-7)\r\n   - `uint8_t GetIndoorLight() const` - extract low nibble (bits 0-3)\r\n   - `void SetOutdoorLight(uint8_t value)` - set high nibble, preserve low\r\n   - `void SetIndoorLight(uint8_t value)` - set low nibble, preserve high\r\n\r\n3. IF `sizeof(Block)` is queried THEN it SHALL return exactly 3 bytes\r\n\r\n4. WHEN bit flags are accessed THEN Block SHALL provide methods for each flag:\r\n   - `bool IsSky() const` / `void SetIsSky(bool)`\r\n   - `bool IsLightDirty() const` / `void SetIsLightDirty(bool)`\r\n   - `bool IsFullOpaque() const` / `void SetIsFullOpaque(bool)`\r\n   - `bool IsSolid() const` / `void SetIsSolid(bool)`\r\n   - `bool IsVisible() const` / `void SetIsVisible(bool)`\r\n\r\n### Requirement 2: Dual Light Influence Maps\r\n\r\n**User Story:** As a player exploring caves, I want to see both outdoor skylight and indoor glowstone light so that I can distinguish between surface-adjacent areas and deep underground.\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN a block stores lighting THEN it SHALL maintain two independent 0-15 values:\r\n   - **Outdoor Light Influence**: Represents skylight penetration (blue-tinted by default)\r\n   - **Indoor Light Influence**: Represents artificial light from blocks (warm-tinted by default)\r\n\r\n2. WHEN light propagates THEN each influence type SHALL spread independently\r\n   - Outdoor light SHALL decrease by 1 per block distance from sky\r\n   - Indoor light SHALL decrease by 1 per block distance from emitting block\r\n   - Opaque blocks SHALL refuse to accept either light type (remain at 0)\r\n\r\n3. WHEN multiple lights influence a block THEN it SHALL take the highest value\r\n   - Example: If outdoor=12 from sky AND indoor=8 from glowstone, outdoor remains 12 (not 20)\r\n   - Light values are NOT additive, only the strongest source applies\r\n\r\n4. IF a block emits light THEN it SHALL set its indoor light to its emission value\r\n   - Glowstone: indoor light emission = 15\r\n   - Lava: indoor light emission = 10 (example, configurable)\r\n   - Most blocks: indoor light emission = 0\r\n\r\n### Requirement 3: Light Propagation Algorithm\r\n\r\n**User Story:** As a game engine, I need to efficiently calculate correct light values for all blocks so that lighting updates complete within one frame without blocking gameplay.\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN a chunk activates THEN lighting SHALL be initialized as follows:\r\n   - All blocks default to 0 outdoor and 0 indoor light\r\n   - Non-opaque boundary blocks touching existing neighbors SHALL be marked dirty\r\n   - Descend each (x,y) column from top, setting IsSky() flag until first opaque block\r\n   - Descend each column again, setting outdoor=15 for IsSky blocks\r\n   - Mark non-sky horizontal neighbors of sky blocks as dirty\r\n   - Mark all light-emitting blocks as dirty\r\n\r\n2. WHEN processing dirty lighting THEN the system SHALL:\r\n   - Pop the front block iterator from the dirty queue\r\n   - Clear its IS_LIGHT_DIRTY flag\r\n   - Compute correct outdoor and indoor light values:\r\n     - IF IsSky() THEN outdoor = 15\r\n     - IF block emits light THEN indoor >= emission value\r\n     - IF non-opaque THEN light >= max(all 6 neighbors) - 1\r\n   - IF computed value differs from current value THEN:\r\n     - Update the block's light values\r\n     - Mark the chunk's mesh as dirty\r\n     - Mark all 6 non-opaque neighbors as dirty (if not already dirty)\r\n\r\n3. WHEN all dirty blocks are processed THEN the queue SHALL be empty\r\n   - Light SHALL propagate to 15 blocks from source (15→14→13...→1→0)\r\n   - Propagation SHALL stop when a block calculates its correct value\r\n   - No block SHALL appear in dirty queue more than once simultaneously\r\n\r\n4. IF lighting is fully resolved THEN performance SHALL meet target:\r\n   - Process all dirty lighting every frame (no amortization required for now)\r\n   - Target: <16ms total frame time including lighting updates\r\n\r\n### Requirement 4: Cross-Chunk Light Propagation\r\n\r\n**User Story:** As a player placing glowstone near chunk boundaries, I want light to spread naturally across chunks so that lighting appears seamless.\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN a block iterator moves across chunk boundaries THEN it SHALL:\r\n   - Detect when x, y, or z reaches chunk limits (0 or MAX)\r\n   - Select the appropriate neighbor chunk (north/south/east/west/up/down)\r\n   - Return a valid block iterator in the neighbor chunk at the correct local coordinates\r\n   - Return null/invalid if no neighbor chunk exists\r\n\r\n2. WHEN light propagates to chunk edges THEN it SHALL:\r\n   - Mark corresponding edge blocks in neighbor chunks as dirty\r\n   - Use the same dirty queue for all chunks (global, not per-chunk)\r\n   - Ensure light values are correct across all chunk boundaries\r\n\r\n3. IF chunk A is deactivated WHILE chunk B references its blocks THEN:\r\n   - System SHALL remove all chunk A blocks from the global dirty queue\r\n   - Use `UndirtyAllBlocksInChunk()` to prevent dangling references\r\n\r\n### Requirement 5: Hidden Surface Removal at Chunk Boundaries\r\n\r\n**User Story:** As a player, I want smooth performance and correct visuals so that chunk boundaries are invisible and hidden faces don't waste GPU resources.\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN building a chunk mesh THEN faces SHALL only be added IF:\r\n   - The neighboring block in that direction is non-opaque OR\r\n   - The neighbor is in an inactive chunk (boundary case)\r\n\r\n2. WHEN a chunk's mesh is being rebuilt THEN it SHALL:\r\n   - Only rebuild IF all 4 horizontal neighbor chunks are active\r\n   - Wait for neighbor activation before attempting mesh construction\r\n   - Allow chunks to be active without meshes (mesh pending state)\r\n\r\n3. WHEN mesh rebuilding is scheduled THEN performance constraints SHALL apply:\r\n   - Build closest 2 chunks to camera per frame maximum\r\n   - Use dirty chunk priority queue (nearest first)\r\n\r\n4. IF a chunk deactivates THEN its mesh buffers SHALL be released\r\n   - Prevent DirectX 11 memory leaks\r\n   - Null-check vertex/index buffers before rendering\r\n\r\n### Requirement 6: Texture Mipmapping\r\n\r\n**User Story:** As a player viewing distant terrain, I want textures to look crisp without aliasing artifacts so that far-away blocks remain visually pleasing.\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN textures are loaded THEN the Renderer SHALL:\r\n   - Generate 5 mip levels for 32-pixel sprite sheets\r\n   - Generate 6 mip levels for 64-pixel sprite sheets\r\n   - Use auto-gen mipmapping (D3D11_RESOURCE_MISC_GENERATE_MIPS flag)\r\n\r\n2. WHEN rendering chunks THEN the sampler SHALL:\r\n   - Use trilinear filtering for mipmap interpolation\r\n   - Select appropriate mip level based on screen-space derivative\r\n\r\n3. IF mipmapping is disabled THEN performance MAY degrade\r\n   - Note: This requirement is optional per assignment specification\r\n\r\n### Requirement 7: Vertex Color Lighting\r\n\r\n**User Story:** As a game engine, I need to encode light values in vertex colors so that the pixel shader can calculate per-pixel lighting without additional lookups.\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN adding a block face to the mesh THEN each vertex SHALL:\r\n   - Set `color.r` = neighboring block's outdoor light / 15.0 (normalized 0-1)\r\n   - Set `color.g` = neighboring block's indoor light / 15.0 (normalized 0-1)\r\n   - Set `color.b` = directional greyscale shading (existing, based on face normal)\r\n   - Use the light value from the block the face is pointing toward\r\n\r\n2. WHEN a block's light value changes THEN affected chunks SHALL:\r\n   - Mark their mesh as dirty\r\n   - Rebuild mesh with updated vertex colors\r\n\r\n3. IF a block has outdoor=15 and indoor=0 THEN its south-facing neighbor's north face SHALL:\r\n   - Have vertex `color.r = 1.0` (full outdoor light)\r\n   - Have vertex `color.g = 0.0` (no indoor light)\r\n\r\n### Requirement 8: World Shader with Lighting and Fog\r\n\r\n**User Story:** As a player, I want lighting and fog to create atmosphere so that caves feel dark, outdoors feels bright, and distant terrain fades into fog.\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN the world shader is compiled THEN it SHALL define a constant buffer (register b4):\r\n   ```hlsl\r\n   cbuffer WorldConstants : register(b4) {\r\n       float4 CameraPosition;\r\n       float4 IndoorLightColor;    // Default (255, 230, 204) warm\r\n       float4 OutdoorLightColor;   // Default (255, 255, 255) white\r\n       float4 SkyColor;            // Default (0, 0, 0), updated at runtime\r\n       float FogNearDistance;       // Default activation_range - (2 * chunk_size)\r\n       float FogFarDistance;        // Default FogNearDistance / 2\r\n       float2 Padding;\r\n   };\r\n   ```\r\n\r\n2. WHEN the vertex shader executes THEN it SHALL:\r\n   - Pass world position to pixel shader\r\n   - Pass vertex color (r=outdoor, g=indoor, b=directional) unchanged\r\n\r\n3. WHEN the pixel shader executes THEN it SHALL:\r\n   - Calculate `diffuseLightColor = DiminishingAdd(outdoor * OutdoorLightColor, indoor * IndoorLightColor)`\r\n     - Where `DiminishingAdd(a, b) = 1 - (1-a)(1-b)` (assuming a,b in [0,1])\r\n   - Multiply sampled texel color by diffuseLightColor and vertex.color.b\r\n   - Calculate `fogFraction = smoothstep(FogNearDistance, FogFarDistance, distance(pixelWorldPos, CameraPosition))`\r\n   - Blend final color toward SkyColor based on `fogFraction * fogMaxAlpha`\r\n\r\n4. IF camera is far from chunk THEN fog SHALL:\r\n   - Reach 100% opacity at activation range boundary\r\n   - Use sky color for fog tint (matches clear color)\r\n\r\n### Requirement 9: Day and Night Cycle\r\n\r\n**User Story:** As a player, I want dynamic time-of-day so that the world feels alive and lighting conditions change naturally.\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN world time advances THEN it SHALL:\r\n   - Use Clock class to store world time in days (float)\r\n   - Calculate time of day as fractional part [0,1):\r\n     - 0.0 = midnight\r\n     - 0.25 = dawn (6am)\r\n     - 0.5 = noon\r\n     - 0.75 = dusk (6pm)\r\n   - Base time ratio: 500:1 (world time : real time)\r\n   - WHEN Y key held THEN accelerate time by 50x (total 25000:1 ratio)\r\n\r\n2. WHEN time of day changes THEN sky and fog color SHALL:\r\n   - Hold steady at dark blue (20, 20, 40) during night (6pm-6am)\r\n   - Lerp toward light blue (200, 230, 255) at high noon\r\n   - Use smooth interpolation curve (not linear)\r\n\r\n3. WHEN time of day changes THEN outdoor light color SHALL:\r\n   - Vary from dark blue-grey at midnight to full white during day\r\n   - Blend smoothly to avoid sudden brightness changes\r\n\r\n4. IF day/night cycle updates THEN NO block light values SHALL change\r\n   - Only constant buffer values update (no mesh rebuilds required)\r\n   - Performance: <0.1ms per frame for time calculations\r\n\r\n### Requirement 10: Lightning Strikes\r\n\r\n**User Story:** As a player, I want occasional lightning flashes so that the world feels dynamic and weather effects add excitement.\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN calculating lightning each frame THEN the system SHALL:\r\n   - Sample 1D Perlin noise at current world time\r\n   - Use 9 octaves and scale of 200\r\n   - Range-map noise from [0.6, 0.9] to lightningStrength [0, 1]\r\n\r\n2. WHEN lightningStrength > 0 THEN:\r\n   - Lerp sky color toward white (255, 255, 255) by lightningStrength\r\n   - Lerp outdoor light color toward white by lightningStrength\r\n   - Update constant buffer, no mesh changes\r\n\r\n3. IF lightningStrength = 1.0 THEN:\r\n   - Sky SHALL be pure white (flash peak)\r\n   - Outdoor-lit faces SHALL appear fully illuminated\r\n\r\n### Requirement 11: Glowstone Flickering\r\n\r\n**User Story:** As a player, I want glowstone to flicker subtly so that artificial lighting feels organic and torch-like.\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN calculating glowstone flicker each frame THEN the system SHALL:\r\n   - Sample 1D Perlin noise at current world time\r\n   - Use 9 octaves and scale of 500\r\n   - Range-map noise from [-1, 1] to glowStrength [0.8, 1.0]\r\n\r\n2. WHEN glowStrength is calculated THEN:\r\n   - Multiply base indoor light color (255, 230, 204) by glowStrength\r\n   - Update constant buffer only, no mesh rebuilds\r\n\r\n3. IF glowStrength = 0.8 THEN indoor light SHALL:\r\n   - Be 80% of base brightness (subtle darkening)\r\n   - Remain warm-tinted (color hue preserved)\r\n\r\n### Requirement 12: Fast Voxel Raycast\r\n\r\n**User Story:** As a player, I want precise block selection so that I can dig and place blocks exactly where I intend.\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN performing raycast THEN the system SHALL:\r\n   - Start at camera world position\r\n   - Extend camera-forward for 8.0 meters\r\n   - Use Fast Voxel Raycast algorithm (modified to use BlockIterator instead of coordinates)\r\n   - Return GameRaycastResult3D with:\r\n     - Block hit (if any)\r\n     - Face normal (which face was struck)\r\n     - Impact position (world coordinates)\r\n\r\n2. WHEN raycast hits a block THEN the system SHALL:\r\n   - Highlight the hit face visually (debug draw, not mesh modification)\r\n   - Draw highlight separately from chunk meshes\r\n\r\n3. WHEN R key is pressed THEN raycast SHALL:\r\n   - Toggle locked/unlocked mode\r\n   - IF locked THEN preserve raycast origin and direction regardless of camera movement\r\n   - IF unlocked THEN update raycast each frame with camera\r\n\r\n4. IF raycast is locked THEN visual feedback SHALL:\r\n   - Draw 3D debug line showing ray path\r\n   - Indicate hit (green) or miss (red)\r\n   - Show impact point if hit\r\n\r\n### Requirement 13: Improved Block Digging\r\n\r\n**User Story:** As a player, I want to dig blocks precisely so that I can mine resources and shape terrain effectively.\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN left mouse button is pressed AND raycast hits a block THEN system SHALL:\r\n   - Convert hit block to AIR\r\n   - Mark the block's light as dirty\r\n   - NOT immediately update light values (let propagation algorithm handle it)\r\n\r\n2. IF the block above the dug block has IsSky() flag THEN:\r\n   - Descend downward from dug block position\r\n   - Set IsSky() flag on all non-opaque blocks until first opaque\r\n   - Mark each newly-flagged sky block as dirty\r\n   - Example: Breaking cave roof allows sunlight beam to stream down\r\n\r\n3. WHEN digging completes THEN chunk SHALL:\r\n   - Mark mesh as dirty\r\n   - Rebuild mesh on next frame (or within 2-frame budget)\r\n\r\n4. IF block cannot be dug (out of range, no hit) THEN:\r\n   - No changes occur\r\n   - No error messages displayed\r\n\r\n### Requirement 14: Improved Block Placement\r\n\r\n**User Story:** As a player, I want to place blocks precisely so that I can build structures and light dark areas.\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN right mouse button is pressed AND raycast hits a block THEN system SHALL:\r\n   - Place selected block type on the struck face (adjacent to hit block)\r\n   - Mark the new block's light as dirty\r\n   - NOT immediately update light values (let propagation algorithm handle it)\r\n\r\n2. IF the placed block is opaque AND replaced block had IsSky() flag THEN:\r\n   - Clear IsSky() flag on placed block\r\n   - Descend downward, clearing IsSky() flags until first opaque\r\n   - Mark all affected blocks as dirty\r\n   - Example: Plugging vertical shaft cuts off sunlight\r\n\r\n3. WHEN placing block THEN selected type SHALL be:\r\n   - Displayed in UI (top center of screen)\r\n   - Changeable with number keys:\r\n     - 1 = Glowstone (emits light 15)\r\n     - 2 = Cobblestone (opaque, no emission)\r\n     - 3 = Chiseled Brick (opaque, no emission)\r\n\r\n4. IF placement location is occupied by opaque block THEN:\r\n   - No placement occurs\r\n   - No error feedback required\r\n\r\n### Requirement 15: Glowstone and Cobblestone Blocks\r\n\r\n**User Story:** As a game engine, I need to define light-emitting and opaque blocks so that players can manipulate lighting dynamically.\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN BlockDefinition is queried for Glowstone THEN it SHALL return:\r\n   - `m_isOpaque = true` (blocks light propagation)\r\n   - `m_isSolid = true` (player collision enabled)\r\n   - `m_indoorLightEmission = 15` (maximum light output)\r\n   - Sprite coordinates for glowstone texture\r\n\r\n2. WHEN BlockDefinition is queried for Cobblestone THEN it SHALL return:\r\n   - `m_isOpaque = true`\r\n   - `m_isSolid = true`\r\n   - `m_indoorLightEmission = 0` (no light output)\r\n   - Sprite coordinates for cobblestone texture\r\n\r\n3. IF player places glowstone THEN:\r\n   - Light SHALL propagate 15 blocks from source (15→14→...→1→0)\r\n   - Nearby chunks SHALL be marked mesh-dirty if lighting changes\r\n\r\n4. IF player places cobblestone THEN:\r\n   - Block SHALL stop light propagation (acts as light blocker)\r\n   - Opposite side of cobblestone SHALL be darker than front side\r\n\r\n### Requirement 16: BlockIterator Cross-Chunk Boundaries\r\n\r\n**User Story:** As a game engine, I need block iterators to work across chunk boundaries so that light propagation and raycasting don't break at edges.\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN BlockIterator moves north AND y == CHUNK_MAX_Y THEN it SHALL:\r\n   - Return `BlockIterator(northNeighborChunk, blockIndex & ~CHUNK_MASK_Y)`\r\n   - Preserve x and z coordinates, reset y to 0 in new chunk\r\n\r\n2. WHEN BlockIterator moves in any direction THEN it SHALL:\r\n   - Detect boundary crossing (coordinate == 0 or MAX)\r\n   - Select appropriate neighbor chunk pointer\r\n   - Calculate new local block index using bitwise operations\r\n   - Return valid iterator or null if no neighbor exists\r\n\r\n3. WHEN BlockIterator is used in raycast THEN:\r\n   - Algorithm SHALL traverse multiple chunks seamlessly\r\n   - No special-case logic needed for chunk boundaries in raycast loop\r\n\r\n4. IF neighbor chunk is inactive THEN:\r\n   - Return null/invalid iterator\r\n   - Caller SHALL handle null gracefully\r\n\r\n### Requirement 17: Tree Height and Radius Variation\r\n\r\n**User Story:** As a player exploring forests, I want trees to have natural size variation so that the environment feels more organic and less repetitive.\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN generating trees for a biome THEN the system SHALL:\r\n   - Use Perlin noise based on world position (x, y) to generate height variation\r\n   - Apply biome-specific height ranges:\r\n     - Oak: 4-7 blocks trunk height, 2-4 blocks canopy radius\r\n     - Spruce: 6-10 blocks trunk height, 1-3 blocks canopy radius\r\n     - Jungle: 8-14 blocks trunk height, 3-5 blocks canopy radius\r\n     - Acacia: 4-6 blocks trunk height, 2-4 blocks canopy radius\r\n     - Birch: 5-8 blocks trunk height, 2-3 blocks canopy radius\r\n   - Use separate noise channels for height and radius variation\r\n\r\n2. WHEN placing a tree at position (x, y) THEN it SHALL:\r\n   - Sample height noise at (x, y) with scale 50, octaves 2\r\n   - Sample radius noise at (x, y) with scale 30, octaves 2\r\n   - Range-map noise values to biome-specific min/max ranges\r\n   - Round to nearest integer for discrete block placement\r\n\r\n3. WHEN building tree canopy THEN the system SHALL:\r\n   - Use generated radius value for leaf sphere/cone dimensions\r\n   - Maintain tree shape (Oak=sphere, Spruce=cone, Jungle=irregular)\r\n   - Ensure leaves don't extend beyond reasonable bounds (max 8 blocks from trunk)\r\n\r\n4. IF tree generation creates invalid structures THEN:\r\n   - Height SHALL be clamped to prevent trees exceeding chunk height (max z=250)\r\n   - Radius SHALL be clamped to prevent excessive cross-chunk tree data (max 8 blocks)\r\n   - Trees SHALL NOT generate if insufficient vertical space available\r\n\r\n### Requirement 18: Fix Mesh Flashing and Jittering\r\n\r\n**User Story:** As a player digging blocks and exploring, I want smooth visual rendering so that blocks don't flash or jitter when I interact with them or when chunks activate.\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN digging or placing a block THEN the system SHALL:\r\n   - Mark affected chunk meshes as dirty BEFORE updating block data\r\n   - Defer mesh rebuild to the next frame (not immediate)\r\n   - Ensure old mesh remains visible until new mesh is ready\r\n   - Use double-buffered vertex/index buffers to prevent read-during-write conflicts\r\n\r\n2. WHEN a chunk mesh is being rebuilt THEN it SHALL:\r\n   - Lock the mesh buffer during construction\r\n   - Upload complete mesh in a single operation (not incrementally)\r\n   - Atomically swap old and new buffers to prevent partial rendering\r\n   - Release old buffer AFTER new buffer is bound for rendering\r\n\r\n3. WHEN chunks are activating near player THEN the system SHALL:\r\n   - Wait for all 4 horizontal neighbor chunks to be ACTIVE before building mesh\r\n   - Render chunks without meshes as invisible (not empty/flashing)\r\n   - Build meshes in priority order (nearest to camera first)\r\n   - Limit mesh builds to 2 chunks per frame to prevent frame time spikes\r\n\r\n4. IF flashing persists after mesh rebuild fixes THEN investigate:\r\n   - Camera frustum culling correctness (ensure chunks aren't flickering in/out of view)\r\n   - Depth buffer precision issues (z-fighting on coincident faces)\r\n   - Shader constant buffer updates (ensure transforms are synchronized)\r\n   - DirectX 11 device context state changes (ensure proper render state)\r\n\r\n5. WHEN debugging mesh issues THEN provide visual feedback:\r\n   - F4 key: Toggle \"mesh pending\" debug visualization (wireframe bounding box)\r\n   - Console logging: Mesh rebuild events with chunk coordinates and frame time\r\n   - Performance metric: Track mesh rebuild count and total time per frame\r\n\r\n## Non-Functional Requirements\r\n\r\n### Code Architecture and Modularity\r\n\r\n**Single Responsibility Principle:**\r\n- Block class: Store type, lighting, and flags only (3 bytes, no logic)\r\n- Chunk class: Manage block array, lighting initialization, mesh building\r\n- World class: Own global dirty queue, coordinate chunks, process lighting\r\n- BlockIterator class: Provide cross-chunk navigation, neighbor queries\r\n\r\n**Modular Design:**\r\n- Lighting system isolated in World::ProcessDirtyLighting() and helper methods\r\n- Shader constants managed by Renderer, updated by Game\r\n- Raycast algorithm encapsulated in World::RaycastVsBlocks()\r\n\r\n**Dependency Management:**\r\n- Block depends on BlockDefinition (flyweight pattern)\r\n- Chunk depends on World (for neighbor access, dirty queue)\r\n- World depends on JobSystem (for async operations)\r\n- Minimize circular dependencies through forward declarations\r\n\r\n**Clear Interfaces:**\r\n- Block: Public inline getters/setters for light and flags\r\n- Chunk: Public methods for mesh rebuild, lighting init\r\n- World: Public methods for marking dirty, processing lighting, raycast\r\n- BlockIterator: Consistent API for moving in 6 directions\r\n\r\n### Performance\r\n\r\n**Frame Rate:**\r\n- Maintain 60 FPS in Release build during normal gameplay\r\n- Maintain 60 FPS during chunk activation/deactivation within range\r\n- Target: 16.67ms total frame time (including all subsystems)\r\n\r\n**Lighting Performance:**\r\n- Process all dirty lighting within 8ms per frame (budgeted)\r\n- Dirty queue processing: O(n) where n = dirty blocks (typically <1000)\r\n- Chunk activation lighting init: O(blocks_per_chunk) = O(262,144) ~5ms\r\n\r\n**Mesh Rebuild Performance:**\r\n- Build maximum 2 chunks per frame (budget: 10ms total)\r\n- Prioritize nearest chunks to camera\r\n- Defer distant chunk meshes without blocking activation\r\n\r\n**Memory Constraints:**\r\n- Block size: 3 bytes (previously 1 byte, 3x increase acceptable)\r\n- Dirty queue: ~1000 BlockIterators typical, 8 bytes each = 8 KB\r\n- Avoid allocating memory during lighting propagation (use reserved queue)\r\n\r\n### Reliability\r\n\r\n**Thread Safety:**\r\n- All DirectX 11 operations SHALL execute on main thread only\r\n- Lighting propagation SHALL execute on main thread only (atomics too slow)\r\n- Chunk generation/loading SHALL remain on worker threads (no change from A4)\r\n\r\n**Error Handling:**\r\n- Null-check neighbor chunk pointers before dereferencing\r\n- Validate block indices within chunk bounds (assertions in debug)\r\n- Handle raycast misses gracefully (no crash if no hit)\r\n\r\n**Data Integrity:**\r\n- Dirty queue SHALL never contain duplicate BlockIterators\r\n- Chunk deactivation SHALL remove all its blocks from dirty queue\r\n- Light values SHALL remain in [0, 15] range (clamped if needed)\r\n\r\n### Usability\r\n\r\n**Visual Clarity:**\r\n- Highlight selected block face clearly (bright overlay or outline)\r\n- Display current selected block type in UI (top center)\r\n- Show FPS counter (top right) for performance monitoring\r\n\r\n**Controls:**\r\n- LMB: Dig block (intuitive, standard in genre)\r\n- RMB: Place block (intuitive, standard in genre)\r\n- 1/2/3 keys: Select block type (quick access to glowstone/cobblestone/brick)\r\n- R key: Toggle raycast lock (useful for debugging)\r\n- Y key: Accelerate time (useful for testing day/night)\r\n\r\n**Feedback:**\r\n- Block highlight: Immediate visual response (<16ms)\r\n- Light changes: Visible within 1 frame after dirty processing\r\n- Fog transitions: Smooth (no popping or abrupt changes)\r\n\r\n**Debugging:**\r\n- F2: Toggle chunk debug draw (bounding boxes, coords, counts)\r\n- F3: Toggle job system debug draw (job counts, states)\r\n- Step-by-step lighting: Implement L key to process one dirty queue iteration (for development)\r\n\r\n### Compatibility\r\n\r\n**Platform:**\r\n- Windows 10/11 x64 only\r\n- DirectX 11 (no fallback to DX10 or DX9)\r\n- Visual Studio 2022 MSVC v143 compiler\r\n\r\n**Third-Party Dependencies:**\r\n- Engine project (shared codebase, C++20 features)\r\n- FMOD audio (already integrated in A1-A4)\r\n- TinyXML2 for XML parsing (BlockDefinitions.xml)\r\n- Perlin noise implementation (provided on Canvas)\r\n\r\n**Backward Compatibility:**\r\n- All Assignment 4 features SHALL continue to work\r\n- World save files MAY be incompatible (acceptable for assignment)\r\n- Existing chunk files MAY require regeneration due to Block structure change\r\n\r\n## Success Criteria\r\n\r\n### Functional Completeness\r\n- All 18 requirements implemented and tested\r\n- Rubric: 100/100 points achievable\r\n  - Block iterators: 5 pts\r\n  - Hidden surface removal: 5 pts\r\n  - Mipmapping: 5 pts (optional)\r\n  - Data structures: 15 pts\r\n  - Light propagation: 20 pts\r\n  - World shader: 15 pts\r\n  - Digging/placing: 20 pts\r\n  - Outdoor effects: 15 pts\r\n- Additional quality improvements (not graded, but enhance experience):\r\n  - Req 17: Tree variation creates more natural-looking forests\r\n  - Req 18: Smooth rendering eliminates visual distractions\r\n\r\n### Performance Targets\r\n- 60 FPS sustained in Release build\r\n- <16ms frame time during chunk activation\r\n- Lighting updates complete within same frame\r\n\r\n### Visual Quality\r\n- No visible artifacts at chunk boundaries\r\n- Smooth fog transitions\r\n- Realistic light falloff (15 blocks range)\r\n- Atmospheric day/night cycle\r\n\r\n### Code Quality\r\n- Zero compile warnings\r\n- No unnecessary files submitted to Perforce\r\n- Proper Perforce depot path submission\r\n- Buddy build successful (compiles on teammate's machine)\r\n\r\n## Assumptions and Constraints\r\n\r\n### Assumptions\r\n- User has completed Assignments 1-4 successfully\r\n- Block structure can be expanded from 1 byte to 3 bytes (memory acceptable)\r\n- Frame budget allows for full lighting propagation per frame (no amortization)\r\n- Professor's reference build demonstrates expected behavior\r\n\r\n### Constraints\r\n- Must use provided sprite sheets and BlockDefinitions.xml (no modifications)\r\n- Must use provided Perlin noise functions (from Canvas)\r\n- All DirectX 11 activity on main thread only (threading constraint)\r\n- Maximum light value = 15 (4-bit storage per light type)\r\n- Chunk size fixed at 32×32×256 blocks (inherited from A4)\r\n\r\n## Risks and Mitigations\r\n\r\n| Risk | Impact | Likelihood | Mitigation |\r\n|------|---------|-----------|------------|\r\n| Lighting propagation too slow (>60 FPS drop) | High | Medium | Optimize dirty queue processing, profile with actual data, consider amortization if needed |\r\n| Chunk boundary lighting artifacts | Medium | Medium | Thorough testing of BlockIterator edge cases, visual inspection |\r\n| Memory bloat from 3-byte blocks | Medium | Low | Monitor chunk memory usage, acceptable 3x increase per assignment |\r\n| DirectX 11 memory leaks | High | Low | Use existing three-stage shutdown (fixed in A4 Phase 5B), track buffer creation/deletion |\r\n| Dirty queue infinite loops | High | Low | Add iteration limit failsafe, debug step-through with L key |\r\n| Raycast precision errors | Medium | Low | Use Professor's Fast Voxel Raycast reference implementation, test edge cases |\r\n| Mesh flashing/jittering persists after fixes | Medium | Medium | Implement debug visualization (F4), profile mesh rebuild timing, use performance counters to identify root cause |\r\n| Tree variation creates cross-chunk issues | Low | Low | Clamp max radius to 8 blocks, ensure TreeStamp placement respects chunk boundaries, test at chunk edges |\r\n\r\n## Dependencies\r\n\r\n### Internal Dependencies\r\n- Assignment 4 completion (world generation, chunk system, threading)\r\n- Engine project (Renderer, JobSystem, Camera, Clock, Input)\r\n- CLAUDE.md documentation (current SimpleMiner state)\r\n\r\n### External Dependencies\r\n- DirectX 11 SDK (included with Windows SDK)\r\n- Visual Studio 2022 with C++20 support\r\n- FMOD audio library\r\n- TinyXML2 library\r\n- Perlin noise implementation (provided)\r\n\r\n### Data Dependencies\r\n- BlockDefinitions.xml (provided, must use unchanged)\r\n- Sprite sheets (64x faithful pack, provided)\r\n- Default.hlsl shader (existing, requires modification)\r\n\r\n## Timeline and Milestones\r\n\r\n**Total Duration**: 20 days (3 weeks)\r\n**Key Change from Original**: Added Phase 10 (Quality Improvements) for tree variation and mesh fixes\r\n\r\n### Phase 1: Foundation (Days 1-3)\r\n- Expand Block class to 3 bytes\r\n- Implement bit flag methods\r\n- Add lighting data getters/setters\r\n- **Milestone**: `sizeof(Block) == 3`, all tests pass\r\n\r\n### Phase 2: Block Iterators (Days 2-3)\r\n- Implement cross-chunk boundary navigation\r\n- Test all 6 directions at chunk edges\r\n- **Milestone**: Raycast works across chunk boundaries\r\n\r\n### Phase 3: Lighting Data Structures (Days 3-5)\r\n- Create global dirty queue in World\r\n- Implement dirty flag management\r\n- Add chunk activation lighting initialization\r\n- **Milestone**: Chunks activate with correct sky light (no propagation yet)\r\n\r\n### Phase 4: Light Propagation Algorithm (Days 5-8)\r\n- Implement ProcessDirtyLighting() loop\r\n- Calculate correct light values (sky, emission, neighbor propagation)\r\n- Test with single glowstone, verify 15→0 falloff\r\n- **Milestone**: Light propagates correctly within single chunk\r\n\r\n### Phase 5: Cross-Chunk Lighting (Days 8-10)\r\n- Extend propagation to chunk boundaries\r\n- Test glowstone near chunk edge\r\n- Verify seamless lighting across chunks\r\n- **Milestone**: No lighting artifacts at chunk boundaries\r\n\r\n### Phase 6: Vertex Lighting and Shaders (Days 10-12)\r\n- Modify mesh building to use neighbor light values\r\n- Create World shader constant buffer\r\n- Implement pixel shader lighting calculations\r\n- Add fog distance-based blending\r\n- **Milestone**: Chunks render with correct lighting colors\r\n\r\n### Phase 7: Raycasting and Block Manipulation (Days 12-14)\r\n- Implement Fast Voxel Raycast with BlockIterator\r\n- Add block digging with sky propagation\r\n- Add block placement with sky clearing\r\n- Implement block highlight rendering\r\n- **Milestone**: Can dig/place blocks with correct lighting updates\r\n\r\n### Phase 8: Outdoor Effects (Days 14-15)\r\n- Implement day/night cycle time system\r\n- Add sky color transitions\r\n- Add lightning strikes (Perlin noise)\r\n- Add glowstone flickering\r\n- **Milestone**: Atmospheric effects working, smooth transitions\r\n\r\n### Phase 9: Optimization and Polish (Days 15-17)\r\n- Profile lighting performance\r\n- Optimize dirty queue processing if needed\r\n- Add hidden surface removal at boundaries\r\n- Implement mipmapping (optional)\r\n- **Milestone**: 60 FPS sustained\r\n\r\n### Phase 10: Quality Improvements (Days 17-18)\r\n- Implement tree height and radius variation (Req 17)\r\n  - Add Perlin noise for height and radius\r\n  - Update TreeStamp generation with biome-specific ranges\r\n  - Test in all 5 tree biomes (Oak, Spruce, Jungle, Acacia, Birch)\r\n- Fix mesh flashing and jittering (Req 18)\r\n  - Implement double-buffered mesh updates\r\n  - Fix chunk activation mesh timing\r\n  - Add F4 debug visualization\r\n- **Milestone**: Natural tree variation, smooth rendering\r\n\r\n### Phase 11: Testing and Submission (Days 18-20)\r\n- Comprehensive testing of all features\r\n- Buddy build verification\r\n- Fix compile warnings\r\n- Clean Perforce submission\r\n- **Milestone**: Assignment complete, ready to submit\r\n\r\n## Glossary\r\n\r\n| Term | Definition |\r\n|------|------------|\r\n| **Influence Map** | A grid where each cell stores a value counting down from a source (15→14→...→0), unlike distance fields which count up |\r\n| **Dirty Queue** | A global list of BlockIterators marking blocks with potentially incorrect light values that need recalculation |\r\n| **Sky Block** | A non-opaque block with no opaque blocks above it (IsSky flag set), receives full outdoor light (15) |\r\n| **Nibble** | 4 bits, storing values 0-15 (half a byte) |\r\n| **Opaque Block** | A block that prevents light propagation (stone, glowstone, cobblestone) |\r\n| **Diminishing Add** | Formula `1 - (1-a)(1-b)` for combining lights without simple addition (avoids unrealistic brightness) |\r\n| **Flyweight Pattern** | Design pattern where Block (1-3 bytes) references shared BlockDefinition data to save memory |\r\n| **Fast Voxel Raycast** | Algorithm by Amanatides & Woo for efficiently traversing a voxel grid along a ray |\r\n| **Chunk Boundary** | Edge where x=0/31, y=0/31 where blocks must check neighbor chunks for data |\r\n| **Mipmapping** | Pre-generating smaller texture versions to reduce aliasing when viewed at distance |\r\n| **Activation Range** | Distance from camera where chunks activate (480 blocks = 15 chunk radius per A4) |\r\n\r\n## References\r\n\r\n- **Assignment Document**: `.claude/docs/A5/Assignment 05 - Rendering and Lighting.txt`\r\n- **Light Propagation Lecture**: `.claude/docs/A5/Light Propogation.txt` (Professor Forseth's transcript)\r\n- **SimpleMiner Documentation**: `CLAUDE.md` (root level, current status)\r\n- **Codebase Analysis**: Comprehensive exploration completed prior to requirements creation\r\n- **Minecraft Lighting Reference**: Java Edition lighting system (industry standard for voxel lighting)\r\n",
  "fileStats": {
    "size": 36480,
    "lines": 787,
    "lastModified": "2025-11-15T05:37:22.943Z"
  },
  "comments": []
}