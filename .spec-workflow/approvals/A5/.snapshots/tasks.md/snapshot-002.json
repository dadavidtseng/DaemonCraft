{
  "id": "snapshot_1763251825470_tl5959ggm",
  "approvalId": "approval_1763246077095_0dvqxvjjw",
  "approvalTitle": "Assignment 5 Tasks Document - 13 Implementation Phases",
  "version": 2,
  "timestamp": "2025-11-16T00:10:25.469Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Assignment 5: Rendering and Lighting - Tasks Document\r\n\r\n**Spec:** A5 - Rendering and Lighting System\r\n**Created:** 2025-11-15\r\n**Status:** Planning Complete, Ready for Implementation\r\n\r\n---\r\n\r\n## Task Overview\r\n\r\nThis document breaks down the Assignment 5 implementation into 13 sequential phases. Each task includes:\r\n- **Files to modify/create** with specific line numbers where applicable\r\n- **Implementation guidance** with pseudocode\r\n- **Verification criteria** for acceptance testing\r\n- **Dependencies** to ensure correct execution order\r\n- **AI agent prompts** for autonomous task execution\r\n\r\n**Critical Notes:**\r\n- All DirectX 11 operations must execute on main thread only\r\n- Block structure expansion breaks existing save files (1→3 bytes)\r\n- Performance targets: 60 FPS sustained, <8ms lighting budget, <100ms cross-chunk latency\r\n- Do NOT modify Default.hlsl - create new World.hlsl instead\r\n\r\n---\r\n\r\n## Phase 1: Core Data Structures (Tasks 1-3)\r\n\r\n### ☐ 1. Block Structure Expansion\r\n\r\n**Files:**\r\n- `Code/Game/Framework/Block.hpp` (TO_MODIFY)\r\n- `Code/Game/Framework/Block.cpp` (TO_MODIFY)\r\n\r\n**Purpose:** Expand Block class from 1 byte to 3 bytes to support lighting data and bit flags. This is the foundation for the entire lighting system.\r\n\r\n**Implementation:**\r\n1. Modify Block.hpp:\r\n   - Keep `uint8_t m_typeIndex` (existing)\r\n   - Add `uint8_t m_lightingData` (high nibble: outdoor 0-15, low nibble: indoor 0-15)\r\n   - Add `uint8_t m_bitFlags` for boolean flags\r\n   - Add inline accessors: `GetOutdoorLight()`, `GetIndoorLight()`, `SetOutdoorLight()`, `SetIndoorLight()`\r\n   - Add `IsSkyVisible()` flag accessor\r\n   - Ensure POD compliance for memcpy operations\r\n\r\n2. Update Block.cpp:\r\n   - Implement inline accessor methods\r\n   - Add debug validation (light values 0-15)\r\n\r\n**Verification:**\r\n- [ ] Compile without errors\r\n- [ ] `sizeof(Block) == 3`\r\n- [ ] Set outdoor light to 15, verify `GetOutdoorLight()` returns 15\r\n- [ ] Set indoor light to 8, verify `GetIndoorLight()` returns 8\r\n- [ ] Verify both lights can be stored simultaneously without interference\r\n\r\n**Notes:** This changes Block from 1 byte to 3 bytes. All existing Chunk storage (16x16x128 = 32,768 blocks per chunk) will triple in memory from 32KB to 96KB per chunk. This is acceptable per requirements.\r\n\r\n_Requirements: 1, 2, 3_\r\n\r\n_Prompt: Role: C++ Systems Programmer specializing in low-level data structures and memory optimization | Task: Expand Block class from 1 to 3 bytes following requirements 1-3, adding lighting data (outdoor/indoor nibbles) and bit flags with inline accessors, ensuring POD compliance for memcpy operations | Restrictions: Must maintain POD type, all accessors must be inline for performance, validate light values 0-15 in debug builds only | Success: sizeof(Block)==3, accessors work correctly, both light channels store/retrieve independently, POD compliance verified with std::is_pod_\r\n\r\n---\r\n\r\n### ☐ 2. BlockIterator Cross-Chunk Navigation\r\n\r\n**Files:**\r\n- `Code/Game/Framework/BlockIterator.hpp` (TO_MODIFY)\r\n- `Code/Game/Framework/BlockIterator.cpp` (TO_MODIFY)\r\n- `Code/Game/Gameplay/World.hpp` (REFERENCE)\r\n\r\n**Purpose:** Extend existing BlockIterator neighbor methods (GetNorthNeighbor, GetSouthNeighbor, etc.) to handle chunk boundaries by fetching neighbor chunks from World.\r\n\r\n**Implementation:**\r\n1. Modify BlockIterator.hpp:\r\n   - Keep existing 6 neighbor methods (already exist in codebase)\r\n   - Add `World* m_world` pointer to BlockIterator constructor\r\n   - Methods should detect edge conditions (x==0, x==15, y==0, y==15, z==0, z==127)\r\n   - When at edge, calculate neighbor chunk coordinates\r\n   - Call `m_world->GetChunk(neighborChunkCoords)`\r\n   - Return BlockIterator pointing to correct block in neighbor chunk\r\n   - Return invalid BlockIterator if neighbor chunk not loaded\r\n\r\n2. Pseudocode pattern for GetEastNeighbor():\r\n```cpp\r\nBlockIterator BlockIterator::GetEastNeighbor() const {\r\n    int localX = m_blockIndex % CHUNK_SIZE_X;\r\n    if (localX < CHUNK_SIZE_X - 1) {\r\n        return BlockIterator(m_chunk, m_blockIndex + 1); // Same chunk\r\n    } else {\r\n        IntVec2 neighborCoords = m_chunk->GetChunkCoords() + IntVec2(1, 0);\r\n        Chunk* neighborChunk = m_world->GetChunk(neighborCoords);\r\n        if (!neighborChunk) return BlockIterator(); // Invalid\r\n        int neighborIndex = /* calculate index at x=0, same y, same z */;\r\n        return BlockIterator(neighborChunk, neighborIndex);\r\n    }\r\n}\r\n```\r\n\r\n3. Update all 6 methods with this pattern\r\n\r\n**Verification:**\r\n- [ ] Create test chunk at (0,0)\r\n- [ ] Get block at east edge (x=15)\r\n- [ ] Call GetEastNeighbor()\r\n- [ ] Verify returned BlockIterator points to chunk (1,0) at x=0\r\n- [ ] Test all 6 directions at chunk boundaries\r\n- [ ] Verify returns invalid iterator when neighbor chunk not loaded\r\n\r\n**Notes:** REUSE EXISTING CODE: BlockIterator already has GetNorthNeighbor(), GetSouthNeighbor(), GetEastNeighbor(), GetWestNeighbor(), GetUpNeighbor(), GetDownNeighbor() at BlockIterator.hpp. Just extend them to handle chunk boundaries.\r\n\r\n_Leverage: Code/Game/Framework/BlockIterator.hpp (existing neighbor methods), Code/Game/Gameplay/World.hpp (GetChunk method)_\r\n\r\n_Requirements: 4_\r\n\r\n_Dependencies: Task 1 (Block Structure Expansion)_\r\n\r\n_Prompt: Role: C++ Game Engine Developer specializing in spatial partitioning and chunk systems | Task: Extend existing BlockIterator 6-direction neighbor methods to handle cross-chunk boundaries following requirement 4, adding World* pointer and using World::GetChunk() for neighbor chunk fetching | Restrictions: Must reuse existing GetNorthNeighbor/South/East/West/Up/Down methods, return invalid iterator when neighbor not loaded, maintain const-correctness | Success: All 6 methods correctly traverse chunk boundaries, invalid iterator returned when neighbor unloaded, edge cases handled (x==0,15 y==0,15 z==0,127)_\r\n\r\n---\r\n\r\n### ☐ 3. Chunk Lighting Initialization\r\n\r\n**Files:**\r\n- `Code/Game/Framework/Chunk.cpp` (TO_MODIFY) - Add InitializeLighting() call at end of GenerateTerrain()\r\n- `Code/Game/Framework/Chunk.hpp` (TO_MODIFY) - Declare InitializeLighting() private method\r\n- `Code/Game/Definition/BlockDefinition.hpp` (REFERENCE) - IsOpaque() and GetEmissiveValue() methods\r\n\r\n**Purpose:** Initialize outdoor and indoor lighting values when chunks are first generated. Set sky-visible blocks to outdoor=15, everything else to 0.\r\n\r\n**Implementation:**\r\n1. Add private method to Chunk class: `void InitializeLighting()`\r\n2. Call `InitializeLighting()` at end of `Chunk::GenerateTerrain()` (after all terrain gen completes)\r\n3. Scan all blocks from top (z=127) downward for each (x,y) column:\r\n   - Find first solid/opaque block from top\r\n   - Set all air blocks above to: outdoor=15, indoor=0, skyVisible=true\r\n   - Set all blocks at/below first solid to: outdoor=0, indoor=0, skyVisible=false\r\n   - Special case: Emissive blocks (glowstone, lava) set indoor=15\r\n\r\n**Pseudocode:**\r\n```cpp\r\nvoid Chunk::InitializeLighting() {\r\n    for (int x = 0; x < 16; x++) {\r\n        for (int y = 0; y < 16; y++) {\r\n            bool foundSolid = false;\r\n            for (int z = 127; z >= 0; z--) {\r\n                Block& block = GetBlock(x, y, z);\r\n                if (!foundSolid && block.IsOpaque()) {\r\n                    foundSolid = true;\r\n                }\r\n                if (!foundSolid) {\r\n                    block.SetOutdoorLight(15);\r\n                    block.SetIsSkyVisible(true);\r\n                } else {\r\n                    block.SetOutdoorLight(0);\r\n                }\r\n                if (block.IsEmissive()) {\r\n                    block.SetIndoorLight(block.GetEmissiveValue());\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**Verification:**\r\n- [ ] Generate new chunk\r\n- [ ] Verify air blocks above terrain have outdoor=15\r\n- [ ] Verify solid blocks have outdoor=0\r\n- [ ] Verify glowstone blocks have indoor=15\r\n- [ ] Verify no crashes during chunk generation\r\n\r\n**Notes:** This runs once per chunk during generation. Does NOT handle cross-chunk lighting yet - that's Phase 4.\r\n\r\n_Leverage: Code/Game/Definition/BlockDefinition.hpp (IsOpaque, GetEmissiveValue)_\r\n\r\n_Requirements: 5_\r\n\r\n_Dependencies: Task 1 (Block Structure Expansion)_\r\n\r\n_Prompt: Role: C++ Game Developer specializing in procedural generation and lighting systems | Task: Implement InitializeLighting() method following requirement 5, scanning top-down per column to set sky-visible blocks to outdoor=15 and emissive blocks to indoor=15, called at end of GenerateTerrain() | Restrictions: Must run only once during chunk generation, do not handle cross-chunk propagation yet, use IsOpaque() and GetEmissiveValue() from BlockDefinition | Success: Air blocks above terrain have outdoor=15, solid blocks have outdoor=0, emissive blocks have indoor=15, no crashes during generation_\r\n\r\n---\r\n\r\n## Phase 2: Lighting Propagation (Tasks 4-6)\r\n\r\n### ☐ 4. World Dirty Light Queue\r\n\r\n**Files:**\r\n- `Code/Game/Gameplay/World.hpp` (TO_MODIFY) - Add m_dirtyLightQueue and processing methods\r\n- `Code/Game/Gameplay/World.cpp` (TO_MODIFY) - Implement dirty queue processing with time budget\r\n\r\n**Purpose:** Add global dirty light queue to World class for tracking blocks that need light recalculation. This queue will be processed every frame with 8ms time budget.\r\n\r\n**Implementation:**\r\n1. Modify World.hpp:\r\n   - Add member: `std::deque<BlockIterator> m_dirtyLightQueue;`\r\n   - Add method: `void AddToDirtyLightQueue(BlockIterator blockIter);`\r\n   - Add method: `void ProcessDirtyLighting(float maxTimeSeconds);`\r\n\r\n2. Modify World.cpp:\r\n   - Implement AddToDirtyLightQueue(): Check if already in queue, add to back\r\n   - Implement ProcessDirtyLighting():\r\n     - Start timer\r\n     - While (queue not empty AND time < maxTimeSeconds):\r\n       - Pop block from front of queue\r\n       - Recalculate lighting (see Task 5)\r\n       - Process next block\r\n     - Return when time budget exhausted or queue empty\r\n\r\n3. Call `ProcessDirtyLighting(0.008f)` from `World::Update()` (8ms budget per requirements)\r\n\r\n**Verification:**\r\n- [ ] Add 1000 blocks to dirty queue\r\n- [ ] Call ProcessDirtyLighting(0.001) // 1ms budget\r\n- [ ] Verify only partial queue processed\r\n- [ ] Verify no crashes\r\n- [ ] Verify queue eventually empties over multiple frames\r\n\r\n**Notes:** This queue will be populated by: chunk activation (Task 6), block dig/place (Task 11), and cross-chunk lighting propagation (Task 5).\r\n\r\n_Requirements: 6_\r\n\r\n_Dependencies: Task 2 (BlockIterator Cross-Chunk Navigation)_\r\n\r\n_Prompt: Role: C++ Game Engine Developer specializing in performance optimization and frame budgeting | Task: Implement dirty light queue in World class following requirement 6, adding std::deque<BlockIterator> m_dirtyLightQueue with AddToDirtyLightQueue() and ProcessDirtyLighting(maxTime) methods, called from World::Update() with 8ms budget | Restrictions: Must respect time budget per frame, check for duplicates before adding to queue, process FIFO order | Success: Queue processes blocks until time budget exhausted, 1000 blocks spread across multiple frames, no frame spikes >8ms for lighting_\r\n\r\n---\r\n\r\n### ☐ 5. Light Propagation Algorithm\r\n\r\n**Files:**\r\n- `Code/Game/Gameplay/World.cpp` (TO_MODIFY) - Add RecalculateBlockLighting() implementing influence map algorithm\r\n- `Code/Game/Gameplay/World.hpp` (TO_MODIFY) - Declare RecalculateBlockLighting() method\r\n\r\n**Purpose:** Implement influence map lighting propagation for both outdoor and indoor light. This is the core lighting algorithm.\r\n\r\n**Implementation:**\r\nAdd method to World.cpp: `void World::RecalculateBlockLighting(BlockIterator blockIter)`\r\n\r\n**Propagation algorithm (influence map, NOT distance field):**\r\n```cpp\r\nvoid World::RecalculateBlockLighting(BlockIterator blockIter) {\r\n    Block& block = blockIter.GetBlock();\r\n    uint8_t oldOutdoor = block.GetOutdoorLight();\r\n    uint8_t oldIndoor = block.GetIndoorLight();\r\n\r\n    // Calculate new outdoor light\r\n    uint8_t newOutdoor = 0;\r\n    if (block.IsSkyVisible()) {\r\n        newOutdoor = 15; // Direct skylight\r\n    } else {\r\n        // Find max neighbor outdoor light - 1\r\n        for (each of 6 neighbors) {\r\n            uint8_t neighborLight = neighbor.GetOutdoorLight();\r\n            if (neighborLight > 0) {\r\n                newOutdoor = max(newOutdoor, neighborLight - 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Calculate new indoor light\r\n    uint8_t newIndoor = block.IsEmissive() ? block.GetEmissiveValue() : 0;\r\n    if (!block.IsEmissive()) {\r\n        // Find max neighbor indoor light - 1\r\n        for (each of 6 neighbors) {\r\n            uint8_t neighborLight = neighbor.GetIndoorLight();\r\n            if (neighborLight > 0) {\r\n                newIndoor = max(newIndoor, neighborLight - 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Update block\r\n    block.SetOutdoorLight(newOutdoor);\r\n    block.SetIndoorLight(newIndoor);\r\n\r\n    // If values changed, add neighbors to dirty queue\r\n    if (newOutdoor != oldOutdoor || newIndoor != oldIndoor) {\r\n        for (each of 6 neighbors) {\r\n            AddToDirtyLightQueue(neighbor);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**Verification:**\r\n- [ ] Place glowstone block (indoor=15)\r\n- [ ] Verify adjacent air blocks get indoor=14\r\n- [ ] Verify blocks 2 away get indoor=13\r\n- [ ] Verify light stops after 15 blocks\r\n- [ ] Remove glowstone, verify light propagates away (darkens)\r\n- [ ] Test cross-chunk propagation at chunk boundaries\r\n\r\n**Notes:** This is INFLUENCE MAP propagation (light spreads from sources with -1 per block), NOT distance field (precalculated distances). Must handle cross-chunk boundaries using Task 2's BlockIterator navigation.\r\n\r\n_Leverage: Task 2 BlockIterator cross-chunk neighbor methods, Task 4 dirty queue_\r\n\r\n_Requirements: 7_\r\n\r\n_Dependencies: Task 2 (BlockIterator Cross-Chunk Navigation), Task 4 (World Dirty Light Queue)_\r\n\r\n_Prompt: Role: Graphics Programmer specializing in lighting algorithms and voxel systems | Task: Implement influence map light propagation algorithm following requirement 7, using RecalculateBlockLighting() to propagate outdoor (skylight) and indoor (emissive) light independently with -1 per block distance, using BlockIterator for cross-chunk navigation | Restrictions: Must be influence map NOT distance field, handle both outdoor and indoor channels independently, add neighbors to dirty queue only if light changed, use 6-direction cross-chunk navigation | Success: Glowstone at 15 propagates to 14/13/12 etc, light stops at 15 blocks distance, cross-chunk propagation works, removing light source darkens area correctly_\r\n\r\n---\r\n\r\n### ☐ 6. Chunk Activation Lighting\r\n\r\n**Files:**\r\n- `Code/Game/Framework/Chunk.cpp` (TO_MODIFY) - Add OnActivate() edge block dirty queue population\r\n- `Code/Game/Framework/Chunk.hpp` (TO_MODIFY) - Declare OnActivate(World*) method\r\n- `Code/Game/Gameplay/World.cpp` (REFERENCE) - Chunk activation state machine\r\n\r\n**Purpose:** When chunks activate, populate dirty light queue with edge blocks to propagate lighting from neighbor chunks.\r\n\r\n**Implementation:**\r\n1. Add method to Chunk: `void Chunk::OnActivate(World* world)`\r\n2. Call from World::ActivateChunk() after chunk becomes ACTIVE state\r\n3. For each of 4 edge faces (north, south, east, west):\r\n   - Add all blocks on that face to dirty light queue\r\n   - This triggers cross-chunk light propagation\r\n\r\n**Pseudocode:**\r\n```cpp\r\nvoid Chunk::OnActivate(World* world) {\r\n    // Add north edge (y = CHUNK_SIZE_Y - 1)\r\n    for (int x = 0; x < CHUNK_SIZE_X; x++) {\r\n        for (int z = 0; z < CHUNK_SIZE_Z; z++) {\r\n            BlockIterator iter(this, GetBlockIndex(x, CHUNK_SIZE_Y - 1, z));\r\n            world->AddToDirtyLightQueue(iter);\r\n        }\r\n    }\r\n    // Repeat for south, east, west edges\r\n}\r\n```\r\n\r\n**Verification:**\r\n- [ ] Load chunk A with glowstone at east edge\r\n- [ ] Load chunk B to the east\r\n- [ ] Verify light from chunk A propagates into chunk B\r\n- [ ] Verify no crashes during chunk activation\r\n- [ ] Test with multiple chunks in all 4 directions\r\n\r\n**Notes:** This ensures lighting propagates correctly when new chunks load adjacent to existing chunks. Top/bottom faces don't need this (world has finite Z height 0-128).\r\n\r\n_Leverage: Code/Game/Gameplay/World.cpp chunk activation state machine_\r\n\r\n_Requirements: 8_\r\n\r\n_Dependencies: Task 4 (World Dirty Light Queue), Task 5 (Light Propagation Algorithm)_\r\n\r\n_Prompt: Role: C++ Game Engine Developer specializing in chunk streaming and activation systems | Task: Implement Chunk::OnActivate() following requirement 8, populating dirty light queue with all blocks on 4 edge faces (N/S/E/W) when chunk activates to trigger cross-chunk light propagation from neighbor chunks | Restrictions: Must add all edge blocks (not just lit ones), call from World::ActivateChunk() after ACTIVE state, skip top/bottom faces (finite Z), handle case when neighbor chunks not loaded | Success: Light from chunk A edge propagates into newly activated chunk B, all 4 horizontal directions tested, no crashes during activation_\r\n\r\n---\r\n\r\n## Phase 3: Visual Rendering (Tasks 7-9)\r\n\r\n### ☐ 7. Mesh Building with Vertex Lighting\r\n\r\n**Files:**\r\n- `Code/Game/Framework/Chunk.cpp` (TO_MODIFY) - Modify RebuildMesh() to encode lighting in vertex colors\r\n- `Code/Game/Framework/Chunk.hpp` (REFERENCE) - Vertex format verification\r\n\r\n**Purpose:** Modify chunk mesh building to encode lighting values in vertex colors (r=outdoor, g=indoor, b=directional shading).\r\n\r\n**Implementation:**\r\n1. Modify `Chunk::RebuildMesh()`:\r\n   - For each visible block face being added to mesh\r\n   - Calculate vertex color based on Block lighting data:\r\n     - r channel: outdoor light / 15.0 (normalized to 0.0-1.0)\r\n     - g channel: indoor light / 15.0\r\n     - b channel: directional shading (top=1.0, sides=0.8, bottom=0.6)\r\n   - Set vertex color for all 4 vertices of the face\r\n\r\n**Pseudocode:**\r\n```cpp\r\nvoid Chunk::RebuildMesh() {\r\n    // ... existing mesh building loop ...\r\n    for (each visible block face) {\r\n        Block& block = GetBlock(x, y, z);\r\n        float r = block.GetOutdoorLight() / 15.0f;\r\n        float g = block.GetIndoorLight() / 15.0f;\r\n        float b = GetDirectionalShading(faceDirection); // 1.0 top, 0.8 sides, 0.6 bottom\r\n        Rgba8 vertexColor = Rgba8(r * 255, g * 255, b * 255, 255);\r\n\r\n        // Add 4 vertices with this color\r\n        AddQuadToMesh(positions, uvs, vertexColor);\r\n    }\r\n}\r\n```\r\n\r\n**Verification:**\r\n- [ ] Rebuild mesh for chunk with varied lighting\r\n- [ ] Inspect vertex buffer data\r\n- [ ] Verify vertex colors encode lighting correctly\r\n- [ ] Verify r channel varies with outdoor light (0-255 based on sunlight)\r\n- [ ] Verify g channel varies with indoor light (0-255 based on emissive blocks)\r\n- [ ] Verify b channel matches directional shading (255 top, 204 sides, 153 bottom)\r\n\r\n**Notes:** This encodes 3 independent lighting values: outdoor (sunlight), indoor (artificial light), and directional (ambient occlusion-like shading). World.hlsl shader will combine them in Task 8.\r\n\r\n_Leverage: Code/Game/Framework/Chunk.cpp existing RebuildMesh()_\r\n\r\n_Requirements: 9_\r\n\r\n_Dependencies: Task 1 (Block Structure Expansion)_\r\n\r\n_Prompt: Role: Graphics Programmer specializing in voxel rendering and vertex data encoding | Task: Modify Chunk::RebuildMesh() following requirement 9 to encode Block lighting in vertex colors with r=outdoor/15.0, g=indoor/15.0, b=directional shading (1.0 top, 0.8 sides, 0.6 bottom) | Restrictions: Must use existing RebuildMesh() structure, encode all 3 channels for every vertex, normalize to 0-1 range then convert to Rgba8 0-255, maintain existing UV and position data | Success: Vertex buffer contains correct lighting in RGB channels, outdoor varies 0-255 with sunlight, indoor varies with emissive blocks, directional shading distinct per face orientation_\r\n\r\n---\r\n\r\n### ☐ 8. World Shader Creation\r\n\r\n**Files:**\r\n- `Run/Data/Shaders/World.hlsl` (CREATE) - NEW shader file for world rendering with lighting\r\n- `Run/Data/Shaders/Default.hlsl` (REFERENCE) - Reference for MVP matrix setup and texture sampling\r\n- `Code/Game/Gameplay/Game.cpp` (TO_MODIFY) - Load World.hlsl shader, bind before rendering chunks (around line 419)\r\n\r\n**Purpose:** Create NEW World.hlsl shader file (do NOT modify Default.hlsl) with vertex and pixel shaders that combine outdoor, indoor, and directional lighting.\r\n\r\n**Implementation:**\r\n1. Create new file: `Run/Data/Shaders/World.hlsl`\r\n\r\n2. Vertex shader (passes through lighting in vertex colors):\r\n```hlsl\r\nstruct vs_input_t {\r\n    float3 position : POSITION;\r\n    float4 color : COLOR;\r\n    float2 uv : TEXCOORD;\r\n};\r\n\r\nstruct v2p_t {\r\n    float4 position : SV_Position;\r\n    float4 color : COLOR;\r\n    float2 uv : TEXCOORD;\r\n};\r\n\r\nv2p_t VertexMain(vs_input_t input) {\r\n    v2p_t output;\r\n    output.position = mul(float4(input.position, 1.0), ModelViewProjection);\r\n    output.color = input.color; // Pass through lighting\r\n    output.uv = input.uv;\r\n    return output;\r\n}\r\n```\r\n\r\n3. Pixel shader (combines outdoor/indoor/directional):\r\n```hlsl\r\nTexture2D diffuseTexture : register(t0);\r\nSamplerState diffuseSampler : register(s0);\r\n\r\ncbuffer TimeConstants : register(b1) {\r\n    float GameTime;\r\n    float OutdoorBrightness; // Day/night cycle\r\n    float2 padding;\r\n};\r\n\r\nfloat4 PixelMain(v2p_t input) : SV_Target0 {\r\n    float4 texColor = diffuseTexture.Sample(diffuseSampler, input.uv);\r\n\r\n    float outdoor = input.color.r * OutdoorBrightness; // Modulated by day/night\r\n    float indoor = input.color.g; // Constant\r\n    float directional = input.color.b; // Directional shading\r\n\r\n    float finalBrightness = max(outdoor, indoor) * directional;\r\n\r\n    return texColor * float4(finalBrightness, finalBrightness, finalBrightness, 1.0);\r\n}\r\n```\r\n\r\n4. Load shader in Game.cpp (around line 419):\r\n```cpp\r\n// In Game::Startup() or Game::Initialize()\r\nm_worldShader = g_renderer->CreateShader(\"Data/Shaders/World.hlsl\");\r\n\r\n// When rendering chunks:\r\ng_renderer->BindShader(m_worldShader);\r\n// ... render chunk meshes ...\r\n```\r\n\r\n**Verification:**\r\n- [ ] Compile World.hlsl without errors\r\n- [ ] Load shader in Game.cpp\r\n- [ ] Render chunks with World.hlsl\r\n- [ ] Verify lighting affects brightness correctly\r\n- [ ] Verify outdoor light responds to OutdoorBrightness uniform (varies with day/night)\r\n- [ ] Verify indoor light is constant regardless of OutdoorBrightness\r\n\r\n**Notes:** This is a NEW file (World.hlsl), not modifying Default.hlsl per design revision. Reuse patterns from Default.hlsl for MVP matrix setup and texture sampling.\r\n\r\n_Leverage: Run/Data/Shaders/Default.hlsl for MVP matrix and texture sampling patterns_\r\n\r\n_Requirements: 10_\r\n\r\n_Dependencies: Task 7 (Mesh Building with Vertex Lighting)_\r\n\r\n_Prompt: Role: Graphics Programmer specializing in HLSL shader development and DirectX 11 | Task: Create NEW World.hlsl shader file following requirement 10 (do NOT modify Default.hlsl), implementing vertex shader passing through r/g/b vertex colors and pixel shader combining outdoor (r * OutdoorBrightness), indoor (g), and directional (b) lighting with max() operator, load in Game.cpp around line 419 | Restrictions: Must create new file not modify Default.hlsl, use cbuffer for OutdoorBrightness uniform, texture sample with diffuseTexture, final brightness = max(outdoor, indoor) * directional | Success: World.hlsl compiles without errors, chunks render with lighting, outdoor varies with OutdoorBrightness, indoor constant, directional shading visible on faces_\r\n\r\n---\r\n\r\n### ☐ 9. Day/Night Cycle\r\n\r\n**Files:**\r\n- `Code/Game/Gameplay/World.cpp` (TO_MODIFY) - Add day/night cycle update logic and constant buffer upload\r\n- `Code/Game/Gameplay/World.hpp` (TO_MODIFY) - Add m_worldTime and shader constant buffer members\r\n- `Code/Game/Framework/Block.cpp` (TO_MODIFY) - Add glowstone flicker to GetEmissiveValue()\r\n\r\n**Purpose:** Implement day/night cycle by modulating OutdoorBrightness uniform in World.hlsl. Add lightning strikes and glowstone flicker using Perlin noise.\r\n\r\n**Implementation:**\r\n1. Add to World.cpp:\r\n```cpp\r\nfloat m_worldTime = 0.0f;\r\nfloat m_dayNightCycleDuration = 240.0f; // 4 minutes per full cycle\r\n\r\nvoid World::Update(float deltaSeconds) {\r\n    m_worldTime += deltaSeconds;\r\n    float cyclePosition = fmod(m_worldTime, m_dayNightCycleDuration) / m_dayNightCycleDuration;\r\n\r\n    // Outdoor brightness: 1.0 at noon (0.5), 0.2 at midnight (0.0 or 1.0)\r\n    float outdoorBrightness = 0.5f + 0.5f * cos(cyclePosition * 2.0f * PI);\r\n    outdoorBrightness = RangeMap(outdoorBrightness, -1.0f, 1.0f, 0.2f, 1.0f);\r\n\r\n    // Lightning strikes (Perlin noise)\r\n    float lightningNoise = Compute2dPerlinNoise(m_worldTime * 10.0f, 0.0f, 2.0f, 3);\r\n    if (lightningNoise > 0.95f) {\r\n        outdoorBrightness = 1.5f; // Flash\r\n    }\r\n\r\n    // Update shader constant buffer\r\n    m_worldShaderConstants.OutdoorBrightness = outdoorBrightness;\r\n    m_worldShaderConstants.GameTime = m_worldTime;\r\n    g_renderer->CopyCPUToGPU(&m_worldShaderConstants, sizeof(m_worldShaderConstants), m_timeConstantBuffer);\r\n}\r\n```\r\n\r\n2. Glowstone flicker:\r\n   - Modify `Block::GetEmissiveValue()` for glowstone blocks\r\n   - Add Perlin noise based on world time\r\n   - Vary emissive value 13-15 instead of constant 15\r\n\r\n**Verification:**\r\n- [ ] Start game, observe outdoor brightness cycle over 4 minutes\r\n- [ ] Verify noon is bright (brightness ~1.0)\r\n- [ ] Verify midnight is dim (brightness ~0.2)\r\n- [ ] Verify occasional lightning flashes (rare, threshold 0.95)\r\n- [ ] Verify indoor light (torches, glowstone) remains constant throughout cycle\r\n- [ ] Verify glowstone flickers slightly (13-15 range)\r\n\r\n**Notes:** Day/night cycle affects ONLY outdoor light channel (r). Indoor light channel (g) remains constant. Lightning is rare (threshold 0.95 means ~5% of frames).\r\n\r\n_Leverage: Engine Perlin noise functions (Compute2dPerlinNoise)_\r\n\r\n_Requirements: 11, 12_\r\n\r\n_Dependencies: Task 8 (World Shader Creation)_\r\n\r\n_Prompt: Role: Gameplay Programmer specializing in environmental systems and shader integration | Task: Implement day/night cycle following requirements 11-12, modulating OutdoorBrightness uniform with cosine wave (240s cycle, 1.0 noon, 0.2 midnight), adding lightning flashes with Perlin noise (threshold 0.95), implementing glowstone flicker (13-15 range), uploading to shader constant buffer in World::Update() | Restrictions: Must only affect outdoor light channel, indoor light stays constant, lightning rare (5% frames), glowstone uses separate noise channel, update constant buffer every frame | Success: 4-minute day/night cycle visible, noon bright (1.0), midnight dim (0.2), occasional lightning flashes, glowstone flickers subtly, indoor lights unaffected_\r\n\r\n---\r\n\r\n## Phase 4: Interaction Systems (Tasks 10-11)\r\n\r\n### ☐ 10. Fast Voxel Raycast\r\n\r\n**Files:**\r\n- `Code/Game/Gameplay/World.cpp` (TO_MODIFY) - Add RaycastVoxel() method using Amanatides & Woo algorithm\r\n- `Code/Game/Gameplay/World.hpp` (TO_MODIFY) - Declare RaycastVoxel() and RaycastResult struct\r\n- `Code/Game/Gameplay/Player.cpp` (TO_MODIFY) - Use RaycastVoxel() for block selection instead of old raycast\r\n\r\n**Purpose:** Implement Amanatides & Woo fast voxel traversal algorithm for block selection raycast. This replaces any existing slower raycast.\r\n\r\n**Implementation:**\r\nAdd to World.cpp:\r\n```cpp\r\nRaycastResult World::RaycastVoxel(Vec3 start, Vec3 direction, float maxDistance) {\r\n    // Amanatides & Woo algorithm\r\n    Vec3 currentPos = start;\r\n    IntVec3 currentBlock = IntVec3(floor(currentPos));\r\n\r\n    Vec3 step = Sign(direction); // +1 or -1 for each axis\r\n    Vec3 tDelta = Abs(1.0f / direction); // Distance along ray to cross 1 voxel\r\n    Vec3 tMax = CalculateTMax(currentPos, direction, step); // Distance to next voxel boundary\r\n\r\n    float distanceTraveled = 0.0f;\r\n\r\n    while (distanceTraveled < maxDistance) {\r\n        // Check current block\r\n        Block* block = GetBlock(currentBlock);\r\n        if (block && block->IsSolid()) {\r\n            return RaycastResult(true, currentBlock, distanceTraveled);\r\n        }\r\n\r\n        // Step to next voxel (whichever axis crosses boundary first)\r\n        if (tMax.x < tMax.y && tMax.x < tMax.z) {\r\n            currentBlock.x += step.x;\r\n            distanceTraveled = tMax.x;\r\n            tMax.x += tDelta.x;\r\n        } else if (tMax.y < tMax.z) {\r\n            currentBlock.y += step.y;\r\n            distanceTraveled = tMax.y;\r\n            tMax.y += tDelta.y;\r\n        } else {\r\n            currentBlock.z += step.z;\r\n            distanceTraveled = tMax.z;\r\n            tMax.z += tDelta.z;\r\n        }\r\n    }\r\n\r\n    return RaycastResult(false); // No hit\r\n}\r\n```\r\n\r\n**Verification:**\r\n- [ ] Raycast from player position toward crosshair\r\n- [ ] Verify correct block selected (matches visual expectation)\r\n- [ ] Verify performance (<0.1ms per raycast)\r\n- [ ] Test at chunk boundaries (should traverse chunks correctly)\r\n- [ ] Test at world edges (should not crash)\r\n- [ ] Compare results to old raycast method if available\r\n\r\n**Notes:** This is much faster than incremental stepping (0.1 unit step distance). Amanatides & Woo guarantees we visit ONLY voxels the ray passes through, with zero missed blocks.\r\n\r\n_Requirements: 13_\r\n\r\n_Dependencies: None (independent system)_\r\n\r\n_Prompt: Role: Graphics Programmer specializing in raycasting algorithms and voxel traversal | Task: Implement Amanatides & Woo fast voxel raycast algorithm following requirement 13, using RaycastVoxel(start, direction, maxDistance) to find first solid block along ray with tMax/tDelta stepping, replace old raycast in Player.cpp | Restrictions: Must use Amanatides & Woo algorithm (not incremental stepping), visit only voxels ray passes through, handle chunk boundaries correctly, return RaycastResult with hit/miss/distance | Success: Correct block selected at crosshair, performance <0.1ms per raycast, works at chunk boundaries, no crashes at world edges, matches expected results_\r\n\r\n---\r\n\r\n### ☐ 11. Block Dig/Place Lighting Update\r\n\r\n**Files:**\r\n- `Code/Game/Gameplay/World.cpp` (TO_MODIFY) - Add lighting update logic to SetBlock() or DigBlock()\r\n- `Code/Game/Gameplay/Player.cpp` (TO_MODIFY) - Call SetBlock() when digging/placing blocks\r\n\r\n**Purpose:** When player digs or places blocks, update lighting by adding affected blocks to dirty light queue and marking chunk mesh dirty.\r\n\r\n**Implementation:**\r\nModify `World::SetBlock()` or `Player::DigBlock()`:\r\n```cpp\r\nvoid World::SetBlock(IntVec3 coords, uint8_t typeIndex) {\r\n    Chunk* chunk = GetChunkContainingBlock(coords);\r\n    if (!chunk) return;\r\n\r\n    Block* block = chunk->GetBlock(coords);\r\n    uint8_t oldTypeIndex = block->m_typeIndex;\r\n    block->m_typeIndex = typeIndex;\r\n\r\n    // Reset lighting for this block\r\n    block->SetOutdoorLight(0);\r\n    block->SetIndoorLight(0);\r\n    if (block->IsEmissive()) {\r\n        block->SetIndoorLight(block->GetEmissiveValue());\r\n    }\r\n\r\n    // Add this block and all 6 neighbors to dirty light queue\r\n    BlockIterator iter(chunk, coords);\r\n    AddToDirtyLightQueue(iter);\r\n    AddToDirtyLightQueue(iter.GetNorthNeighbor());\r\n    AddToDirtyLightQueue(iter.GetSouthNeighbor());\r\n    AddToDirtyLightQueue(iter.GetEastNeighbor());\r\n    AddToDirtyLightQueue(iter.GetWestNeighbor());\r\n    AddToDirtyLightQueue(iter.GetUpNeighbor());\r\n    AddToDirtyLightQueue(iter.GetDownNeighbor());\r\n\r\n    // Mark chunk mesh dirty (will rebuild next frame via Task 13)\r\n    chunk->MarkMeshDirty();\r\n\r\n    // Trigger ChunkSaveJob for modified chunk\r\n    // ... existing save logic ...\r\n}\r\n```\r\n\r\n**Verification:**\r\n- [ ] Place glowstone block in dark cave\r\n- [ ] Verify light propagates outward over next few frames\r\n- [ ] Dig glowstone block\r\n- [ ] Verify light fades away (darkens)\r\n- [ ] Verify chunk mesh rebuilds to show updated lighting\r\n- [ ] Verify modified chunk saves to disk (ChunkSaveJob triggered)\r\n\r\n**Notes:** Ensures lighting updates propagate from dig/place operations. Mesh rebuild is deferred via Task 13's double buffering system to prevent flashing.\r\n\r\n_Leverage: Task 4 dirty queue, Task 5 propagation, Task 13 mesh rebuild_\r\n\r\n_Requirements: 14_\r\n\r\n_Dependencies: Task 4 (World Dirty Light Queue), Task 5 (Light Propagation Algorithm)_\r\n\r\n_Prompt: Role: Gameplay Programmer specializing in player interaction and world modification systems | Task: Implement lighting update in SetBlock() following requirement 14, resetting block lighting to 0 (or emissive value), adding block and 6 neighbors to dirty queue using BlockIterator cross-chunk navigation, marking chunk mesh dirty for deferred rebuild, ensuring ChunkSaveJob triggers | Restrictions: Must add block AND 6 neighbors to dirty queue, use cross-chunk navigation for neighbors, mark mesh dirty (don't rebuild immediately), trigger save for modified chunk | Success: Placing glowstone propagates light over frames, digging glowstone darkens area, mesh updates to show lighting, chunk saves correctly_\r\n\r\n---\r\n\r\n## Phase 5: Additional Requirements (Tasks 12-13)\r\n\r\n### ☐ 12. Tree Height/Radius Variation (Requirement 17)\r\n\r\n**Files:**\r\n- `Code/Game/Framework/Chunk.cpp` (TO_MODIFY) - Add Perlin noise variation to tree generation (lines 1684-1864)\r\n- `Code/Game/Framework/Chunk.hpp` (REFERENCE) - TreeStamp structure and placement methods\r\n\r\n**Purpose:** Add Perlin noise-based height and radius variation to tree generation. Extend existing tree placement code.\r\n\r\n**Implementation:**\r\nModify tree generation code in Chunk.cpp (lines 1684-1864):\r\n```cpp\r\nvoid Chunk::PlaceTrees() {\r\n    // ... existing biome-specific tree placement ...\r\n\r\n    // For each tree placement position (x, y):\r\n    Vec2 worldPos = GetWorldCoordsForColumn(x, y);\r\n\r\n    // Generate height variation using Perlin noise\r\n    float heightNoise = Compute2dPerlinNoise(worldPos.x * 0.05f, worldPos.y * 0.05f, 1.0f, 3);\r\n    heightNoise = RangeMap(heightNoise, -1.0f, 1.0f, 0.0f, 1.0f); // Normalize to 0-1\r\n\r\n    // Generate radius variation using different noise channel (offset +1000)\r\n    float radiusNoise = Compute2dPerlinNoise(worldPos.x * 0.07f + 1000.0f, worldPos.y * 0.07f + 1000.0f, 1.0f, 3);\r\n    radiusNoise = RangeMap(radiusNoise, -1.0f, 1.0f, 0.0f, 1.0f);\r\n\r\n    // Apply biome-specific ranges (from Requirement 17):\r\n    int trunkHeight, canopyRadius;\r\n    if (biome == FOREST) { // Oak trees\r\n        trunkHeight = 4 + int(heightNoise * 3.0f); // 4-7 blocks\r\n        canopyRadius = 2 + int(radiusNoise * 2.0f); // 2-4 blocks\r\n    } else if (biome == TAIGA) { // Spruce trees\r\n        trunkHeight = 6 + int(heightNoise * 4.0f); // 6-10 blocks\r\n        canopyRadius = 1 + int(radiusNoise * 2.0f); // 1-3 blocks\r\n    } else if (biome == JUNGLE) { // Jungle trees\r\n        trunkHeight = 5 + int(heightNoise * 5.0f); // 5-10 blocks\r\n        canopyRadius = 2 + int(radiusNoise * 2.0f); // 2-4 blocks\r\n    }\r\n\r\n    // Use these values in existing TreeStamp generation\r\n    PlaceTreeStamp(x, y, surfaceZ, trunkHeight, canopyRadius, biome);\r\n}\r\n```\r\n\r\n**Verification:**\r\n- [ ] Generate chunks with forest biome\r\n- [ ] Verify oak trees have varied heights (4-7 blocks trunk)\r\n- [ ] Verify oak trees have varied canopy radius (2-4 blocks)\r\n- [ ] Generate taiga biome chunks\r\n- [ ] Verify spruce trees have different height range (6-10 blocks trunk)\r\n- [ ] Verify spruce trees have narrow canopy (1-3 blocks radius)\r\n- [ ] Verify trees in same biome are NOT identical (noise creates variation)\r\n\r\n**Notes:** REUSE EXISTING CODE at Chunk.cpp lines 1684-1864. Tree placement system already exists. Just add noise-based variation to trunk height and canopy radius. Use separate noise channels (different offsets +1000) for height vs radius.\r\n\r\n_Leverage: Code/Game/Framework/Chunk.cpp existing tree placement (lines 1684-1864)_\r\n\r\n_Requirements: 17 (Additional Requirement)_\r\n\r\n_Dependencies: None (independent enhancement)_\r\n\r\n_Prompt: Role: Procedural Generation Programmer specializing in natural feature variation and Perlin noise | Task: Add tree height/radius variation following Requirement 17, using Perlin noise with separate channels (offset +1000 for radius) to vary trunk height and canopy radius per biome (Oak 4-7h/2-4r, Spruce 6-10h/1-3r, Jungle 5-10h/2-4r), extending existing tree placement at Chunk.cpp lines 1684-1864 | Restrictions: Must reuse existing tree placement code, use separate noise channels for height vs radius, apply biome-specific ranges, do not change tree block types | Success: Forest oak trees vary 4-7 blocks height and 2-4 radius, taiga spruce 6-10h/1-3r, jungle 5-10h/2-4r, trees in same biome NOT identical_\r\n\r\n---\r\n\r\n### ☐ 13. Fix Mesh Flashing/Jittering (Requirement 18)\r\n\r\n**Files:**\r\n- `Code/Game/Framework/Chunk.hpp` (TO_MODIFY) - Add double vertex buffer pointers\r\n- `Code/Game/Framework/Chunk.cpp` (TO_MODIFY) - Implement MarkMeshDirty(), RebuildMeshInto(), update Render()\r\n- `Code/Game/Gameplay/World.hpp` (TO_MODIFY) - Add m_dirtyMeshQueue and ProcessDirtyMeshes() method\r\n- `Code/Game/Gameplay/World.cpp` (TO_MODIFY) - Implement ProcessDirtyMeshes() with time budget, call from Update()\r\n\r\n**Purpose:** Fix flashing/jittering when digging/placing blocks and activating chunks by implementing deferred mesh rebuild queue with double buffering.\r\n\r\n**Root Cause Analysis:**\r\n- Flashing occurs when chunk mesh is being rebuilt (RebuildMesh) while GPU is still rendering old mesh\r\n- Chunk activation triggers immediate RebuildMesh() which can take several milliseconds\r\n- Block dig/place marks chunk dirty, triggering RebuildMesh() next frame\r\n- Current system: Single vertex buffer per chunk, rebuilt in-place\r\n\r\n**Solution: Double Buffering + Deferred Rebuild Queue**\r\n\r\nAdd to Chunk.hpp:\r\n```cpp\r\nclass Chunk {\r\n    VertexBuffer* m_meshVBO_A = nullptr;\r\n    VertexBuffer* m_meshVBO_B = nullptr;\r\n    VertexBuffer* m_currentRenderVBO = nullptr; // Pointer to A or B\r\n    bool m_needsMeshRebuild = false;\r\n};\r\n```\r\n\r\nAdd to World.hpp:\r\n```cpp\r\nclass World {\r\n    std::deque<Chunk*> m_dirtyMeshQueue; // Chunks needing mesh rebuild\r\n    void ProcessDirtyMeshes(float maxTimeSeconds); // Budget: 0.005s per frame\r\n};\r\n```\r\n\r\nImplement deferred rebuild in Chunk.cpp:\r\n```cpp\r\nvoid Chunk::MarkMeshDirty() {\r\n    if (!m_needsMeshRebuild) {\r\n        m_needsMeshRebuild = true;\r\n        m_world->AddToDirtyMeshQueue(this);\r\n    }\r\n}\r\n```\r\n\r\nImplement ProcessDirtyMeshes in World.cpp:\r\n```cpp\r\nvoid World::ProcessDirtyMeshes(float maxTimeSeconds) {\r\n    Timer timer;\r\n    while (!m_dirtyMeshQueue.empty() && timer.GetElapsedSeconds() < maxTimeSeconds) {\r\n        Chunk* chunk = m_dirtyMeshQueue.front();\r\n        m_dirtyMeshQueue.pop_front();\r\n\r\n        // Rebuild into INACTIVE buffer\r\n        VertexBuffer* inactiveVBO = (chunk->m_currentRenderVBO == chunk->m_meshVBO_A) ?\r\n                                     chunk->m_meshVBO_B : chunk->m_meshVBO_A;\r\n        chunk->RebuildMeshInto(inactiveVBO);\r\n\r\n        // Atomic swap (single pointer assignment)\r\n        chunk->m_currentRenderVBO = inactiveVBO;\r\n        chunk->m_needsMeshRebuild = false;\r\n    }\r\n}\r\n\r\nvoid Chunk::Render() {\r\n    if (m_currentRenderVBO) {\r\n        g_renderer->DrawVertexBuffer(m_currentRenderVBO); // Always use stable buffer\r\n    }\r\n}\r\n```\r\n\r\nCall ProcessDirtyMeshes() from World::Update():\r\n```cpp\r\nvoid World::Update(float deltaSeconds) {\r\n    ProcessDirtyLighting(0.008f); // 8ms budget from Task 4\r\n    ProcessDirtyMeshes(0.005f);   // 5ms budget for mesh rebuilds\r\n}\r\n```\r\n\r\n**Verification:**\r\n- [ ] Dig blocks rapidly in multiple chunks\r\n- [ ] Verify NO visible flashing or jittering\r\n- [ ] Verify smooth mesh transitions\r\n- [ ] Activate new chunks by walking\r\n- [ ] Verify NO flashing during chunk activation\r\n- [ ] Measure frame time: should stay below 16.67ms (60 FPS)\r\n- [ ] Verify both vertex buffers allocated correctly (debug inspection)\r\n- [ ] Test edge case: Dig same chunk's blocks rapidly, verify queue handles repeated marks\r\n\r\n**Notes:** Double buffering ensures GPU never renders a buffer that's being modified. Deferred queue spreads mesh rebuild cost across multiple frames. Combined budget: 8ms lighting + 5ms meshes = 13ms total (leaves 3.7ms for other systems at 60 FPS).\r\n\r\n_Requirements: 18 (Additional Requirement)_\r\n\r\n_Dependencies: Task 7 (Mesh Building with Vertex Lighting)_\r\n\r\n_Prompt: Role: Graphics Programmer specializing in DirectX 11 rendering and performance optimization | Task: Implement double buffering + deferred mesh rebuild following Requirement 18, adding m_meshVBO_A/B and m_currentRenderVBO to Chunk, creating m_dirtyMeshQueue in World with ProcessDirtyMeshes(0.005s budget), rebuilding into inactive buffer then atomic swap, calling from World::Update() after ProcessDirtyLighting() | Restrictions: Must use double buffering (2 VBOs per chunk), rebuild into inactive buffer only, atomic pointer swap, respect 5ms time budget, process FIFO queue order | Success: NO flashing when digging/placing blocks, NO jittering during chunk activation, frame time <16.67ms (60 FPS), both VBOs allocated, smooth mesh transitions_\r\n\r\n---\r\n\r\n## Implementation Order\r\n\r\n**Critical Path (Sequential):**\r\n1. Task 1 (Block Expansion) → Task 2 (BlockIterator) → Task 3 (Lighting Init)\r\n2. Task 4 (Dirty Queue) + Task 5 (Propagation) → Task 6 (Chunk Activation)\r\n3. Task 7 (Mesh Vertex Lighting) → Task 8 (World Shader) → Task 9 (Day/Night)\r\n4. Task 11 (Dig/Place Update) depends on Tasks 4+5\r\n5. Task 13 (Mesh Flashing Fix) depends on Task 7\r\n\r\n**Parallel Opportunities:**\r\n- Task 10 (Raycast) can be implemented anytime (no dependencies)\r\n- Task 12 (Tree Variation) can be implemented anytime (no dependencies)\r\n- Task 3 (Lighting Init) parallel with Task 2 (BlockIterator) if careful\r\n- Tasks 7-9 (rendering) parallel with Tasks 4-6 (propagation) after Task 1 completes\r\n\r\n**Recommended Execution:**\r\n1. **Phase 1** (Days 1-4): Tasks 1-3 (Data structures and initialization)\r\n2. **Phase 2** (Days 5-9): Tasks 4-6 (Lighting propagation system)\r\n3. **Phase 3** (Days 10-14): Tasks 7-9 (Visual rendering and shaders)\r\n4. **Phase 4** (Days 15-17): Tasks 10-11 (Interaction systems)\r\n5. **Phase 5** (Days 18-20): Tasks 12-13 (Additional requirements and polish)\r\n\r\n---\r\n\r\n## Testing Strategy\r\n\r\n**Unit Testing:**\r\n- Task 1: sizeof(Block), light accessors, POD compliance\r\n- Task 2: Cross-chunk navigation at boundaries\r\n- Task 5: Light propagation math (15→14→13→...→0)\r\n\r\n**Integration Testing:**\r\n- Tasks 4+5+6: Full lighting propagation across chunks\r\n- Tasks 7+8: Vertex lighting renders correctly\r\n- Task 11: Dig/place triggers lighting update\r\n\r\n**Performance Testing:**\r\n- Task 4: ProcessDirtyLighting respects 8ms budget\r\n- Task 10: Raycast <0.1ms per call\r\n- Task 13: ProcessDirtyMeshes respects 5ms budget, no flashing\r\n\r\n**Visual Testing:**\r\n- Task 9: Day/night cycle visible over 4 minutes\r\n- Task 12: Tree variation visible (not identical trees)\r\n- All tasks: 60 FPS sustained, no visual glitches\r\n\r\n---\r\n\r\n## Success Criteria\r\n\r\n**Functional:**\r\n- [ ] Block structure expanded to 3 bytes\r\n- [ ] Dual-channel lighting (outdoor/indoor) propagates correctly\r\n- [ ] Day/night cycle affects outdoor light only\r\n- [ ] Chunk activation propagates cross-chunk lighting\r\n- [ ] Dig/place updates lighting dynamically\r\n- [ ] Tree height/radius varies per Perlin noise\r\n- [ ] No mesh flashing during dig/place/activation\r\n\r\n**Performance:**\r\n- [ ] 60 FPS sustained (16.67ms/frame)\r\n- [ ] Lighting budget <8ms/frame\r\n- [ ] Mesh rebuild budget <5ms/frame\r\n- [ ] Cross-chunk propagation <100ms latency\r\n- [ ] Raycast <0.1ms per call\r\n\r\n**Quality:**\r\n- [ ] No DirectX 11 resource leaks\r\n- [ ] No crashes during chunk activation\r\n- [ ] Save files work correctly (3-byte Block)\r\n- [ ] Visual quality matches requirements\r\n- [ ] Code follows SimpleMiner conventions\r\n\r\n---\r\n\r\n**Total Tasks:** 13\r\n**Estimated Time:** 18-22 days (per requirements timeline)\r\n**Last Updated:** 2025-11-15\r\n",
  "fileStats": {
    "size": 43895,
    "lines": 939,
    "lastModified": "2025-11-15T22:34:26.474Z"
  },
  "comments": []
}