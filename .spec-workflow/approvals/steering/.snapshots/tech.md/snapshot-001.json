{
  "id": "snapshot_1764279122675_qfp1w644t",
  "approvalId": "approval_1764012950776_silmz1ss1",
  "approvalTitle": "Review Steering Document: tech.md",
  "version": 1,
  "timestamp": "2025-11-27T21:32:02.675Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Assignment 7: Technology Stack\r\n\r\n## Project Type\r\n\r\nSimpleMiner is a **3D voxel game engine** built as a desktop application using DirectX 11 for rendering. It combines custom game engine architecture with Minecraft-inspired gameplay mechanics and AI agent integration for autonomous gameplay research.\r\n\r\n**Assignment 7 Focus:** Adding gameplay layer (inventory, crafting, mining) and AI integration layer (KADI WebSocket, MCP tools) on top of existing world generation and physics systems.\r\n\r\n## Core Technologies\r\n\r\n### Primary Language(s)\r\n- **Language**: C++20\r\n- **Compiler**: MSVC (Visual Studio 2022)\r\n- **Compiler Flags**: `/std:c++20`, `/W3`, `/permissive-`\r\n- **Platform**: Windows x64 only (DirectX 11 dependency)\r\n\r\n### Key Dependencies/Libraries\r\n\r\n#### Engine Systems (Existing)\r\n- **DirectX 11**: GPU rendering, vertex/index buffers, shaders, textures\r\n- **FMOD Studio API**: Professional audio middleware (`fmod.lib`, `fmodstudio.lib`)\r\n- **Winsock2**: TCP/UDP networking, WebSocket client (`ws2_32.lib`)\r\n- **nlohmann/json**: Header-only JSON parsing (`Engine\\Code\\ThirdParty\\json\\json.hpp`)\r\n- **V8 JavaScript Engine**: Embedded scripting (currently unused in A7)\r\n\r\n#### Third-Party Integration (Assignment 7)\r\n- **KADI Broker**: WebSocket message broker for AI-game communication\r\n- **Agent_TypeScript**: TypeScript agent framework (deployed on DigitalOcean)\r\n- **Claude Desktop/Code**: AI assistant with MCP tool discovery and invocation\r\n\r\n#### Assignment 7 New Systems\r\n- **Widget Subsystem**: DirectX 11-based UI rendering (alpha quality, needs refinement)\r\n- **KADI WebSocket Subsystem**: Game-to-AI integration protocol\r\n- **JSON Registry System**: Data-driven block/item/recipe definitions\r\n\r\n### Application Architecture\r\n\r\n**Multi-Threaded Chunk-Based World Engine:**\r\n- **Main Thread**: Game loop, rendering, input, UI, AI agent update\r\n- **Worker Threads**: (N-1) threads for async chunk generation/loading/saving\r\n  - 1 dedicated I/O thread for disk operations\r\n  - (N-2) generic threads for computation-heavy terrain generation\r\n- **Job System**: Thread-safe queue with LoadChunkJob, SaveChunkJob, ChunkGenerateJob\r\n\r\n**Entity-Component System:**\r\n- **Entity Base Class**: Physics-enabled objects (Player, AIAgent, ItemEntity)\r\n- **Component Pattern**: Physics, rendering, inventory, AI command queue\r\n- **World Manager**: Chunk activation/deactivation, entity lifecycle, lighting propagation\r\n\r\n**Registry Pattern (Assignment 7):**\r\n- **Generic Registry<T>**: Type-safe ID management for any type\r\n- **BlockRegistry**: Replaces static `s_definitions` vector, JSON-based\r\n- **ItemRegistry**: New system for tools, resources, placeable items\r\n- **RecipeRegistry**: Crafting recipe management with pattern matching\r\n\r\n### Data Storage\r\n\r\n#### Primary Storage\r\n- **World Data**: RLE-compressed chunk files in `Run/Saves/<worldName>/`\r\n- **Game Configuration**: XML (legacy) and JSON (A7) in `Run/Data/Definitions/`\r\n- **Player State**: JSON serialization in `Run/Saves/<worldName>/player.json`\r\n\r\n#### File Formats\r\n- **Chunks**: Custom binary format with RLE compression (`.chunk` files)\r\n- **Definitions**: JSON for blocks, items, recipes (`BlockDefinitions.json`, etc.)\r\n- **Shaders**: HLSL compiled bytecode (`.cso` files)\r\n- **Audio**: WAV, MP3, OGG via FMOD\r\n- **Textures**: PNG, JPG, TGA via DirectX 11\r\n\r\n#### Caching\r\n- **In-Memory Chunk Cache**: Active chunks kept in memory with dirty flags\r\n- **Texture Cache**: Loaded textures persist until app shutdown\r\n- **Sound Cache**: FMOD manages audio asset loading/unloading\r\n- **UI Sprite Cache**: Widget textures cached per WidgetSubsystem instance\r\n\r\n### External Integrations\r\n\r\n#### KADI Broker Integration (Assignment 7)\r\n- **Protocol**: WebSocket (RFC 6455) with KADI protocol v1\r\n- **Authentication**: Public/private key pairs (RSA-based)\r\n- **Message Format**: JSON-RPC 2.0 for tool invocation\r\n- **Connection States**: 7-state flow (DISCONNECTED → READY)\r\n- **Heartbeat**: Ping/pong every 30 seconds, 90-second timeout\r\n\r\n#### MCP Tool Registration (Assignment 7)\r\nSimpleMiner exposes these tools to Claude Desktop/Code:\r\n1. `SimpleMiner_Spawn_Agent(name, x, y, z)` → agentID\r\n2. `SimpleMiner_Move_Agent(agentID, dirX, dirY, dirZ, duration)`\r\n3. `SimpleMiner_Mine_Block(agentID, x, y, z)`\r\n4. `SimpleMiner_Place_Block(agentID, blockType, x, y, z)`\r\n5. `SimpleMiner_Get_Agent_Vision(agentID)` → {blocks, entities}\r\n6. `SimpleMiner_Get_Agent_Inventory(agentID)` → {itemStacks}\r\n7. `SimpleMiner_Craft_Item(agentID, recipeID)`\r\n\r\n#### Claude Agent Communication Flow\r\n```\r\nClaude Desktop → KADI Broker (WebSocket) → SimpleMiner (KADIWebSocketSubsystem)\r\n                                          ↓\r\n                                    Tool Handler (Game Logic)\r\n                                          ↓\r\n                                    AIAgent Entity (Command Queue)\r\n                                          ↓\r\n                                    World Update (Block Manipulation)\r\n                                          ↓\r\n                                    Tool Result (Success/Failure)\r\n                                          ↓\r\nKADI Broker ← SimpleMiner ← Tool Response JSON\r\n     ↓\r\nClaude Desktop (Result Display)\r\n```\r\n\r\n## Development Environment\r\n\r\n### Build & Development Tools\r\n- **Build System**: Visual Studio 2022 solution (.sln) with MSBuild\r\n- **Project Structure**: SimpleMiner.vcxproj + Engine.vcxproj (submodule)\r\n- **Configurations**: Debug|x64, Release|x64, DebugInline|x64, FastBreak|x64\r\n- **Output**: Executables copied to `Run/` directory post-build\r\n- **Hot Reload**: Not supported (C++ requires full rebuild and restart)\r\n\r\n### Code Quality Tools\r\n- **Static Analysis**: Visual Studio Code Analysis (/analyze flag, disabled by default)\r\n- **Formatting**: Manual (no automated formatter configured)\r\n- **Testing Framework**: Manual testing, no unit test framework\r\n- **Documentation**: CLAUDE.md files per module, inline comments for complex logic\r\n- **Memory Leak Detection**: Visual Studio CRT debug heap (Debug builds only)\r\n\r\n### Version Control & Collaboration\r\n- **VCS**: Git with GitHub remote\r\n- **Submodules**: Engine as git submodule (`git submodule update --init --recursive`)\r\n- **Branching Strategy**: Main branch for assignments, feature branches for experiments\r\n- **Code Review**: User reviews AI-generated code via Claude Code approval system\r\n- **.gitignore**: Excludes `.vs/`, `x64/`, `Debug/`, `Release/`, `*.user` files\r\n\r\n### Assignment 7 Development Workflow\r\n1. **Prerequisites**: Update CLAUDE.md documentation, create steering docs\r\n2. **Steering Approval**: User reviews product.md, tech.md, structure.md via dashboard\r\n3. **Design Phase**: Create design.md with architecture diagrams and rendering bug fix (P-1)\r\n4. **Implementation**: Task-by-task execution with spec-workflow logging\r\n5. **Testing**: MVP demo scenario validation (11 features)\r\n6. **Archive**: Move A7 spec to `.spec-workflow/archive/specs/A7/`\r\n\r\n## Deployment & Distribution\r\n\r\n### Target Platform(s)\r\n- **Primary**: Windows 10/11 x64 (DirectX 11 hardware required)\r\n- **No Support**: Linux, macOS, mobile, web, consoles\r\n\r\n### Distribution Method\r\n- **Academic Submission**: Zip file or GitHub repository link\r\n- **No Public Release**: Assignment project, not intended for distribution\r\n\r\n### Installation Requirements\r\n- **Windows SDK**: For DirectX 11 headers and libraries\r\n- **Visual Studio 2022**: C++ development tools\r\n- **Git**: For submodule initialization\r\n- **KADI Broker**: Separate process (optional for non-AI testing)\r\n\r\n### Update Mechanism\r\n- **Manual**: User pulls latest code from repository\r\n- **No Auto-Update**: Desktop application with manual rebuild required\r\n\r\n## Technical Requirements & Constraints\r\n\r\n### Performance Requirements (Assignment 7)\r\n- **Target FPS**: 60 FPS sustained with inventory UI open and 3-10 AI agents\r\n- **UI Rendering**: < 2ms per frame for all widgets (HUD, inventory, crafting)\r\n- **Agent Update**: < 0.5ms per agent per frame (command processing + vision)\r\n- **JSON Loading**: < 100ms for all registries at startup\r\n- **Chunk Generation**: Background threads, non-blocking on main thread\r\n- **Memory Limit**: < 2GB RAM for typical gameplay session\r\n\r\n### Compatibility Requirements\r\n- **OS**: Windows 10 (1809+) or Windows 11\r\n- **GPU**: DirectX 11.0 compatible (Intel HD 4000+ minimum)\r\n- **CPU**: Multi-core recommended for worker threads (2+ cores)\r\n- **RAM**: 4GB minimum, 8GB recommended\r\n- **Disk**: 500MB for executable + assets + world saves\r\n\r\n### Security & Compliance\r\n- **KADI Authentication**: Public/private key pairs, no plaintext passwords\r\n- **No PII Collection**: Single-player game, no telemetry or user data transmission\r\n- **Local Saves**: All data stored locally in `Run/Saves/` directory\r\n- **WebSocket Security**: localhost connections only (no remote KADI brokers for A7)\r\n\r\n### Scalability & Reliability\r\n- **Expected Load**: Single player + 3-10 AI agents\r\n- **World Size**: Theoretically infinite X/Y, finite Z (0-128 blocks)\r\n- **Active Chunks**: ~81 chunks (9×9 around player) with async loading\r\n- **Agent Concurrency**: Up to 10 agents supported, 3 for MVP\r\n- **No Multiplayer**: Single-threaded game logic (no server architecture)\r\n\r\n## Technical Decisions & Rationale\r\n\r\n### Decision Log\r\n\r\n#### 1. **JSON Over XML for Registries (Assignment 7)**\r\n**Decision:** Migrate BlockDefinitions from XML to JSON, use JSON for all A7 data files.\r\n**Rationale:**\r\n- User explicitly requested JSON (3 comments)\r\n- Engine already has `nlohmann/json` library\r\n- Consistency with KADI protocol (JSON-RPC)\r\n- Modern C++ STL-like API easier to use than XML parsing\r\n**Alternatives Considered:**\r\n- Keep XML (rejected: inconsistent with A7 direction)\r\n- Use binary formats (rejected: not human-readable for debugging)\r\n\r\n#### 2. **KADI WebSocket Over Direct API for AI Integration**\r\n**Decision:** All AI agent control routes through KADIWebSocketSubsystem with MCP tool registration.\r\n**Rationale:**\r\n- Establishes standard protocol for AI-game integration\r\n- User has existing KADI infrastructure (Agent_TypeScript on DigitalOcean)\r\n- Enables Claude Desktop/Code integration via MCP\r\n- Decouples AI logic from game engine (agents run externally)\r\n**Alternatives Considered:**\r\n- Direct function calls (rejected: tight coupling, no remote agents)\r\n- Custom TCP protocol (rejected: reinventing WebSocket)\r\n\r\n#### 3. **Use Existing WidgetSubsystem Despite \"Very Rough\" Status**\r\n**Decision:** Build A7 UI using existing WidgetSubsystem, refine only blocking features.\r\n**Rationale:**\r\n- Time constraint (due 12/12) prevents UI framework rewrite\r\n- Core lifecycle (z-order, owner grouping) functional\r\n- User acknowledged system needs work but wants to use it\r\n- Defer comprehensive redesign to post-A7\r\n**Alternatives Considered:**\r\n- Full WidgetSubsystem redesign (rejected: scope too large for deadline)\r\n- Immediate mode GUI (ImGui for game UI, rejected: not Minecraft-authentic)\r\n\r\n#### 4. **Command Queue Over Goal-Based AI (Assignment 7)**\r\n**Decision:** Agents execute commands sequentially (MOVE, MINE, PLACE), not autonomous goal-based planning.\r\n**Rationale:**\r\n- KISS principle for MVP (simpler to implement and debug)\r\n- User explicitly stated \"command execution for now, goal-based for later\"\r\n- Allows testing AI-game integration without complex planning logic\r\n- Easier to validate behavior (predictable command sequences)\r\n**Alternatives Considered:**\r\n- GOAP (Goal-Oriented Action Planning, rejected: too complex for A7 scope)\r\n- Behavior trees (rejected: overkill for command execution)\r\n\r\n#### 5. **2×2 Crafting Grid Only (No 3×3 Yet)**\r\n**Decision:** Implement 2×2 inventory crafting, defer 3×3 workbench crafting to future.\r\n**Rationale:**\r\n- YAGNI principle (only 10 recipes required for MVP)\r\n- 2×2 sufficient for all MVP recipes (planks, sticks, tools, crafting table)\r\n- 3×3 requires additional UI work (workbench block, separate screen)\r\n**Alternatives Considered:**\r\n- Full 3×3 system (rejected: not required for A7 MVP, adds complexity)\r\n\r\n## Known Limitations\r\n\r\n### Technical Debt\r\n\r\n#### 1. **WidgetSubsystem Alpha Quality**\r\n**Limitation:** Missing modal dialog support, input event routing, layout system.\r\n**Impact:** Inventory screen requires custom mouse capture logic, no automatic positioning.\r\n**Future Solution:** Post-A7 comprehensive redesign with modal system, event bubbling, flex layouts.\r\n\r\n#### 2. **Single-Threaded Game Logic**\r\n**Limitation:** Main thread handles all gameplay (player, agents, inventory, crafting).\r\n**Impact:** 10+ agents may cause frame drops if command processing is heavy.\r\n**Future Solution:** Agent update on worker threads with thread-safe world queries.\r\n\r\n#### 3. **No Network Multiplayer**\r\n**Limitation:** World state not replicated, no client-server architecture.\r\n**Impact:** Cannot have multiple human players + AI agents simultaneously.\r\n**Future Solution:** Requires significant refactoring (authoritative server, state replication).\r\n\r\n#### 4. **KADI Broker External Dependency**\r\n**Limitation:** Requires separate KADI broker process for AI agent functionality.\r\n**Impact:** Cannot test AI features without running broker separately.\r\n**Future Solution:** Consider embedded broker mode or mock adapter for testing.\r\n\r\n#### 5. **Windows-Only DirectX 11**\r\n**Limitation:** No cross-platform support (no Vulkan/OpenGL backend).\r\n**Impact:** Cannot run on Linux/macOS.\r\n**Future Solution:** Abstract rendering backend (out of scope for academic project).\r\n\r\n### Performance Considerations\r\n\r\n#### Potential Bottlenecks\r\n1. **UI Rendering**: Every widget rendered every frame (no dirty flag optimization)\r\n2. **Agent Vision**: Each agent scans nearby blocks every 0.5s (can be expensive with 10 agents)\r\n3. **JSON Parsing**: Loading registries at startup blocks main thread\r\n4. **Chunk Mesh Rebuilding**: Frequent block changes (agent mining) triggers mesh regeneration\r\n\r\n#### Mitigation Strategies (Implemented or Planned)\r\n- **UI**: Z-order sorting only when widgets added/removed, not every frame\r\n- **Agent Vision**: Cached results, 0.5s refresh rate, spatial partitioning for queries\r\n- **JSON Loading**: One-time cost at startup, acceptable for < 100ms\r\n- **Chunk Mesh**: Dirty flag system, rebuild on next frame (not immediate)\r\n\r\n---\r\n\r\n**Document Version:** 1.0\r\n**Created:** 2025-11-24\r\n**Assignment:** A7 - Registry, Inventory, UI, AI Agents\r\n**Due Date:** December 12, 2025\r\n",
  "fileStats": {
    "size": 14510,
    "lines": 299,
    "lastModified": "2025-11-24T12:48:46.781Z"
  },
  "comments": []
}