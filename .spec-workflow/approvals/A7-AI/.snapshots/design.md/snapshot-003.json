{
  "id": "snapshot_1764390480734_vok80b20p",
  "approvalId": "approval_1764389755502_uhrnerkct",
  "approvalTitle": "A7-AI design.md - Agent Framework Architecture (REVISED v2.0)",
  "version": 3,
  "timestamp": "2025-11-29T04:28:00.734Z",
  "trigger": "revision_requested",
  "status": "pending",
  "content": "# Assignment 7-AI: Design Document\r\n# AI Agent Integration (KADI WebSocket, Agent Framework)\r\n\r\n**Version:** 2.0 (REVISED)\r\n**Date:** 2025-11-29\r\n**Status:** Design Phase - Revision 1\r\n**Dependencies:** âœ… Requires A7-Core completion (Registry, Inventory systems)\r\n\r\n---\r\n\r\n## Revision History\r\n\r\n**v2.0 (2025-11-29)** - Architecture revision based on ProtogameJS3D framework:\r\n- âœ… Renamed AIAgent â†’ Agent throughout entire document\r\n- âœ… Changed MCP tool naming: `SimpleMiner_Spawn_Agent` â†’ `simpleminer_spawn_agent` (lowercase_with_underscores)\r\n- âœ… Revised KADI integration to match Engine KADIWebSocketSubsystem API\r\n- âœ… Added 7-state connection flow (DISCONNECTED â†’ READY)\r\n- âœ… Updated agent architecture to follow broker-centralized pattern\r\n- âœ… Added Ed25519 authentication details\r\n- âœ… Aligned TypeScript agent examples with template-agent-typescript structure\r\n\r\n**v1.0 (2025-11-27)** - Initial design\r\n\r\n---\r\n\r\n## Executive Summary\r\n\r\nThis design document provides the technical architecture for A7-AI's implementation of AI agent framework and KADI WebSocket integration. The design covers:\r\n\r\n1. **Agent Entity Class** - Autonomous entity with inventory and command queue (extends Entity)\r\n2. **Agent Command System** - MOVE, MINE, PLACE, CRAFT, WAIT commands\r\n3. **Agent Vision System** - Query nearby blocks and entities\r\n4. **KADI WebSocket Integration** - 7 MCP tools using Engine's KADIWebSocketSubsystem\r\n5. **TypeScript Agent Framework** - Example agent behaviors (MinerAgent, BuilderAgent)\r\n\r\n**Design Philosophy:**\r\n- **Command Execution Only** - No goal-based AI (defer to future assignment)\r\n- **Reuse Player Logic** - Share mining/placement code with Player class\r\n- **Non-Blocking Network** - KADI communication doesn't freeze game\r\n- **Broker-Centralized Architecture** - No MCP spawning in SimpleMiner code\r\n- **MCP Tool Naming** - lowercase_with_underscores (e.g., `simpleminer_spawn_agent`)\r\n\r\n---\r\n\r\n## Table of Contents\r\n\r\n1. [System Architecture Overview](#1-system-architecture-overview)\r\n2. [Agent Class Design](#2-agent-class-design)\r\n3. [Agent Command System](#3-agent-command-system)\r\n4. [Agent Vision System](#4-agent-vision-system)\r\n5. [KADI WebSocket Integration](#5-kadi-websocket-integration)\r\n6. [TypeScript Agent Framework](#6-typescript-agent-framework)\r\n7. [Data Flow Diagrams](#7-data-flow-diagrams)\r\n8. [Implementation Strategy](#8-implementation-strategy)\r\n\r\n---\r\n\r\n## 1. System Architecture Overview\r\n\r\n### Component Architecture\r\n\r\n```\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚      TypeScript Agents (DigitalOcean)       â”‚\r\nâ”‚   MinerAgent.ts, BuilderAgent.ts            â”‚\r\nâ”‚   Uses @kadi.build/core (KadiClient)        â”‚\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\r\n                    â†“â†‘ WebSocket (KADI Protocol)\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚         KADI Broker (localhost:8080)        â”‚\r\nâ”‚   - Tool discovery & routing                â”‚\r\nâ”‚   - Ed25519 authentication                  â”‚\r\nâ”‚   - Network isolation (global, simpleminer) â”‚\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\r\n                    â†“â†‘ WebSocket\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚    KADIWebSocketSubsystem (Engine)          â”‚\r\nâ”‚   - RegisterTools() - 7 MCP tools           â”‚\r\nâ”‚   - SetToolInvokeCallback()                 â”‚\r\nâ”‚   - SendToolResult() / SendToolError()      â”‚\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\r\n                    â†“â†‘\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚         SimpleMiner Game Logic              â”‚\r\nâ”‚   Agent, AgentCommand, AgentVision          â”‚\r\nâ”‚   World::OnKADIToolInvoke()                 â”‚\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\r\n```\r\n\r\n### Entity Hierarchy\r\n\r\n```\r\nEntity (base class)\r\nâ”œâ”€â”€ Player\r\nâ”œâ”€â”€ ItemEntity\r\nâ””â”€â”€ Agent (new) - Autonomous AI-controlled entity\r\n```\r\n\r\n### KADI Connection States (7-State Flow)\r\n\r\nBased on Engine's KADIWebSocketSubsystem implementation:\r\n\r\n```\r\nDISCONNECTED â”€â”€Connect()â”€â”€â†’ CONNECTING\r\n                               â†“ (WebSocket open)\r\n                          CONNECTED\r\n                               â†“ (send hello)\r\n                        AUTHENTICATING\r\n                               â†“ (Ed25519 signature)\r\n                        AUTHENTICATED\r\n                               â†“ (RegisterTools())\r\n                     REGISTERING_TOOLS\r\n                               â†“ (tools registered)\r\n                            READY âœ…\r\n```\r\n\r\n**State Transitions:**\r\n- `DISCONNECTED`: Not connected to broker\r\n- `CONNECTING`: WebSocket connection in progress\r\n- `CONNECTED`: WebSocket open, not authenticated\r\n- `AUTHENTICATING`: Sending Ed25519 authentication\r\n- `AUTHENTICATED`: Authentication complete\r\n- `REGISTERING_TOOLS`: Sending tool registration\r\n- `READY`: Fully operational, can receive tool calls\r\n\r\n### Data Flow: Spawning Agent via KADI\r\n\r\n```\r\nClaude Desktop: \"Spawn a miner agent at (100, 100, 70)\"\r\n     â†“\r\nTypeScript Agent (MinerAgent.ts):\r\n  const simpleminer = await client.load('simpleminer', 'broker');\r\n  const result = await simpleminer.simpleminer_spawn_agent({\r\n    name: \"MinerBot\",\r\n    x: 100, y: 100, z: 70\r\n  });\r\n     â†“\r\nKADI Broker: Route to SimpleMiner (network: simpleminer)\r\n     â†“\r\nKADIWebSocketSubsystem: Receive JSON-RPC request\r\n     â†“\r\nGame::OnKADIToolInvoke(requestId, \"simpleminer_spawn_agent\", {...})\r\n     â†“\r\nWorld::SpawnAgent(\"MinerBot\", Vec3(100, 100, 70))\r\n     â†“\r\nAgent* agent = new Agent(\"MinerBot\", agentID, position);\r\n     â†“\r\ng_kadiWebSocket->SendToolResult(requestId, {{\"agent_id\", agentID}});\r\n     â†“\r\nTypeScript Agent receives result: { agent_id: 1234567890 }\r\n```\r\n\r\n---\r\n\r\n## 2. Agent Class Design\r\n\r\n### Class Definition\r\n\r\n**File:** `Code/Game/Gameplay/Agent.hpp`\r\n\r\n```cpp\r\n#pragma once\r\n#include \"Entity.hpp\"\r\n#include \"Game/Framework/Inventory.hpp\"\r\n#include \"Game/Framework/AgentCommand.hpp\"\r\n#include <string>\r\n#include <queue>\r\n#include <vector>\r\n\r\n//-----------------------------------------------------------------------------------------------\r\n// Agent - AI-controlled entity with inventory and command queue\r\n//\r\n// Extends Entity to provide:\r\n// - 36-slot inventory (same as Player)\r\n// - Command queue for autonomous actions (MOVE, MINE, PLACE, CRAFT, WAIT)\r\n// - Vision system for querying nearby blocks\r\n// - Command execution state machine\r\n//\r\n// Design Notes:\r\n// - Shares mining/placement logic with Player (via World methods)\r\n// - No goal-based AI (commands come from TypeScript agents via KADI)\r\n// - Command queue processed one command per Update() call\r\n// - Non-blocking: Failed commands are removed, agent continues\r\n//\r\nclass Agent : public Entity\r\n{\r\npublic:\r\n    // Constructor\r\n    Agent(std::string const& name, uint64_t agentID, Vec3 const& position);\r\n    virtual ~Agent();\r\n\r\n    // Entity Interface\r\n    virtual void Update(float deltaSeconds) override;\r\n    virtual void Render() const override;\r\n    virtual EntityType GetEntityType() const override { return EntityType::AGENT; }\r\n\r\n    // Agent Identity\r\n    std::string const& GetName() const { return m_agentName; }\r\n    uint64_t GetAgentID() const { return m_agentID; }\r\n\r\n    // Command Queue\r\n    void QueueCommand(AgentCommand* command);\r\n    bool HasPendingCommands() const { return !m_commandQueue.empty(); }\r\n    int GetCommandQueueSize() const { return static_cast<int>(m_commandQueue.size()); }\r\n    void ClearCommandQueue(); // For emergency stops\r\n\r\n    // Inventory Access\r\n    Inventory& GetInventory() { return m_inventory; }\r\n    Inventory const& GetInventory() const { return m_inventory; }\r\n\r\n    // Vision System\r\n    struct BlockInfo {\r\n        IntVec3 blockCoords;  // World coordinates\r\n        uint16_t blockID;     // BlockRegistry ID\r\n        std::string blockName; // Human-readable name (e.g., \"Stone\", \"Oak_Log\")\r\n    };\r\n\r\n    std::vector<BlockInfo> GetNearbyBlocks(float radius) const;\r\n    std::vector<Entity*> GetNearbyEntities(float radius) const;\r\n\r\n    // Command Execution State\r\n    bool IsExecutingCommand() const { return m_currentCommand != nullptr; }\r\n    std::string GetCurrentCommandType() const;\r\n\r\nprivate:\r\n    // Agent Identity\r\n    std::string m_agentName;          // Unique name (e.g., \"MinerBot\")\r\n    uint64_t m_agentID;               // Unique ID from KADI\r\n\r\n    // Inventory\r\n    Inventory m_inventory;            // 36 slots (matches Player)\r\n\r\n    // Command System\r\n    std::queue<AgentCommand*> m_commandQueue;\r\n    AgentCommand* m_currentCommand = nullptr;\r\n\r\n    // Command Execution\r\n    void ProcessCommandQueue(float deltaSeconds);\r\n    void ExecuteCurrentCommand(float deltaSeconds);\r\n    void CompleteCurrentCommand();\r\n};\r\n```\r\n\r\n### Implementation Details\r\n\r\n**File:** `Code/Game/Gameplay/Agent.cpp`\r\n\r\n**Key Methods:**\r\n\r\n#### Constructor\r\n```cpp\r\nAgent::Agent(std::string const& name, uint64_t agentID, Vec3 const& position)\r\n    : Entity(position)\r\n    , m_agentName(name)\r\n    , m_agentID(agentID)\r\n    , m_inventory(36) // 36 slots, matches Player\r\n{\r\n    // Agent rendering: Green wireframe cube (2x2x2 blocks tall)\r\n    // (Reuse Entity rendering system)\r\n}\r\n```\r\n\r\n#### Update()\r\n```cpp\r\nvoid Agent::Update(float deltaSeconds)\r\n{\r\n    Entity::Update(deltaSeconds);  // Physics, collision, etc.\r\n    ProcessCommandQueue(deltaSeconds);\r\n}\r\n\r\nvoid Agent::ProcessCommandQueue(float deltaSeconds)\r\n{\r\n    // If no current command, dequeue next command\r\n    if (m_currentCommand == nullptr && !m_commandQueue.empty()) {\r\n        m_currentCommand = m_commandQueue.front();\r\n        m_commandQueue.pop();\r\n        m_currentCommand->Start(); // Initialize command state\r\n    }\r\n\r\n    // Execute current command\r\n    if (m_currentCommand != nullptr) {\r\n        ExecuteCurrentCommand(deltaSeconds);\r\n    }\r\n}\r\n\r\nvoid Agent::ExecuteCurrentCommand(float deltaSeconds)\r\n{\r\n    eCommandStatus status = m_currentCommand->Execute(deltaSeconds, this);\r\n\r\n    if (status == eCommandStatus::COMPLETED) {\r\n        CompleteCurrentCommand();\r\n    } else if (status == eCommandStatus::FAILED) {\r\n        // Log failure and move to next command\r\n        g_theConsole->PrintString(Rgba8::RED, Stringf(\"Agent '%s': Command failed: %s\",\r\n            m_agentName.c_str(), m_currentCommand->GetFailureReason().c_str()));\r\n        CompleteCurrentCommand();\r\n    }\r\n    // Status IN_PROGRESS: Continue executing next frame\r\n}\r\n\r\nvoid Agent::CompleteCurrentCommand()\r\n{\r\n    delete m_currentCommand;\r\n    m_currentCommand = nullptr;\r\n}\r\n```\r\n\r\n#### Vision System\r\n```cpp\r\nstd::vector<Agent::BlockInfo> Agent::GetNearbyBlocks(float radius) const\r\n{\r\n    std::vector<BlockInfo> blocks;\r\n\r\n    // Query all blocks within radius\r\n    int radiusBlocks = static_cast<int>(radius) + 1;\r\n    IntVec3 centerCoords = IntVec3(m_position);\r\n\r\n    for (int x = -radiusBlocks; x <= radiusBlocks; ++x) {\r\n        for (int y = -radiusBlocks; y <= radiusBlocks; ++y) {\r\n            for (int z = -radiusBlocks; z <= radiusBlocks; ++z) {\r\n                IntVec3 coords = centerCoords + IntVec3(x, y, z);\r\n\r\n                // Check distance\r\n                Vec3 blockCenter = Vec3(coords) + Vec3(0.5f, 0.5f, 0.5f);\r\n                float dist = GetDistance3D(m_position, blockCenter);\r\n                if (dist > radius) continue;\r\n\r\n                // Get block from World\r\n                Block block = m_world->GetBlock(coords);\r\n                if (block.IsAir()) continue;\r\n\r\n                BlockInfo info;\r\n                info.blockCoords = coords;\r\n                info.blockID = block.GetBlockID();\r\n                info.blockName = g_blockRegistry->GetBlockName(block.GetBlockID());\r\n                blocks.push_back(info);\r\n            }\r\n        }\r\n    }\r\n\r\n    return blocks;\r\n}\r\n\r\nstd::vector<Entity*> Agent::GetNearbyEntities(float radius) const\r\n{\r\n    std::vector<Entity*> entities;\r\n\r\n    for (Entity* entity : m_world->GetAllEntities()) {\r\n        if (entity == this) continue; // Skip self\r\n\r\n        float dist = GetDistance3D(m_position, entity->GetPosition());\r\n        if (dist <= radius) {\r\n            entities.push_back(entity);\r\n        }\r\n    }\r\n\r\n    return entities;\r\n}\r\n```\r\n\r\n---\r\n\r\n## 3. Agent Command System\r\n\r\n### Command Base Class\r\n\r\n**File:** `Code/Game/Framework/AgentCommand.hpp`\r\n\r\n```cpp\r\n#pragma once\r\n#include \"Engine/Core/Vec3.hpp\"\r\n#include <string>\r\n\r\n// Forward declarations\r\nclass Agent;\r\nclass World;\r\n\r\n//-----------------------------------------------------------------------------------------------\r\n// Command Status\r\nenum class eCommandStatus : uint8_t\r\n{\r\n    NOT_STARTED,  // Command not started yet\r\n    IN_PROGRESS,  // Command actively executing\r\n    COMPLETED,    // Command successfully finished\r\n    FAILED        // Command failed (invalid target, unreachable, etc.)\r\n};\r\n\r\n//-----------------------------------------------------------------------------------------------\r\n// AgentCommand - Abstract base class for agent actions\r\n//\r\n// All commands implement:\r\n// - Start() - Initialize command state\r\n// - Execute() - Perform one frame of work, return status\r\n// - GetType() - Return command type as string\r\n// - GetFailureReason() - Return reason if status == FAILED\r\n//\r\nclass AgentCommand\r\n{\r\npublic:\r\n    virtual ~AgentCommand() = default;\r\n\r\n    // Command lifecycle\r\n    virtual void Start() = 0;\r\n    virtual eCommandStatus Execute(float deltaSeconds, Agent* agent) = 0;\r\n\r\n    // Command metadata\r\n    virtual std::string GetType() const = 0;\r\n    std::string GetFailureReason() const { return m_failureReason; }\r\n\r\nprotected:\r\n    eCommandStatus m_status = eCommandStatus::NOT_STARTED;\r\n    std::string m_failureReason;\r\n};\r\n```\r\n\r\n### Command Implementations\r\n\r\n#### 1. MoveCommand\r\n\r\n```cpp\r\nclass MoveCommand : public AgentCommand\r\n{\r\npublic:\r\n    MoveCommand(Vec3 const& targetPosition, float moveSpeed = 4.0f);\r\n\r\n    virtual void Start() override;\r\n    virtual eCommandStatus Execute(float deltaSeconds, Agent* agent) override;\r\n    virtual std::string GetType() const override { return \"MOVE\"; }\r\n\r\nprivate:\r\n    Vec3 m_targetPosition;\r\n    float m_moveSpeed; // Blocks per second (Player uses 4.0f)\r\n\r\n    static constexpr float ARRIVAL_THRESHOLD = 0.5f; // Within 0.5 blocks\r\n};\r\n\r\n// Implementation\r\neCommandStatus MoveCommand::Execute(float deltaSeconds, Agent* agent)\r\n{\r\n    Vec3 currentPos = agent->GetPosition();\r\n    Vec3 toTarget = m_targetPosition - currentPos;\r\n    float distanceRemaining = toTarget.GetLength();\r\n\r\n    // Check arrival\r\n    if (distanceRemaining < ARRIVAL_THRESHOLD) {\r\n        return eCommandStatus::COMPLETED;\r\n    }\r\n\r\n    // Move towards target\r\n    Vec3 moveDirection = toTarget.GetNormalized();\r\n    float moveDistance = m_moveSpeed * deltaSeconds;\r\n\r\n    if (moveDistance > distanceRemaining) {\r\n        moveDistance = distanceRemaining; // Don't overshoot\r\n    }\r\n\r\n    Vec3 newPos = currentPos + (moveDirection * moveDistance);\r\n    agent->SetPosition(newPos);\r\n\r\n    // Check collision (reuse Player physics)\r\n    if (agent->IsCollidingWithWorld()) {\r\n        m_failureReason = \"Collision with terrain\";\r\n        return eCommandStatus::FAILED;\r\n    }\r\n\r\n    return eCommandStatus::IN_PROGRESS;\r\n}\r\n```\r\n\r\n#### 2. MineCommand\r\n\r\n```cpp\r\nclass MineCommand : public AgentCommand\r\n{\r\npublic:\r\n    MineCommand(IntVec3 const& blockCoords);\r\n\r\n    virtual void Start() override;\r\n    virtual eCommandStatus Execute(float deltaSeconds, Agent* agent) override;\r\n    virtual std::string GetType() const override { return \"MINE\"; }\r\n\r\nprivate:\r\n    IntVec3 m_blockCoords;\r\n    float m_miningProgress = 0.0f;  // 0.0 to 1.0\r\n    float m_miningDuration = 0.0f;  // Seconds (from block definition)\r\n\r\n    static constexpr float MAX_MINING_DISTANCE = 5.0f; // Same as Player\r\n};\r\n\r\n// Implementation\r\nvoid MineCommand::Start()\r\n{\r\n    m_status = eCommandStatus::IN_PROGRESS;\r\n    m_miningProgress = 0.0f;\r\n}\r\n\r\neCommandStatus MineCommand::Execute(float deltaSeconds, Agent* agent)\r\n{\r\n    // Check distance\r\n    Vec3 blockCenter = Vec3(m_blockCoords) + Vec3(0.5f, 0.5f, 0.5f);\r\n    float distance = GetDistance3D(agent->GetPosition(), blockCenter);\r\n    if (distance > MAX_MINING_DISTANCE) {\r\n        m_failureReason = \"Block out of range\";\r\n        return eCommandStatus::FAILED;\r\n    }\r\n\r\n    // Get block\r\n    World* world = agent->GetWorld();\r\n    Block block = world->GetBlock(m_blockCoords);\r\n    if (block.IsAir()) {\r\n        m_failureReason = \"Block already mined\";\r\n        return eCommandStatus::COMPLETED; // Treat as success\r\n    }\r\n\r\n    // Calculate mining duration (if not calculated yet)\r\n    if (m_miningDuration == 0.0f) {\r\n        BlockDefinition const& blockDef = g_blockRegistry->GetBlockDefinition(block.GetBlockID());\r\n        m_miningDuration = blockDef.GetMiningDuration();\r\n    }\r\n\r\n    // Update progress\r\n    m_miningProgress += deltaSeconds / m_miningDuration;\r\n\r\n    if (m_miningProgress >= 1.0f) {\r\n        // Break block and spawn ItemEntity\r\n        world->BreakBlock(m_blockCoords, agent->GetPosition());\r\n        return eCommandStatus::COMPLETED;\r\n    }\r\n\r\n    return eCommandStatus::IN_PROGRESS;\r\n}\r\n```\r\n\r\n#### 3. PlaceCommand\r\n\r\n```cpp\r\nclass PlaceCommand : public AgentCommand\r\n{\r\npublic:\r\n    PlaceCommand(IntVec3 const& blockCoords, uint16_t itemID);\r\n\r\n    virtual void Start() override;\r\n    virtual eCommandStatus Execute(float deltaSeconds, Agent* agent) override;\r\n    virtual std::string GetType() const override { return \"PLACE\"; }\r\n\r\nprivate:\r\n    IntVec3 m_blockCoords;\r\n    uint16_t m_itemID; // ItemRegistry ID (must be a block item)\r\n\r\n    static constexpr float MAX_PLACEMENT_DISTANCE = 5.0f;\r\n};\r\n\r\n// Implementation\r\neCommandStatus PlaceCommand::Execute(float deltaSeconds, Agent* agent)\r\n{\r\n    UNUSED(deltaSeconds);\r\n\r\n    // Check distance\r\n    Vec3 blockCenter = Vec3(m_blockCoords) + Vec3(0.5f, 0.5f, 0.5f);\r\n    float distance = GetDistance3D(agent->GetPosition(), blockCenter);\r\n    if (distance > MAX_PLACEMENT_DISTANCE) {\r\n        m_failureReason = \"Block position out of range\";\r\n        return eCommandStatus::FAILED;\r\n    }\r\n\r\n    // Check agent has the item\r\n    Inventory& inv = agent->GetInventory();\r\n    int slotIndex = inv.FindItemSlot(m_itemID);\r\n    if (slotIndex == -1) {\r\n        m_failureReason = \"Item not in inventory\";\r\n        return eCommandStatus::FAILED;\r\n    }\r\n\r\n    // Get corresponding block ID from ItemRegistry\r\n    ItemDefinition const& itemDef = g_itemRegistry->GetItemDefinition(m_itemID);\r\n    if (itemDef.GetBlockID() == 0) {\r\n        m_failureReason = \"Item is not a placeable block\";\r\n        return eCommandStatus::FAILED;\r\n    }\r\n\r\n    // Attempt placement (reuse Player placement logic)\r\n    World* world = agent->GetWorld();\r\n    bool placed = world->PlaceBlock(m_blockCoords, itemDef.GetBlockID());\r\n\r\n    if (placed) {\r\n        // Remove item from inventory\r\n        inv.RemoveItemFromSlot(slotIndex, 1);\r\n        return eCommandStatus::COMPLETED;\r\n    } else {\r\n        m_failureReason = \"Block placement failed (occupied or invalid)\";\r\n        return eCommandStatus::FAILED;\r\n    }\r\n}\r\n```\r\n\r\n#### 4. CraftCommand\r\n\r\n```cpp\r\nclass CraftCommand : public AgentCommand\r\n{\r\npublic:\r\n    CraftCommand(uint16_t recipeID);\r\n\r\n    virtual void Start() override;\r\n    virtual eCommandStatus Execute(float deltaSeconds, Agent* agent) override;\r\n    virtual std::string GetType() const override { return \"CRAFT\"; }\r\n\r\nprivate:\r\n    uint16_t m_recipeID; // RecipeRegistry ID\r\n};\r\n\r\n// Implementation (instant crafting, no duration)\r\neCommandStatus CraftCommand::Execute(float deltaSeconds, Agent* agent)\r\n{\r\n    UNUSED(deltaSeconds);\r\n\r\n    // Get recipe\r\n    RecipeDefinition const& recipe = g_recipeRegistry->GetRecipeDefinition(m_recipeID);\r\n\r\n    // Check ingredients\r\n    Inventory& inv = agent->GetInventory();\r\n    if (!inv.HasIngredients(recipe.GetIngredients())) {\r\n        m_failureReason = \"Missing ingredients\";\r\n        return eCommandStatus::FAILED;\r\n    }\r\n\r\n    // Remove ingredients\r\n    inv.RemoveIngredients(recipe.GetIngredients());\r\n\r\n    // Add result\r\n    ItemStack result = recipe.GetResult();\r\n    bool added = inv.AddItem(result);\r\n\r\n    if (!added) {\r\n        m_failureReason = \"Inventory full (cannot add result)\";\r\n        // TODO: Should we return ingredients? (Edge case handling)\r\n        return eCommandStatus::FAILED;\r\n    }\r\n\r\n    return eCommandStatus::COMPLETED;\r\n}\r\n```\r\n\r\n#### 5. WaitCommand\r\n\r\n```cpp\r\nclass WaitCommand : public AgentCommand\r\n{\r\npublic:\r\n    WaitCommand(float duration); // Duration in seconds\r\n\r\n    virtual void Start() override;\r\n    virtual eCommandStatus Execute(float deltaSeconds, Agent* agent) override;\r\n    virtual std::string GetType() const override { return \"WAIT\"; }\r\n\r\nprivate:\r\n    float m_duration;\r\n    float m_elapsedTime = 0.0f;\r\n};\r\n\r\n// Implementation\r\nvoid WaitCommand::Start()\r\n{\r\n    m_status = eCommandStatus::IN_PROGRESS;\r\n    m_elapsedTime = 0.0f;\r\n}\r\n\r\neCommandStatus WaitCommand::Execute(float deltaSeconds, Agent* agent)\r\n{\r\n    UNUSED(agent);\r\n\r\n    m_elapsedTime += deltaSeconds;\r\n\r\n    if (m_elapsedTime >= m_duration) {\r\n        return eCommandStatus::COMPLETED;\r\n    }\r\n\r\n    return eCommandStatus::IN_PROGRESS;\r\n}\r\n```\r\n\r\n---\r\n\r\n## 4. Agent Vision System\r\n\r\n### Vision System Design\r\n\r\nThe vision system allows agents to query their environment without direct access to World's internal data structures.\r\n\r\n**Key Methods:**\r\n\r\n```cpp\r\n// In Agent class\r\nstd::vector<BlockInfo> GetNearbyBlocks(float radius) const;\r\nstd::vector<Entity*> GetNearbyEntities(float radius) const;\r\n```\r\n\r\n**BlockInfo Structure:**\r\n\r\n```cpp\r\nstruct BlockInfo {\r\n    IntVec3 blockCoords;    // World coordinates\r\n    uint16_t blockID;       // BlockRegistry ID\r\n    std::string blockName;  // Human-readable name (e.g., \"Stone\", \"Diamond_Ore\")\r\n};\r\n```\r\n\r\n**Use Case Example:**\r\n\r\n```typescript\r\n// TypeScript Agent: Find nearest diamond ore\r\nconst visionResult = await simpleminer.simpleminer_get_nearby_blocks({\r\n  agent_id: agentID,\r\n  radius: 10.0\r\n});\r\n\r\nconst diamondOre = visionResult.blocks.find(b => b.block_name === \"Diamond_Ore\");\r\nif (diamondOre) {\r\n  // Queue MOVE command to diamond ore\r\n  await simpleminer.simpleminer_queue_command({\r\n    agent_id: agentID,\r\n    command_type: \"MOVE\",\r\n    params: diamondOre.block_coords\r\n  });\r\n\r\n  // Queue MINE command\r\n  await simpleminer.simpleminer_queue_command({\r\n    agent_id: agentID,\r\n    command_type: \"MINE\",\r\n    params: { block_coords: diamondOre.block_coords }\r\n  });\r\n}\r\n```\r\n\r\n---\r\n\r\n## 5. KADI WebSocket Integration\r\n\r\n### KADIWebSocketSubsystem API\r\n\r\nBased on Engine's `KADIWebSocketSubsystem` (see `Engine\\Code\\Engine\\Network\\CLAUDE.md`):\r\n\r\n**Key Methods:**\r\n\r\n```cpp\r\n// Lifecycle\r\nvoid Startup();\r\nvoid Shutdown();\r\nvoid BeginFrame();\r\nvoid EndFrame();\r\n\r\n// Connection Management\r\nvoid Connect(std::string const& brokerUrl, std::string const& publicKey, std::string const& privateKey);\r\nvoid Disconnect();\r\nbool IsConnected() const;\r\neKADIConnectionState GetConnectionState() const;\r\n\r\n// Tool Registration (MCP Tools)\r\nvoid RegisterTools(nlohmann::json const& tools);\r\nvoid SendToolResult(int requestId, nlohmann::json const& result);\r\nvoid SendToolError(int requestId, std::string const& errorMessage);\r\n\r\n// Event System\r\nvoid SubscribeToEvents(std::vector<std::string> const& channels);\r\nvoid PublishEvent(std::string const& channel, nlohmann::json const& data);\r\n\r\n// Callback Registration\r\nvoid SetToolInvokeCallback(KADIToolInvokeCallback callback);\r\nvoid SetEventDeliveryCallback(KADIEventDeliveryCallback callback);\r\nvoid SetConnectionStateCallback(KADIConnectionStateCallback callback);\r\n```\r\n\r\n**Callback Types:**\r\n\r\n```cpp\r\nusing KADIToolInvokeCallback = std::function<void(int requestId, std::string const& toolName, nlohmann::json const& arguments)>;\r\nusing KADIEventDeliveryCallback = std::function<void(std::string const& channel, nlohmann::json const& data)>;\r\nusing KADIConnectionStateCallback = std::function<void(eKADIConnectionState oldState, eKADIConnectionState newState)>;\r\n```\r\n\r\n### MCP Tool Registration\r\n\r\n**File:** `Code/Game/Gameplay/Game.cpp` (Startup)\r\n\r\n**Tool Naming Convention:** `lowercase_with_underscores` (e.g., `simpleminer_spawn_agent`)\r\n\r\n```cpp\r\nvoid Game::InitializeKADI()\r\n{\r\n    // Get KADIWebSocketSubsystem from Engine\r\n    g_kadiWebSocket = g_theEngine->GetKADIWebSocketSubsystem();\r\n    if (!g_kadiWebSocket) {\r\n        g_theConsole->PrintString(Rgba8::RED, \"KADI WebSocket subsystem not available\");\r\n        return;\r\n    }\r\n\r\n    // Set tool invoke callback\r\n    g_kadiWebSocket->SetToolInvokeCallback([this](int requestId, std::string const& toolName, nlohmann::json const& arguments) {\r\n        this->OnKADIToolInvoke(requestId, toolName, arguments);\r\n    });\r\n\r\n    // Register 7 MCP tools\r\n    nlohmann::json tools = nlohmann::json::array();\r\n\r\n    // Tool 1: simpleminer_spawn_agent\r\n    tools.push_back({\r\n        {\"name\", \"simpleminer_spawn_agent\"},\r\n        {\"description\", \"Spawn a new AI agent at specified position\"},\r\n        {\"inputSchema\", {\r\n            {\"type\", \"object\"},\r\n            {\"properties\", {\r\n                {\"name\", {{\"type\", \"string\"}, {\"description\", \"Agent name (e.g., 'MinerBot')\"}}},\r\n                {\"x\", {{\"type\", \"number\"}, {\"description\", \"X world coordinate\"}}},\r\n                {\"y\", {{\"type\", \"number\"}, {\"description\", \"Y world coordinate\"}}},\r\n                {\"z\", {{\"type\", \"number\"}, {\"description\", \"Z world coordinate\"}}}\r\n            }},\r\n            {\"required\", nlohmann::json::array({\"name\", \"x\", \"y\", \"z\"})}\r\n        }}\r\n    });\r\n\r\n    // Tool 2: simpleminer_queue_command\r\n    tools.push_back({\r\n        {\"name\", \"simpleminer_queue_command\"},\r\n        {\"description\", \"Queue a command for an agent (MOVE, MINE, PLACE, CRAFT, WAIT)\"},\r\n        {\"inputSchema\", {\r\n            {\"type\", \"object\"},\r\n            {\"properties\", {\r\n                {\"agent_id\", {{\"type\", \"number\"}, {\"description\", \"Agent ID\"}}},\r\n                {\"command_type\", {{\"type\", \"string\"}, {\"enum\", nlohmann::json::array({\"MOVE\", \"MINE\", \"PLACE\", \"CRAFT\", \"WAIT\"})}}},\r\n                {\"params\", {{\"type\", \"object\"}, {\"description\", \"Command-specific parameters\"}}}\r\n            }},\r\n            {\"required\", nlohmann::json::array({\"agent_id\", \"command_type\", \"params\"})}\r\n        }}\r\n    });\r\n\r\n    // Tool 3: simpleminer_get_nearby_blocks\r\n    tools.push_back({\r\n        {\"name\", \"simpleminer_get_nearby_blocks\"},\r\n        {\"description\", \"Query blocks near an agent\"},\r\n        {\"inputSchema\", {\r\n            {\"type\", \"object\"},\r\n            {\"properties\", {\r\n                {\"agent_id\", {{\"type\", \"number\"}}},\r\n                {\"radius\", {{\"type\", \"number\"}, {\"description\", \"Search radius in blocks\"}}}\r\n            }},\r\n            {\"required\", nlohmann::json::array({\"agent_id\", \"radius\"})}\r\n        }}\r\n    });\r\n\r\n    // Tool 4: simpleminer_get_agent_inventory\r\n    tools.push_back({\r\n        {\"name\", \"simpleminer_get_agent_inventory\"},\r\n        {\"description\", \"Get agent's inventory contents\"},\r\n        {\"inputSchema\", {\r\n            {\"type\", \"object\"},\r\n            {\"properties\", {\r\n                {\"agent_id\", {{\"type\", \"number\"}}}\r\n            }},\r\n            {\"required\", nlohmann::json::array({\"agent_id\"})}\r\n        }}\r\n    });\r\n\r\n    // Tool 5: simpleminer_get_agent_status\r\n    tools.push_back({\r\n        {\"name\", \"simpleminer_get_agent_status\"},\r\n        {\"description\", \"Get agent position, current command, queue size\"},\r\n        {\"inputSchema\", {\r\n            {\"type\", \"object\"},\r\n            {\"properties\", {\r\n                {\"agent_id\", {{\"type\", \"number\"}}}\r\n            }},\r\n            {\"required\", nlohmann::json::array({\"agent_id\"})}\r\n        }}\r\n    });\r\n\r\n    // Tool 6: simpleminer_list_agents\r\n    tools.push_back({\r\n        {\"name\", \"simpleminer_list_agents\"},\r\n        {\"description\", \"List all active agents in the world\"},\r\n        {\"inputSchema\", {\r\n            {\"type\", \"object\"},\r\n            {\"properties\", {}}\r\n        }}\r\n    });\r\n\r\n    // Tool 7: simpleminer_despawn_agent\r\n    tools.push_back({\r\n        {\"name\", \"simpleminer_despawn_agent\"},\r\n        {\"description\", \"Remove an agent from the world\"},\r\n        {\"inputSchema\", {\r\n            {\"type\", \"object\"},\r\n            {\"properties\", {\r\n                {\"agent_id\", {{\"type\", \"number\"}}}\r\n            }},\r\n            {\"required\", nlohmann::json::array({\"agent_id\"})}\r\n        }}\r\n    });\r\n\r\n    // Register tools with broker\r\n    g_kadiWebSocket->RegisterTools(tools);\r\n\r\n    // Connect to KADI broker\r\n    std::string brokerUrl = \"ws://localhost:8080/ws\";\r\n    std::string publicKey = LoadPublicKeyFromFile(\"Data/Config/kadi_public.key\");\r\n    std::string privateKey = LoadPrivateKeyFromFile(\"Data/Config/kadi_private.key\");\r\n\r\n    g_kadiWebSocket->Connect(brokerUrl, publicKey, privateKey);\r\n\r\n    g_theConsole->PrintString(Rgba8::GREEN, \"KADI WebSocket initialized, connecting to broker...\");\r\n}\r\n```\r\n\r\n### Tool Invocation Handler\r\n\r\n**File:** `Code/Game/Gameplay/Game.cpp`\r\n\r\n```cpp\r\nvoid Game::OnKADIToolInvoke(int requestId, std::string const& toolName, nlohmann::json const& arguments)\r\n{\r\n    // Dispatch to appropriate handler\r\n    if (toolName == \"simpleminer_spawn_agent\") {\r\n        HandleSpawnAgent(requestId, arguments);\r\n    }\r\n    else if (toolName == \"simpleminer_queue_command\") {\r\n        HandleQueueCommand(requestId, arguments);\r\n    }\r\n    else if (toolName == \"simpleminer_get_nearby_blocks\") {\r\n        HandleGetNearbyBlocks(requestId, arguments);\r\n    }\r\n    else if (toolName == \"simpleminer_get_agent_inventory\") {\r\n        HandleGetAgentInventory(requestId, arguments);\r\n    }\r\n    else if (toolName == \"simpleminer_get_agent_status\") {\r\n        HandleGetAgentStatus(requestId, arguments);\r\n    }\r\n    else if (toolName == \"simpleminer_list_agents\") {\r\n        HandleListAgents(requestId, arguments);\r\n    }\r\n    else if (toolName == \"simpleminer_despawn_agent\") {\r\n        HandleDespawnAgent(requestId, arguments);\r\n    }\r\n    else {\r\n        // Unknown tool\r\n        g_kadiWebSocket->SendToolError(requestId, \"Unknown tool: \" + toolName);\r\n    }\r\n}\r\n\r\nvoid Game::HandleSpawnAgent(int requestId, nlohmann::json const& arguments)\r\n{\r\n    try {\r\n        // Parse arguments\r\n        std::string name = arguments[\"name\"];\r\n        float x = arguments[\"x\"];\r\n        float y = arguments[\"y\"];\r\n        float z = arguments[\"z\"];\r\n\r\n        // Spawn agent\r\n        uint64_t agentID = m_world->SpawnAgent(name, Vec3(x, y, z));\r\n\r\n        // Send result\r\n        nlohmann::json result = {\r\n            {\"agent_id\", agentID},\r\n            {\"position\", {{\"x\", x}, {\"y\", y}, {\"z\", z}}},\r\n            {\"name\", name}\r\n        };\r\n        g_kadiWebSocket->SendToolResult(requestId, result);\r\n    }\r\n    catch (std::exception const& e) {\r\n        g_kadiWebSocket->SendToolError(requestId, std::string(\"Failed to spawn agent: \") + e.what());\r\n    }\r\n}\r\n\r\nvoid Game::HandleQueueCommand(int requestId, nlohmann::json const& arguments)\r\n{\r\n    try {\r\n        uint64_t agentID = arguments[\"agent_id\"];\r\n        std::string commandType = arguments[\"command_type\"];\r\n        nlohmann::json params = arguments[\"params\"];\r\n\r\n        // Find agent\r\n        Agent* agent = m_world->FindAgentByID(agentID);\r\n        if (!agent) {\r\n            g_kadiWebSocket->SendToolError(requestId, \"Agent not found\");\r\n            return;\r\n        }\r\n\r\n        // Create command based on type\r\n        AgentCommand* command = nullptr;\r\n\r\n        if (commandType == \"MOVE\") {\r\n            Vec3 target(params[\"x\"], params[\"y\"], params[\"z\"]);\r\n            command = new MoveCommand(target);\r\n        }\r\n        else if (commandType == \"MINE\") {\r\n            IntVec3 coords(params[\"x\"], params[\"y\"], params[\"z\"]);\r\n            command = new MineCommand(coords);\r\n        }\r\n        else if (commandType == \"PLACE\") {\r\n            IntVec3 coords(params[\"x\"], params[\"y\"], params[\"z\"]);\r\n            uint16_t itemID = params[\"item_id\"];\r\n            command = new PlaceCommand(coords, itemID);\r\n        }\r\n        else if (commandType == \"CRAFT\") {\r\n            uint16_t recipeID = params[\"recipe_id\"];\r\n            command = new CraftCommand(recipeID);\r\n        }\r\n        else if (commandType == \"WAIT\") {\r\n            float duration = params[\"duration\"];\r\n            command = new WaitCommand(duration);\r\n        }\r\n        else {\r\n            g_kadiWebSocket->SendToolError(requestId, \"Unknown command type: \" + commandType);\r\n            return;\r\n        }\r\n\r\n        // Queue command\r\n        agent->QueueCommand(command);\r\n\r\n        // Send result\r\n        nlohmann::json result = {\r\n            {\"success\", true},\r\n            {\"queue_size\", agent->GetCommandQueueSize()}\r\n        };\r\n        g_kadiWebSocket->SendToolResult(requestId, result);\r\n    }\r\n    catch (std::exception const& e) {\r\n        g_kadiWebSocket->SendToolError(requestId, std::string(\"Failed to queue command: \") + e.what());\r\n    }\r\n}\r\n\r\nvoid Game::HandleGetNearbyBlocks(int requestId, nlohmann::json const& arguments)\r\n{\r\n    try {\r\n        uint64_t agentID = arguments[\"agent_id\"];\r\n        float radius = arguments[\"radius\"];\r\n\r\n        Agent* agent = m_world->FindAgentByID(agentID);\r\n        if (!agent) {\r\n            g_kadiWebSocket->SendToolError(requestId, \"Agent not found\");\r\n            return;\r\n        }\r\n\r\n        // Get nearby blocks\r\n        std::vector<Agent::BlockInfo> blocks = agent->GetNearbyBlocks(radius);\r\n\r\n        // Convert to JSON\r\n        nlohmann::json blocksJson = nlohmann::json::array();\r\n        for (auto const& block : blocks) {\r\n            blocksJson.push_back({\r\n                {\"block_coords\", {{\"x\", block.blockCoords.x}, {\"y\", block.blockCoords.y}, {\"z\", block.blockCoords.z}}},\r\n                {\"block_id\", block.blockID},\r\n                {\"block_name\", block.blockName}\r\n            });\r\n        }\r\n\r\n        nlohmann::json result = {\r\n            {\"blocks\", blocksJson},\r\n            {\"count\", blocks.size()}\r\n        };\r\n        g_kadiWebSocket->SendToolResult(requestId, result);\r\n    }\r\n    catch (std::exception const& e) {\r\n        g_kadiWebSocket->SendToolError(requestId, std::string(\"Failed to get nearby blocks: \") + e.what());\r\n    }\r\n}\r\n\r\n// Similar implementations for HandleGetAgentInventory, HandleGetAgentStatus, HandleListAgents, HandleDespawnAgent\r\n```\r\n\r\n---\r\n\r\n## 6. TypeScript Agent Framework\r\n\r\n### Example: MinerAgent\r\n\r\n**File:** `agents/simpleminer/MinerAgent.ts`\r\n\r\nBased on `template-agent-typescript` structure:\r\n\r\n```typescript\r\n/**\r\n * MinerAgent - Autonomous mining agent for SimpleMiner\r\n *\r\n * Capabilities:\r\n * - Find nearest diamond ore using vision system\r\n * - Navigate to ore location\r\n * - Mine ore and collect drops\r\n * - Return to home position\r\n */\r\n\r\nimport 'dotenv/config';\r\nimport { KadiClient } from '@kadi.build/core';\r\n\r\n// Configuration\r\nconst BROKER_URL = process.env.KADI_BROKER_URL || 'ws://localhost:8080';\r\nconst AGENT_NAME = 'miner-agent';\r\nconst NETWORKS = ['global', 'simpleminer'];\r\n\r\n// Mining constants\r\nconst VISION_RADIUS = 20.0;\r\nconst HOME_POSITION = { x: 0, y: 0, z: 70 };\r\nconst MINING_TARGETS = ['Diamond_Ore', 'Iron_Ore', 'Coal_Ore'];\r\n\r\nasync function main() {\r\n    // Create KADI client\r\n    const client = new KadiClient({\r\n        name: AGENT_NAME,\r\n        broker: BROKER_URL,\r\n        networks: NETWORKS\r\n    });\r\n\r\n    // Connect to broker\r\n    await client.connect();\r\n    console.log(`âœ… Connected to KADI broker at ${BROKER_URL}`);\r\n\r\n    // Load SimpleMiner tools\r\n    const simpleminer = await client.load('simpleminer', 'broker');\r\n    console.log(`âœ… Loaded SimpleMiner tools`);\r\n\r\n    // Spawn agent in game\r\n    const spawnResult = await simpleminer.simpleminer_spawn_agent({\r\n        name: 'MinerBot',\r\n        x: HOME_POSITION.x,\r\n        y: HOME_POSITION.y,\r\n        z: HOME_POSITION.z\r\n    });\r\n\r\n    const agentID = spawnResult.agent_id;\r\n    console.log(`âœ… Spawned agent with ID: ${agentID}`);\r\n\r\n    // Main mining loop\r\n    while (true) {\r\n        try {\r\n            // Get nearby blocks\r\n            const visionResult = await simpleminer.simpleminer_get_nearby_blocks({\r\n                agent_id: agentID,\r\n                radius: VISION_RADIUS\r\n            });\r\n\r\n            // Find nearest valuable ore\r\n            const targetOre = visionResult.blocks.find((block: any) =>\r\n                MINING_TARGETS.includes(block.block_name)\r\n            );\r\n\r\n            if (targetOre) {\r\n                console.log(`ðŸŽ¯ Found ${targetOre.block_name} at (${targetOre.block_coords.x}, ${targetOre.block_coords.y}, ${targetOre.block_coords.z})`);\r\n\r\n                // Move to ore\r\n                await simpleminer.simpleminer_queue_command({\r\n                    agent_id: agentID,\r\n                    command_type: 'MOVE',\r\n                    params: {\r\n                        x: targetOre.block_coords.x + 0.5,\r\n                        y: targetOre.block_coords.y + 0.5,\r\n                        z: targetOre.block_coords.z\r\n                    }\r\n                });\r\n\r\n                // Mine ore\r\n                await simpleminer.simpleminer_queue_command({\r\n                    agent_id: agentID,\r\n                    command_type: 'MINE',\r\n                    params: {\r\n                        x: targetOre.block_coords.x,\r\n                        y: targetOre.block_coords.y,\r\n                        z: targetOre.block_coords.z\r\n                    }\r\n                });\r\n\r\n                console.log(`â›ï¸ Queued mining commands`);\r\n            } else {\r\n                console.log(`ðŸ” No ores found nearby, waiting...`);\r\n\r\n                // Wait 5 seconds before next scan\r\n                await simpleminer.simpleminer_queue_command({\r\n                    agent_id: agentID,\r\n                    command_type: 'WAIT',\r\n                    params: { duration: 5.0 }\r\n                });\r\n            }\r\n\r\n            // Check agent status\r\n            const status = await simpleminer.simpleminer_get_agent_status({\r\n                agent_id: agentID\r\n            });\r\n\r\n            console.log(`ðŸ“Š Agent status: Position (${status.position.x}, ${status.position.y}, ${status.position.z}), Queue: ${status.queue_size} commands`);\r\n\r\n            // Wait for commands to execute\r\n            await new Promise(resolve => setTimeout(resolve, 3000));\r\n\r\n        } catch (error) {\r\n            console.error(`âŒ Error: ${error}`);\r\n            await new Promise(resolve => setTimeout(resolve, 5000));\r\n        }\r\n    }\r\n}\r\n\r\n// Graceful shutdown\r\nprocess.on('SIGINT', async () => {\r\n    console.log('\\nðŸ›‘ Shutting down MinerAgent...');\r\n    process.exit(0);\r\n});\r\n\r\nmain().catch(console.error);\r\n```\r\n\r\n### Example: BuilderAgent\r\n\r\n**File:** `agents/simpleminer/BuilderAgent.ts`\r\n\r\n```typescript\r\n/**\r\n * BuilderAgent - Automated construction agent\r\n *\r\n * Capabilities:\r\n * - Build simple structures (walls, floors, pillars)\r\n * - Manage inventory for construction materials\r\n * - Follow blueprint commands from Claude Desktop\r\n */\r\n\r\nimport 'dotenv/config';\r\nimport { KadiClient } from '@kadi.build/core';\r\n\r\nconst BROKER_URL = process.env.KADI_BROKER_URL || 'ws://localhost:8080';\r\nconst AGENT_NAME = 'builder-agent';\r\n\r\ninterface BuildTask {\r\n    type: 'wall' | 'floor' | 'pillar';\r\n    material: string; // e.g., \"Stone\", \"Oak_Planks\"\r\n    start: { x: number; y: number; z: number };\r\n    end: { x: number; y: number; z: number };\r\n}\r\n\r\nasync function buildWall(simpleminer: any, agentID: number, task: BuildTask) {\r\n    const { start, end, material } = task;\r\n\r\n    // Get material item ID (simplified - would query ItemRegistry in production)\r\n    const materialID = getMaterialID(material);\r\n\r\n    // Build wall column by column\r\n    for (let x = start.x; x <= end.x; x++) {\r\n        for (let z = start.z; z <= end.z; z++) {\r\n            // Move to position\r\n            await simpleminer.simpleminer_queue_command({\r\n                agent_id: agentID,\r\n                command_type: 'MOVE',\r\n                params: { x: x + 0.5, y: start.y, z: z }\r\n            });\r\n\r\n            // Place block\r\n            await simpleminer.simpleminer_queue_command({\r\n                agent_id: agentID,\r\n                command_type: 'PLACE',\r\n                params: { x, y: start.y, z, item_id: materialID }\r\n            });\r\n        }\r\n    }\r\n\r\n    console.log(`âœ… Wall built from (${start.x}, ${start.y}, ${start.z}) to (${end.x}, ${end.y}, ${end.z})`);\r\n}\r\n\r\nfunction getMaterialID(materialName: string): number {\r\n    // Map material names to item IDs\r\n    // In production, this would query SimpleMiner's ItemRegistry via MCP tool\r\n    const materials: { [key: string]: number } = {\r\n        'Stone': 1,\r\n        'Dirt': 2,\r\n        'Oak_Planks': 10,\r\n        'Cobblestone': 15\r\n    };\r\n    return materials[materialName] || 1;\r\n}\r\n\r\n// Main function would set up similar pattern to MinerAgent\r\nasync function main() {\r\n    const client = new KadiClient({\r\n        name: AGENT_NAME,\r\n        broker: BROKER_URL,\r\n        networks: ['global', 'simpleminer']\r\n    });\r\n\r\n    await client.connect();\r\n    console.log(`âœ… BuilderAgent connected to KADI broker`);\r\n\r\n    const simpleminer = await client.load('simpleminer', 'broker');\r\n\r\n    // Spawn builder agent\r\n    const spawnResult = await simpleminer.simpleminer_spawn_agent({\r\n        name: 'BuilderBot',\r\n        x: 0, y: 0, z: 70\r\n    });\r\n\r\n    const agentID = spawnResult.agent_id;\r\n    console.log(`âœ… Spawned BuilderBot with ID: ${agentID}`);\r\n\r\n    // Example: Build a simple wall\r\n    await buildWall(simpleminer, agentID, {\r\n        type: 'wall',\r\n        material: 'Stone',\r\n        start: { x: 10, y: 70, z: 10 },\r\n        end: { x: 20, y: 70, z: 10 }\r\n    });\r\n}\r\n\r\nmain().catch(console.error);\r\n```\r\n\r\n---\r\n\r\n## 7. Data Flow Diagrams\r\n\r\n### Spawning Agent Flow\r\n\r\n```\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚  Claude Desktop    â”‚ User: \"Spawn MinerBot at (100, 100, 70)\"\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\r\n          â†“ (Claude API processes request)\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚ TypeScript Agent   â”‚ MinerAgent.ts calls:\r\nâ”‚  (MinerAgent.ts)   â”‚ simpleminer.simpleminer_spawn_agent({name, x, y, z})\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\r\n          â†“ (KadiClient sends JSON-RPC request)\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚   KADI Broker      â”‚ Routes to SimpleMiner (network: simpleminer)\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\r\n          â†“ (WebSocket JSON-RPC message)\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚ KADIWebSocketSub   â”‚ Receives request, parses JSON\r\nâ”‚     (Engine)       â”‚ Invokes SetToolInvokeCallback\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\r\n          â†“\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚ Game::OnKADI       â”‚ OnKADIToolInvoke(requestId, \"simpleminer_spawn_agent\", args)\r\nâ”‚   ToolInvoke       â”‚ Dispatches to HandleSpawnAgent()\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\r\n          â†“\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚  World::           â”‚ SpawnAgent(name, position)\r\nâ”‚  SpawnAgent        â”‚ Creates new Agent* entity\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\r\n          â†“\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚  Agent*            â”‚ new Agent(name, agentID, position)\r\nâ”‚  Constructor       â”‚ Initialize inventory, command queue\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\r\n          â†“\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚ Game::             â”‚ SendToolResult(requestId, {agent_id: 1234})\r\nâ”‚ SendToolResult     â”‚\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\r\n          â†“ (WebSocket response)\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚   KADI Broker      â”‚ Routes response to TypeScript Agent\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\r\n          â†“\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚ TypeScript Agent   â”‚ Receives { agent_id: 1234 }\r\nâ”‚  (MinerAgent.ts)   â”‚ Stores agentID for future commands\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\r\n```\r\n\r\n### Command Execution Flow\r\n\r\n```\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚ TypeScript Agent   â”‚ Calls: simpleminer.simpleminer_queue_command({\r\nâ”‚  (MinerAgent.ts)   â”‚   agent_id: 1234,\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   command_type: \"MINE\",\r\n          â†“              params: {x: 105, y: 100, z: 70}\r\n          â†“            })\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚   KADI Broker      â”‚ Routes to SimpleMiner\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\r\n          â†“\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚ Game::             â”‚ HandleQueueCommand(requestId, args)\r\nâ”‚ OnKADIToolInvoke   â”‚ Finds agent by ID\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ Creates MineCommand(IntVec3(105, 100, 70))\r\n          â†“\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚  Agent::           â”‚ QueueCommand(command)\r\nâ”‚  QueueCommand      â”‚ Adds to m_commandQueue\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\r\n          â†“\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚ Game::             â”‚ SendToolResult(requestId, {success: true})\r\nâ”‚ SendToolResult     â”‚\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\r\n\r\n(Later, during Update loop...)\r\n\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚  Agent::Update     â”‚ Calls ProcessCommandQueue(deltaSeconds)\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\r\n          â†“\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚  Agent::           â”‚ If no current command, dequeue next\r\nâ”‚  ProcessCommand    â”‚ m_currentCommand = m_commandQueue.front()\r\nâ”‚  Queue             â”‚ m_currentCommand->Start()\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\r\n          â†“\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚  MineCommand::     â”‚ Execute(deltaSeconds, agent)\r\nâ”‚  Execute           â”‚ Increment m_miningProgress\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ If progress >= 1.0:\r\n          â†“              - World::BreakBlock()\r\n          â†“              - return COMPLETED\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚  Agent::           â”‚ If status == COMPLETED:\r\nâ”‚  ExecuteCommand    â”‚   CompleteCurrentCommand()\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   delete m_currentCommand\r\n          â†“              m_currentCommand = nullptr\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚  Next Update()     â”‚ Dequeue next command from queue\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\r\n```\r\n\r\n### Vision System Flow\r\n\r\n```\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚ TypeScript Agent   â”‚ Calls: simpleminer.simpleminer_get_nearby_blocks({\r\nâ”‚  (MinerAgent.ts)   â”‚   agent_id: 1234,\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   radius: 20.0\r\n          â†“            })\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚   KADI Broker      â”‚ Routes to SimpleMiner\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\r\n          â†“\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚ Game::             â”‚ HandleGetNearbyBlocks(requestId, args)\r\nâ”‚ OnKADIToolInvoke   â”‚ Finds agent by ID\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ Calls agent->GetNearbyBlocks(radius)\r\n          â†“\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚  Agent::           â”‚ GetNearbyBlocks(20.0)\r\nâ”‚  GetNearbyBlocks   â”‚ Iterate all blocks within 20 block radius\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ For each block:\r\n          â†“              - Check distance\r\n          â†“              - Get Block from World\r\n          â†“              - Query BlockRegistry for name\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚  Return            â”‚ std::vector<BlockInfo>\r\nâ”‚  BlockInfo[]       â”‚ Each entry: {coords, blockID, blockName}\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\r\n          â†“\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚ Game::             â”‚ Convert to JSON array\r\nâ”‚ Handle...Blocks    â”‚ SendToolResult(requestId, {blocks: [...], count: 42})\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\r\n          â†“\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚ TypeScript Agent   â”‚ Receives { blocks: [{block_name: \"Diamond_Ore\", ...}], count: 42 }\r\nâ”‚  (MinerAgent.ts)   â”‚ Find nearest Diamond_Ore\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ Queue MOVE and MINE commands\r\n```\r\n\r\n---\r\n\r\n## 8. Implementation Strategy\r\n\r\n### Phase 1: Agent Entity and Command System (Week 4, Days 1-2)\r\n\r\n**Tasks:**\r\n\r\n1. **Create Agent class** (`Agent.hpp`, `Agent.cpp`)\r\n   - Extend Entity base class\r\n   - Add inventory (36 slots)\r\n   - Add command queue (std::queue<AgentCommand*>)\r\n   - Implement Update() with command processing\r\n   - Implement Render() (green wireframe cube)\r\n\r\n2. **Create AgentCommand base class and implementations**\r\n   - `AgentCommand.hpp` - Base class with virtual Execute()\r\n   - `MoveCommand` - Navigate to position\r\n   - `MineCommand` - Progressive block breaking\r\n   - `PlaceCommand` - Block placement with inventory check\r\n   - `CraftCommand` - Recipe execution\r\n   - `WaitCommand` - Timer-based delay\r\n\r\n3. **Add Agent vision system**\r\n   - `GetNearbyBlocks(radius)` - Query blocks within radius\r\n   - `GetNearbyEntities(radius)` - Query entities within radius\r\n\r\n4. **Update World class**\r\n   - `SpawnAgent(name, position)` â†’ `uint64_t agentID`\r\n   - `FindAgentByID(agentID)` â†’ `Agent*`\r\n   - `DespawnAgent(agentID)` - Remove from entity list\r\n   - Track agents in `std::map<uint64_t, Agent*> m_agents`\r\n\r\n**Testing:**\r\n- Spawn agent via console command: `/spawn_agent MinerBot 100 100 70`\r\n- Queue commands via console: `/queue_command 1234 MOVE 105 100 70`\r\n- Verify command execution (agent moves to target)\r\n\r\n---\r\n\r\n### Phase 2: KADI WebSocket Integration (Week 4, Days 3-4)\r\n\r\n**Tasks:**\r\n\r\n1. **Initialize KADIWebSocketSubsystem in Game::Startup()**\r\n   - Get subsystem from Engine: `g_theEngine->GetKADIWebSocketSubsystem()`\r\n   - Set tool invoke callback: `SetToolInvokeCallback(...)`\r\n   - Load Ed25519 keys from `Data/Config/kadi_public.key` and `kadi_private.key`\r\n   - Connect to broker: `Connect(\"ws://localhost:8080/ws\", publicKey, privateKey)`\r\n\r\n2. **Register 7 MCP tools**\r\n   - Create nlohmann::json array with tool schemas\r\n   - Call `RegisterTools(tools)`\r\n   - Tools:\r\n     1. `simpleminer_spawn_agent`\r\n     2. `simpleminer_queue_command`\r\n     3. `simpleminer_get_nearby_blocks`\r\n     4. `simpleminer_get_agent_inventory`\r\n     5. `simpleminer_get_agent_status`\r\n     6. `simpleminer_list_agents`\r\n     7. `simpleminer_despawn_agent`\r\n\r\n3. **Implement tool handlers**\r\n   - `Game::OnKADIToolInvoke(requestId, toolName, arguments)`\r\n   - Dispatch to 7 handler functions:\r\n     - `HandleSpawnAgent()` - World::SpawnAgent(), send result\r\n     - `HandleQueueCommand()` - Create command, queue, send result\r\n     - `HandleGetNearbyBlocks()` - agent->GetNearbyBlocks(), convert to JSON\r\n     - `HandleGetAgentInventory()` - Serialize inventory to JSON\r\n     - `HandleGetAgentStatus()` - Return position, current command, queue size\r\n     - `HandleListAgents()` - List all active agents\r\n     - `HandleDespawnAgent()` - World::DespawnAgent(), send confirmation\r\n\r\n4. **Handle connection states**\r\n   - Monitor eKADIConnectionState transitions\r\n   - Print status messages (CONNECTED, AUTHENTICATED, READY)\r\n   - Handle disconnections gracefully (don't crash game)\r\n\r\n**Testing:**\r\n- Manually send JSON-RPC request via WebSocket client\r\n- Verify tool registration appears in KADI broker dashboard\r\n- Test spawning agent via KADI tool call\r\n- Test queuing commands via KADI tool call\r\n\r\n---\r\n\r\n### Phase 3: TypeScript Agent Framework (Week 4, Days 5-7)\r\n\r\n**Tasks:**\r\n\r\n1. **Set up TypeScript agent project**\r\n   - Copy `template-agent-typescript` structure\r\n   - Create `agents/simpleminer/` directory\r\n   - Install dependencies: `@kadi.build/core`, `dotenv`\r\n   - Configure `.env` file with `KADI_BROKER_URL` and `KADI_NETWORK`\r\n\r\n2. **Implement MinerAgent.ts**\r\n   - Connect to KADI broker using KadiClient\r\n   - Load SimpleMiner tools: `client.load('simpleminer', 'broker')`\r\n   - Spawn agent: `simpleminer.simpleminer_spawn_agent({...})`\r\n   - Implement mining loop:\r\n     - Get nearby blocks\r\n     - Find diamond ore\r\n     - Queue MOVE command\r\n     - Queue MINE command\r\n     - Wait for execution\r\n   - Add error handling and logging\r\n\r\n3. **Implement BuilderAgent.ts**\r\n   - Similar setup to MinerAgent\r\n   - Implement `buildWall()` function\r\n   - Queue PLACE commands in sequence\r\n   - Manage inventory (check material availability)\r\n\r\n4. **Create agent deployment script**\r\n   - Deploy to DigitalOcean droplet (or run locally for testing)\r\n   - Set up systemd service for auto-restart\r\n   - Configure environment variables\r\n\r\n5. **Test end-to-end flow**\r\n   - Claude Desktop â†’ TypeScript Agent â†’ KADI Broker â†’ SimpleMiner â†’ Agent execution\r\n   - Verify agent spawns, moves, mines blocks\r\n   - Verify vision system returns nearby blocks\r\n   - Verify inventory updates after mining\r\n\r\n**Testing:**\r\n- Run MinerAgent.ts locally: `npm run dev`\r\n- Ask Claude Desktop: \"Spawn a mining agent and find diamond ore\"\r\n- Verify agent appears in SimpleMiner world\r\n- Verify agent moves to ore and mines it\r\n- Verify TypeScript logs show successful execution\r\n\r\n---\r\n\r\n### Phase 4: Integration and Polish (Week 4, Day 7)\r\n\r\n**Tasks:**\r\n\r\n1. **Error handling improvements**\r\n   - Handle agent not found errors gracefully\r\n   - Handle invalid command parameters (out of range, missing items)\r\n   - Add timeout handling for stuck commands\r\n\r\n2. **Performance optimization**\r\n   - Limit vision system queries (cache results for 1 second)\r\n   - Limit command queue size (max 100 commands)\r\n   - Throttle KADI message rate (max 10 requests/second)\r\n\r\n3. **Documentation**\r\n   - Write `agents/simpleminer/README.md` with setup instructions\r\n   - Document MCP tool schemas\r\n   - Add JSDoc comments to TypeScript agents\r\n\r\n4. **Final testing**\r\n   - Test all 7 MCP tools\r\n   - Test all 5 command types\r\n   - Test error cases (invalid agent ID, out of range, etc.)\r\n   - Test concurrent TypeScript agents (MinerAgent + BuilderAgent)\r\n\r\n---\r\n\r\n### Implementation Files Checklist\r\n\r\n**New Files:**\r\n\r\n```\r\nCode/Game/Gameplay/Agent.hpp                     # Agent entity class\r\nCode/Game/Gameplay/Agent.cpp                     # Agent implementation\r\nCode/Game/Framework/AgentCommand.hpp             # Command base class + implementations\r\nCode/Game/Framework/AgentCommand.cpp             # Command implementations\r\nagents/simpleminer/MinerAgent.ts                 # TypeScript mining agent\r\nagents/simpleminer/BuilderAgent.ts               # TypeScript building agent\r\nagents/simpleminer/package.json                  # TypeScript dependencies\r\nagents/simpleminer/.env.template                 # Environment config template\r\nagents/simpleminer/README.md                     # Setup documentation\r\nRun/Data/Config/kadi_public.key                  # Ed25519 public key\r\nRun/Data/Config/kadi_private.key                 # Ed25519 private key (gitignored)\r\n```\r\n\r\n**Modified Files:**\r\n\r\n```\r\nCode/Game/Gameplay/Game.hpp                      # Add KADI initialization\r\nCode/Game/Gameplay/Game.cpp                      # Implement tool handlers\r\nCode/Game/Gameplay/World.hpp                     # Add SpawnAgent, FindAgentByID\r\nCode/Game/Gameplay/World.cpp                     # Agent management\r\nCode/Game/Framework/GameCommon.hpp               # Add Agent-related constants\r\n.gitignore                                       # Ignore kadi_private.key\r\n```\r\n\r\n---\r\n\r\n### Dependencies and Prerequisites\r\n\r\n**Prerequisites from A7-Core:**\r\n- âœ… Registry<T> template (BlockRegistry, ItemRegistry, RecipeRegistry)\r\n- âœ… Inventory class with 36-slot storage\r\n- âœ… ItemStack structure (itemID, quantity, durability)\r\n- âœ… ItemEntity with magnetic pickup\r\n- âœ… World::BreakBlock() - Progressive mining logic\r\n- âœ… World::PlaceBlock() - Block placement validation\r\n- âœ… RecipeDefinition with GetIngredients() and GetResult()\r\n\r\n**External Dependencies:**\r\n- âœ… Engine KADIWebSocketSubsystem (already implemented in Engine)\r\n- âœ… KADI Broker running at `ws://localhost:8080` (separate process)\r\n- âœ… nlohmann/json library (already in Engine/Code/ThirdParty/json/)\r\n- â³ @kadi.build/core npm package (for TypeScript agents)\r\n- â³ template-agent-typescript repository (reference implementation)\r\n\r\n---\r\n\r\n## Conclusion\r\n\r\nThis revised design document provides a complete technical architecture for A7-AI's AI agent framework, aligned with the ProtogameJS3D reference implementation and Engine's KADIWebSocketSubsystem. Key revisions include:\r\n\r\n1. âœ… **Naming Corrections:**\r\n   - Renamed `AIAgent` â†’ `Agent` throughout\r\n   - Changed MCP tool naming from `SimpleMiner_Spawn_Agent` â†’ `simpleminer_spawn_agent`\r\n\r\n2. âœ… **Architecture Alignment:**\r\n   - Broker-centralized pattern (no MCP spawning in game code)\r\n   - Ed25519 authentication with public/private keys\r\n   - 7-state connection flow (DISCONNECTED â†’ READY)\r\n   - Tool registration via nlohmann::json schemas\r\n\r\n3. âœ… **TypeScript Integration:**\r\n   - KadiClient usage pattern from template-agent-typescript\r\n   - Zod schema validation (handled by broker)\r\n   - Event-driven architecture support\r\n   - Cross-language tool loading (`client.load()`)\r\n\r\nThe implementation follows SOLID principles, reuses existing Player logic for mining/placement, and provides a clean separation between game logic and AI control. The design is ready for approval and implementation in Week 4 of Assignment 7.\r\n\r\n**Estimated Implementation Time:** 7 days (Week 4)\r\n**Lines of Code:** ~2,000 lines (C++ Agent framework) + ~500 lines (TypeScript agents)\r\n**Testing Time:** 2 days (integrated with A7-Core and A7-UI testing)\r\n",
  "fileStats": {
    "size": 59685,
    "lines": 1697,
    "lastModified": "2025-11-29T04:00:53.008Z"
  },
  "comments": []
}