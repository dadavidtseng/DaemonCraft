{
  "id": "snapshot_1764388299411_vo8344pg9",
  "approvalId": "approval_1764294255841_lrwitao32",
  "approvalTitle": "A7-Core requirements.md - Foundation Systems",
  "version": 2,
  "timestamp": "2025-11-29T03:51:39.411Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Assignment 7-Core: Foundation Systems (Registry, Inventory, Mining, Placement)\r\n\r\n**Due Date:** December 12, 2025 (Week 1-2)\r\n**Estimated Duration:** 1-2 weeks\r\n**Complexity:** High (Multi-system foundation)\r\n**Implementation Standard:** ⭐ **Follow Minecraft Implementation Patterns** ⭐\r\n\r\n---\r\n\r\n## Executive Summary\r\n\r\nAssignment 7-Core implements the foundational gameplay systems for SimpleMiner, establishing the data-driven architecture and core mechanics that will support all future features:\r\n\r\n1. **Rendering Bug Fix** - Fix incorrect hidden surface removal at chunk boundaries\r\n2. **Minecraft-style Registry System** - Data-driven architecture for blocks, items, and recipes (JSON-based)\r\n3. **Inventory System** - Player item storage with hotbar and full inventory management (Minecraft-style)\r\n4. **Mining Mechanics** - Progressive block breaking and item drops (Minecraft mechanics)\r\n5. **Block Placement Mechanics** - Item-based block placement (Minecraft mechanics)\r\n6. **Basic HUD** - Hotbar widget only (bottom-center display, Minecraft-style)\r\n\r\nThis assignment establishes the foundation for SimpleMiner's gameplay loop (mine → collect → craft → build) and prepares the codebase for UI and AI integration in subsequent specs.\r\n\r\n---\r\n\r\n## Project Context\r\n\r\n### Current State (Post-A6)\r\n\r\n**Existing Systems:**\r\n- ✅ Newtonian physics with gravity, friction, collision detection (Entity.cpp)\r\n- ✅ 5 camera modes (FIRST_PERSON, OVER_SHOULDER, SPECTATOR, etc.)\r\n- ✅ 3 physics modes (WALKING, FLYING, NOCLIP)\r\n- ✅ BlockDefinition system with XML loading (will migrate to JSON)\r\n- ✅ Chunk-based world with async generation/loading\r\n- ✅ JSON library (`C:\\p4\\Personal\\SD\\Engine\\Code\\ThirdParty\\json\\json.hpp`)\r\n\r\n**Known Issues:**\r\n- ❌ **Rendering Bug**: Some block faces incorrectly hidden at chunk boundaries (MUST FIX)\r\n\r\n### Target State (Post-A7-Core)\r\n\r\n**New Systems:**\r\n- ✅ Rendering bug fixed (chunk boundary face visibility)\r\n- ✅ Registry<T> template for type-safe ID management\r\n- ✅ ItemRegistry, enhanced BlockRegistry, RecipeRegistry (JSON-based)\r\n- ✅ ItemStack data structure with quantity and type\r\n- ✅ Player inventory (36 slots: 27 main + 9 hotbar)\r\n- ✅ ItemEntity for dropped items (magnetic pickup, world physics)\r\n- ✅ Mining mechanics (progressive break, block → item drop, Minecraft-style)\r\n- ✅ Placement mechanics (consume inventory, place block, Minecraft-style)\r\n- ✅ Basic HUD (hotbar widget only, Minecraft-style)\r\n\r\n---\r\n\r\n## Goals and Objectives\r\n\r\n### Primary Goals\r\n\r\n1. **Fix Rendering Bug** - Eliminate hidden surface removal artifacts at chunk boundaries\r\n2. **Registry Architecture** - Establish Minecraft-inspired JSON-driven foundation\r\n3. **Core Gameplay Loop** - Enable mine → collect → place cycle (Minecraft mechanics)\r\n4. **Basic UI** - Display hotbar with item counts (Minecraft-style)\r\n\r\n### Secondary Goals\r\n\r\n1. **Performance** - Maintain 60 FPS with hotbar rendering and item entities\r\n2. **Extensibility** - Design for future expansion (more items, recipes, full UI)\r\n3. **Code Quality** - Clean separation between data (Registry) and logic (Game systems)\r\n\r\n### Non-Goals (Explicitly Out of Scope for A7-Core)\r\n\r\n- ❌ Full inventory screen (deferred to A7-UI)\r\n- ❌ Crafting interface (deferred to A7-UI)\r\n- ❌ AI agents (deferred to A7-AI)\r\n- ❌ Menu system (deferred to A7-Polish)\r\n- ❌ Sound effects (deferred to A7-Polish)\r\n- ❌ Combat/damage system\r\n- ❌ Health/hunger bars\r\n- ❌ Armor system\r\n- ❌ Particle effects\r\n\r\n---\r\n\r\n## Functional Requirements\r\n\r\n### FR-0: Rendering Bug Fix (BLOCKING)\r\n\r\n#### FR-0.1: Fix Hidden Surface Removal at Chunk Boundaries\r\n**Description**: Fix incorrect face culling when neighboring chunks are not loaded.\r\n\r\n**Problem**:\r\n- File: `Chunk.cpp:3632` in `IsFaceVisible()` function\r\n- Bug: Returns `false` when `neighborIter.IsValid()` is false\r\n- Effect: Assumes unloaded chunks are opaque, hides visible surface faces\r\n\r\n**Solution**:\r\n```cpp\r\n// File: Chunk.cpp, line ~3632\r\nbool Chunk::IsFaceVisible(BlockIterator const& blockIter, IntVec3 const& faceDirection) const\r\n{\r\n    BlockIterator neighborIter = blockIter.GetNeighbor(faceDirection);\r\n\r\n    if (!neighborIter.IsValid())\r\n    {\r\n        IntVec3 currentCoords = blockIter.GetLocalCoords();\r\n        IntVec3 neighborCoords = currentCoords + faceDirection;\r\n        int worldZ = neighborCoords.z;\r\n\r\n        if (worldZ < 0 || worldZ >= CHUNK_SIZE_Z)\r\n        {\r\n            return true;  // At vertical boundaries, render face\r\n        }\r\n\r\n        // ✅ FIX: Horizontal chunk boundary - assume neighbor is AIR (transparent)\r\n        return true;  // Changed from false to true\r\n    }\r\n\r\n    // Rest unchanged...\r\n}\r\n```\r\n\r\n**Rationale**:\r\n- Better to render extra faces temporarily than hide visible ones\r\n- Minecraft renders chunk boundaries optimistically\r\n- Face will be hidden when neighbor chunk loads (mesh rebuild)\r\n- Small performance impact (~16-32 extra quads per chunk edge)\r\n\r\n**Acceptance Criteria**:\r\n- ✅ Surface chunk boundaries show all visible faces\r\n- ✅ Underground cave boundaries are continuous\r\n- ✅ Building across chunks has no missing faces\r\n- ✅ Chunk load/unload cycle correctly rebuilds meshes\r\n\r\n---\r\n\r\n### FR-1: Registry System (JSON-Based)\r\n\r\n#### FR-1.1: Generic Registry Template\r\n**Description**: Implement type-safe registry pattern for managing game objects with persistent IDs.\r\n\r\n**Requirements**:\r\n- Template class `Registry<T>` supporting any type\r\n- Numeric ID assignment (uint16_t for 65,535 entries)\r\n- String name → ID lookup (case-insensitive)\r\n- ID → Object pointer lookup\r\n- Registration order preservation\r\n- Thread-safe read access (write happens during startup only)\r\n- **JSON loading** (not XML) using Engine's json.hpp\r\n\r\n**Acceptance Criteria**:\r\n```cpp\r\nRegistry<BlockDefinition> blockRegistry;\r\nblockRegistry.Register(\"stone\", stoneDefPtr);\r\nuint16_t stoneID = blockRegistry.GetID(\"stone\");  // Returns stable ID\r\nBlockDefinition* def = blockRegistry.Get(stoneID); // O(1) lookup\r\n```\r\n\r\n#### FR-1.2: Block Registry (JSON Migration)\r\n**Description**: Migrate existing BlockDefinition system to Registry pattern with JSON.\r\n\r\n**Requirements**:\r\n- Replace static `s_definitions` vector with `BlockRegistry` singleton\r\n- **Migrate from XML to JSON** format (BlockDefinitions.json)\r\n- Use `C:\\p4\\Personal\\SD\\Engine\\Code\\ThirdParty\\json\\json.hpp` for parsing\r\n- Preserve AIR as ID 0\r\n- Maintain loading order for compatibility with existing chunks\r\n- Support by-name and by-ID lookup\r\n- Follow Minecraft's block definition structure\r\n\r\n**JSON Format Example**:\r\n```json\r\n{\r\n  \"blocks\": [\r\n    {\r\n      \"name\": \"stone\",\r\n      \"visible\": true,\r\n      \"solid\": true,\r\n      \"opaque\": true,\r\n      \"topSprite\": [1, 0],\r\n      \"bottomSprite\": [1, 0],\r\n      \"sideSprite\": [1, 0],\r\n      \"indoorLighting\": 0.0,\r\n      \"hardness\": 1.5\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n**Acceptance Criteria**:\r\n- All existing block types load from BlockDefinitions.json\r\n- `Block::GetDefinition()` still works via registry lookup\r\n- JSON definitions load in same order as before\r\n- No breaking changes to existing Chunk code\r\n\r\n#### FR-1.3: Item Registry (JSON-Based, Minecraft-Style)\r\n**Description**: Create item system with JSON registry following Minecraft patterns.\r\n\r\n**Requirements**:\r\n- `ItemDefinition` class with Minecraft-style properties:\r\n  - String name, description\r\n  - Texture/sprite coordinates\r\n  - ItemType enum (RESOURCE, TOOL, BLOCK, CONSUMABLE)\r\n  - BlockType reference (for placeable items)\r\n  - Tool properties (mining speed, durability)\r\n  - Max stack size (Minecraft standard: 64 for blocks, 1 for tools, 16 for some items)\r\n- **JSON loading** from `ItemDefinitions.json`\r\n- Item ID range separate from block IDs\r\n- Support for block items (e.g., \"Stone Block\" item places STONE block)\r\n- Follow Minecraft's item definition structure\r\n\r\n**JSON Format Example**:\r\n```json\r\n{\r\n  \"items\": [\r\n    {\r\n      \"name\": \"stone_block\",\r\n      \"displayName\": \"Stone\",\r\n      \"type\": \"block\",\r\n      \"blockType\": \"stone\",\r\n      \"maxStackSize\": 64,\r\n      \"spriteCoords\": [1, 0]\r\n    },\r\n    {\r\n      \"name\": \"wooden_pickaxe\",\r\n      \"displayName\": \"Wooden Pickaxe\",\r\n      \"type\": \"tool\",\r\n      \"miningSpeed\": 2.0,\r\n      \"durability\": 60,\r\n      \"maxStackSize\": 1,\r\n      \"spriteCoords\": [0, 3]\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n**Acceptance Criteria**:\r\n- Items load from JSON\r\n- Block items correctly reference block types\r\n- Tool items have durability and mining speed\r\n- Stack sizes follow Minecraft conventions\r\n\r\n#### FR-1.4: Recipe Registry (JSON-Based, Minecraft Recipes)\r\n**Description**: Define 10 Minecraft-style crafting recipes for 2×2 crafting grid.\r\n\r\n**Requirements**:\r\n- `Recipe` class with input/output patterns\r\n- 2×2 grid support (4 input slots)\r\n- Shaped recipes (pattern matters)\r\n- Shapeless recipes (pattern doesn't matter)\r\n- Recipe validation (check if inventory matches)\r\n- **JSON-based recipe definitions** following Minecraft format\r\n- **10 total recipes**\r\n\r\n**JSON Format Example**:\r\n```json\r\n{\r\n  \"recipes\": [\r\n    {\r\n      \"type\": \"shaped\",\r\n      \"pattern\": [\r\n        [\"log\", \"log\"],\r\n        [\"log\", \"log\"]\r\n      ],\r\n      \"result\": {\r\n        \"item\": \"crafting_table\",\r\n        \"count\": 1\r\n      }\r\n    },\r\n    {\r\n      \"type\": \"shapeless\",\r\n      \"ingredients\": [\"log\"],\r\n      \"result\": {\r\n        \"item\": \"planks\",\r\n        \"count\": 4\r\n      }\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n**10 Required Recipes** (Minecraft-based):\r\n1. LOG → 4 PLANKS (shapeless)\r\n2. 4 PLANKS (2×2) → CRAFTING_TABLE (shaped)\r\n3. 2 PLANKS (vertical) → 4 STICKS (shaped)\r\n4. 3 PLANKS + 2 STICKS → WOODEN_PICKAXE (shaped)\r\n5. 3 PLANKS + 2 STICKS → WOODEN_AXE (shaped)\r\n6. 1 PLANK + 2 STICKS → WOODEN_SHOVEL (shaped)\r\n7. 4 COBBLESTONE (2×2) → FURNACE (shaped)\r\n8. 2 COBBLESTONE (vertical) → STONE_STAIRS (shaped)\r\n9. 3 COBBLESTONE (horizontal) → STONE_SLAB (shaped)\r\n10. 1 COAL + 1 STICK → TORCH (shapeless)\r\n\r\n**Note**: Recipes will be used in A7-UI crafting interface, but registry is defined in A7-Core for data completeness.\r\n\r\n---\r\n\r\n### FR-2: Inventory System (Minecraft-Style)\r\n\r\n#### FR-2.1: ItemStack Data Structure\r\n**Description**: Represent item quantity and type in a single slot (Minecraft pattern).\r\n\r\n**Requirements**:\r\n- `ItemStack` struct:\r\n  - `uint16_t itemID` (ItemRegistry ID)\r\n  - `uint8_t quantity` (1-255, Minecraft uses 1-64 typically)\r\n  - `uint16_t durability` (for tools, optional)\r\n- Empty stack representation (itemID = 0)\r\n- Stack merging logic (same item, below max stack size)\r\n- Stack splitting (take N from stack)\r\n- Follow Minecraft stacking rules\r\n\r\n**Acceptance Criteria**:\r\n```cpp\r\nItemStack stack(STONE_BLOCK_ITEM, 32);\r\nbool canMerge = stack.CanMergeWith(otherStack);\r\nItemStack split = stack.TakeQuantity(16); // Now has 16, split has 16\r\n```\r\n\r\n#### FR-2.2: Player Inventory (Minecraft Layout)\r\n**Description**: Player storage for collected items following Minecraft structure.\r\n\r\n**Requirements**:\r\n- 36 total slots (Minecraft standard):\r\n  - Slots 0-26: Main inventory (27 slots, 3 rows × 9 columns)\r\n  - Slots 27-35: Hotbar (9 slots, bottom row)\r\n- Current selected hotbar slot (0-8)\r\n- Add item (find empty/matching slot, Minecraft behavior)\r\n- Remove item by slot\r\n- Transfer items between slots\r\n- **Serialize/deserialize for save system** (JSON format)\r\n\r\n**Acceptance Criteria**:\r\n- Picking up items fills inventory automatically (Minecraft behavior)\r\n- Hotbar slots 1-9 map to keyboard keys 1-9\r\n- Full inventory prevents further pickups\r\n- Inventory persists across save/load\r\n\r\n#### FR-2.3: Item Pickup System (Minecraft Mechanics)\r\n**Description**: World items can be collected into inventory (Minecraft behavior).\r\n\r\n**Requirements**:\r\n- `ItemEntity` class (extends Entity):\r\n  - Position, velocity (affected by gravity, Minecraft physics)\r\n  - ItemStack contents\r\n  - Pickup cooldown (0.5 seconds after drop, Minecraft standard)\r\n  - Magnetic attraction to nearby player (3 block radius, Minecraft mechanic)\r\n  - **Item stacking in world** (multiple same items merge into one entity with higher quantity)\r\n- Collision detection with player\r\n- Inventory space check before pickup\r\n- Visual feedback (item entity disappears)\r\n- Item entity despawn timer (5 minutes, Minecraft standard)\r\n\r\n**Acceptance Criteria**:\r\n- Breaking a block spawns ItemEntity at block center\r\n- Player walks near ItemEntity, it flies toward player (Minecraft magnetic pull)\r\n- On collision, item added to inventory, entity destroyed\r\n- If inventory full, item remains in world\r\n- Multiple dropped items of same type stack together (Minecraft behavior)\r\n\r\n---\r\n\r\n### FR-3: Mining & Placement Mechanics (Minecraft-Style)\r\n\r\n#### FR-3.1: Progressive Block Breaking (Minecraft Mechanics)\r\n**Description**: Blocks take time to break with visual progress (Minecraft system).\r\n\r\n**Requirements**:\r\n- Raycast from player camera to detect targeted block (6 block range, Minecraft standard)\r\n- Hold left mouse button to mine\r\n- Mining progress (0.0 to 1.0) based on Minecraft formula:\r\n  - Block hardness (BlockDefinition property)\r\n  - Tool effectiveness (ToolDefinition property)\r\n  - Time held\r\n- Visual crack overlay (10 stages, 0-9, Minecraft style)\r\n- Cancel mining if:\r\n  - Player releases mouse\r\n  - Player looks away from block\r\n  - Player moves too far (7 block range)\r\n- On completion:\r\n  - Block removed from world (set to AIR)\r\n  - ItemEntity spawned with block drop\r\n  - Tool durability decreases (if tool used)\r\n\r\n**Break Time Formula** (Minecraft-based):\r\n```cpp\r\nfloat breakTime = blockHardness / (toolEffectiveness * globalMultiplier);\r\n// Example: Stone (hardness 1.5) with wooden pickaxe (effectiveness 2.0)\r\n// breakTime = 1.5 / 2.0 = 0.75 seconds\r\n```\r\n\r\n**Acceptance Criteria**:\r\n- Holding left mouse on stone block shows progressive cracks (Minecraft style)\r\n- After ~0.75s (with pickaxe), block breaks and drops item\r\n- Without tool, takes 3x longer (Minecraft penalty)\r\n- Breaking GRASS drops DIRT_BLOCK item (Minecraft behavior)\r\n- Tool durability decreases on each block broken\r\n\r\n#### FR-3.2: Block Placement (Minecraft Mechanics)\r\n**Description**: Place blocks from hotbar into world (Minecraft placement rules).\r\n\r\n**Requirements**:\r\n- Raycast to find placement position (adjacent to targeted block face, Minecraft rule)\r\n- Right mouse button to place\r\n- Consume 1 item from selected hotbar slot\r\n- Check placement validity (Minecraft rules):\r\n  - Target position not occupied by solid block\r\n  - Player not intersecting placed block position\r\n  - Within reach (6 block range, Minecraft standard)\r\n- Update chunk mesh after placement\r\n- Visual preview (ghost block) before placement (optional, nice-to-have)\r\n\r\n**Acceptance Criteria**:\r\n- With STONE_BLOCK in hotbar, right-click places stone block (Minecraft behavior)\r\n- Item quantity decreases by 1\r\n- Cannot place block inside player (Minecraft rule)\r\n- Can place blocks on ground, walls, ceilings (Minecraft placement)\r\n\r\n#### FR-3.3: Tool Effectiveness System (Minecraft-Based)\r\n**Description**: Different tools break blocks at different speeds (Minecraft system).\r\n\r\n**Requirements**:\r\n- `ToolDefinition` properties (Minecraft-style):\r\n  - Tool tier (WOOD, STONE, IRON, DIAMOND)\r\n  - Effectiveness multiplier per block type\r\n  - **Durability** (uses before breaking, Minecraft standard: Wood=60, Stone=132, Iron=251, Diamond=1562)\r\n- Preferred tool for each block (Minecraft rules):\r\n  - STONE → Pickaxe (faster)\r\n  - DIRT/GRASS → Shovel (faster)\r\n  - WOOD → Axe (faster)\r\n- Wrong tool or no tool: 0.5x speed (Minecraft penalty)\r\n- **Tool durability decreases on block break**\r\n- Tool breaks when durability reaches 0 (disappears from inventory, Minecraft behavior)\r\n\r\n**Example** (Minecraft-based):\r\n```cpp\r\n// Breaking stone with wooden pickaxe: 0.75s\r\n// Breaking stone with stone pickaxe: 0.5s\r\n// Breaking stone with hand (no tool): 2.25s\r\n// Wooden pickaxe breaks after 60 uses\r\n```\r\n\r\n---\r\n\r\n### FR-4: Basic HUD (Minecraft-Style Hotbar Only)\r\n\r\n#### FR-4.1: Hotbar Widget (Minecraft-Style)\r\n**Description**: Always-visible hotbar UI element during gameplay (pixel-perfect Minecraft style).\r\n\r\n**Requirements**:\r\n- **Hotbar Widget** (bottom-center, Minecraft style):\r\n  - 9 slots displayed horizontally\r\n  - Selected slot highlighted (white border, Minecraft style)\r\n  - Item icons rendered in each slot (16×16 pixel items, Minecraft size)\r\n  - Item quantity displayed (bottom-right corner, if > 1, Minecraft position)\r\n  - Semi-transparent gray background (Minecraft GUI texture)\r\n- **Crosshair Widget** (center, Minecraft style):\r\n  - Simple white cross (Minecraft crosshair design)\r\n  - Always visible, no alpha fade\r\n\r\n**UI Assets**:\r\n- **Find online** or **draw programmatically** using Engine renderer\r\n- Must match Minecraft visual style (pixel-perfect if possible)\r\n- Reference Minecraft UI screenshots for accuracy\r\n\r\n**WidgetSubsystem Integration**:\r\n- May need to **refine/redesign WidgetSubsystem** for production quality\r\n- Create custom `HotbarWidget` class (extends `IWidget`)\r\n- Use `WidgetSubsystem::AddWidget()` with zOrder=100 (above world)\r\n- Render with orthographic projection (screen-space coordinates)\r\n\r\n**Acceptance Criteria**:\r\n- Hotbar looks like Minecraft (visual fidelity)\r\n- Selecting different slots (1-9 keys) updates highlight (Minecraft behavior)\r\n- Item icons and quantities render correctly (Minecraft style)\r\n- Crosshair centered on screen\r\n\r\n**Note**: Full inventory screen and crafting interface deferred to A7-UI.\r\n\r\n---\r\n\r\n## Non-Functional Requirements\r\n\r\n### NFR-1: Performance\r\n- **Target FPS**: 60 FPS sustained with hotbar rendering\r\n- **UI Rendering**: < 1ms per frame for hotbar widget\r\n- **JSON Loading**: < 100ms for all registries at startup\r\n\r\n### NFR-2: Memory\r\n- **Registry Overhead**: < 1MB for all registries combined\r\n- **Inventory Storage**: 36 slots × 6 bytes = 216 bytes per player\r\n- **ItemEntity**: < 100 bytes per entity\r\n\r\n### NFR-3: Usability (Minecraft Standard)\r\n- **Input Responsiveness**: < 16ms (one frame) from input to action\r\n- **Visual Feedback**: All interactions show immediate feedback (Minecraft polish)\r\n- **Error Messages**: Clear error messages for invalid placements/mining\r\n\r\n### NFR-4: Extensibility\r\n- **Registry Design**: Easy to add new blocks, items, recipes via JSON\r\n- **Inventory Logic**: Reusable for AI agents (A7-AI) and other entities\r\n\r\n### NFR-5: Code Quality\r\n- **SOLID Principles**: Registry pattern demonstrates Single Responsibility\r\n- **DRY**: No duplicate inventory logic across classes\r\n- **YAGNI**: Only implement 2×2 crafting registry, not UI yet\r\n- **KISS**: Simple ItemStack struct, straightforward mining mechanics\r\n- **Minecraft Fidelity**: All systems follow Minecraft implementation patterns\r\n\r\n---\r\n\r\n## Constraints and Assumptions\r\n\r\n### Technical Constraints\r\n1. **DirectX 11**: Hotbar UI must use existing WidgetSubsystem (may need refinement)\r\n2. **Windows Only**: No cross-platform support required\r\n3. **Single-threaded Gameplay**: Game logic runs on main thread\r\n4. **JSON Library**: Must use `C:\\p4\\Personal\\SD\\Engine\\Code\\ThirdParty\\json\\json.hpp`\r\n\r\n### Assumptions\r\n1. **Rendering Bug Fix**: Can be completed quickly (1-2 hours)\r\n2. **WidgetSubsystem**: Functional enough for basic hotbar rendering (refinement can happen later)\r\n3. **Minecraft Assets**: Hotbar sprite sheet can be found online or recreated programmatically\r\n4. **Save System**: Inventory serialization piggybacks on existing chunk save system\r\n\r\n---\r\n\r\n## Success Criteria\r\n\r\n### Minimum Viable Product (MVP)\r\n**These features MUST work for A7-Core completion**:\r\n\r\n1. ✅ Rendering bug fixed (no missing faces at chunk boundaries)\r\n2. ✅ Registry system (Block, Item, Recipe) functional with JSON loading\r\n3. ✅ Player inventory with 36 slots\r\n4. ✅ Mining mechanics (progressive break, item drop, pickup) - Minecraft-style\r\n5. ✅ Placement mechanics (consume inventory, place block) - Minecraft-style\r\n6. ✅ Hotbar HUD with item display and selection (Minecraft-style)\r\n7. ✅ Tool durability system (if feasible)\r\n\r\n**Demo Scenario**:\r\n```\r\n1. Start game in existing world\r\n2. Player mines 4 logs (break blocks, collect items)\r\n3. Hotbar shows log items (bottom-center, Minecraft style)\r\n4. Player uses wooden pickaxe to mine stone (tool durability decreases)\r\n5. Pickaxe breaks after 60 uses (disappears from hotbar)\r\n6. Player places logs to build structure (right-click)\r\n7. Item quantity in hotbar decreases with each placement\r\n```\r\n\r\n### Stretch Goals (Nice-to-Have)\r\n**These features are bonus, not required**:\r\n\r\n- ⭐ Tool durability fully implemented (if not too hard)\r\n- ⭐ Ghost block preview before placement\r\n- ⭐ Pixel-perfect Minecraft hotbar recreation\r\n- ⭐ Item entity stacking animation (Minecraft item pickup animation)\r\n- ⭐ F3 debug overlay enhancement (Minecraft F3 style) - currently basic\r\n\r\n---\r\n\r\n## Dependencies\r\n\r\n**Engine Systems**:\r\n1. **WidgetSubsystem**: Must refine for hotbar rendering (basic functionality sufficient)\r\n2. **JSON Library**: Must use for all JSON parsing (`ThirdParty\\json\\json.hpp`)\r\n3. **Entity System**: Extend for ItemEntity physics\r\n4. **Chunk System**: Integrate with block placement/removal mesh rebuilding\r\n\r\n**A7 Spec Sequence**:\r\n- **A7-Core** (this spec) → **A7-UI** (inventory screen, crafting) → **A7-AI** (agents, KADI)\r\n- A7-UI depends on A7-Core registries and inventory system\r\n- A7-AI depends on A7-Core inventory system (agents have inventory)\r\n\r\n---\r\n\r\n## References\r\n\r\n### Minecraft Systems (Implementation Reference)\r\n- [Minecraft Wiki: Inventory](https://minecraft.wiki/w/Inventory)\r\n- [Minecraft Wiki: Mining](https://minecraft.wiki/w/Mining)\r\n- [Minecraft Wiki: Items](https://minecraft.wiki/w/Item)\r\n- [Minecraft Wiki: Blocks](https://minecraft.wiki/w/Block)\r\n\r\n### SimpleMiner Codebase\r\n- **Engine**: `C:\\p4\\Personal\\SD\\Engine\\Code\\Engine\\`\r\n  - `Widget\\` - WidgetSubsystem (needs refinement)\r\n  - `ThirdParty\\json\\json.hpp` - JSON library\r\n- **SimpleMiner**: `C:\\p4\\Personal\\SD\\SimpleMiner\\Code\\Game\\`\r\n  - `Framework\\Chunk.cpp` (line 3632: rendering bug fix location)\r\n  - `Gameplay\\Player.cpp` (extend with inventory)\r\n\r\n---\r\n\r\n**Next Steps**:\r\n1. Review and approve this requirements.md via spec-workflow\r\n2. Create design.md for A7-Core with detailed architecture\r\n3. After design approval, create tasks.md and begin implementation\r\n4. After A7-Core complete, proceed to A7-UI spec\r\n",
  "fileStats": {
    "size": 22473,
    "lines": 600,
    "lastModified": "2025-11-28T01:16:22.608Z"
  },
  "comments": []
}