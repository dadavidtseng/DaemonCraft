{
  "id": "snapshot_1764393598572_dji8pz6e5",
  "approvalId": "approval_1764391107299_0kh57dtjh",
  "approvalTitle": "A7-AI design.md v2.1 (Ed25519 Runtime Key Generation)",
  "version": 4,
  "timestamp": "2025-11-29T05:19:58.572Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Assignment 7-AI: Design Document\n# AI Agent Integration (KADI WebSocket, Agent Framework)\n\n**Version:** 2.0 (REVISED)\n**Date:** 2025-11-29\n**Status:** Design Phase - Revision 1\n**Dependencies:** âœ… Requires A7-Core completion (Registry, Inventory systems)\n\n---\n\n## Revision History\n\n**v2.0 (2025-11-29)** - Architecture revision based on ProtogameJS3D framework:\n\n**v2.1 (2025-11-29)** - Ed25519 key management revision:\n- âœ… Changed from file-based key storage to runtime key generation\n- âœ… Updated InitializeKADI() to use KADIAuthenticationUtility::GenerateKeyPair()\n- âœ… Removed kadi_public.key and kadi_private.key from file checklist\n- âœ… Aligned with ProtogameJS3D pattern: keys generated on startup, not loaded from disk\n- âœ… Renamed AIAgent â†’ Agent throughout entire document\n- âœ… Changed MCP tool naming: `SimpleMiner_Spawn_Agent` â†’ `simpleminer_spawn_agent` (lowercase_with_underscores)\n- âœ… Revised KADI integration to match Engine KADIWebSocketSubsystem API\n- âœ… Added 7-state connection flow (DISCONNECTED â†’ READY)\n- âœ… Updated agent architecture to follow broker-centralized pattern\n- âœ… Added Ed25519 authentication details\n- âœ… Aligned TypeScript agent examples with template-agent-typescript structure\n\n**v1.0 (2025-11-27)** - Initial design\n\n---\n\n## Executive Summary\n\nThis design document provides the technical architecture for A7-AI's implementation of AI agent framework and KADI WebSocket integration. The design covers:\n\n1. **Agent Entity Class** - Autonomous entity with inventory and command queue (extends Entity)\n2. **Agent Command System** - MOVE, MINE, PLACE, CRAFT, WAIT commands\n3. **Agent Vision System** - Query nearby blocks and entities\n4. **KADI WebSocket Integration** - 7 MCP tools using Engine's KADIWebSocketSubsystem\n5. **TypeScript Agent Framework** - Example agent behaviors (MinerAgent, BuilderAgent)\n\n**Design Philosophy:**\n- **Command Execution Only** - No goal-based AI (defer to future assignment)\n- **Reuse Player Logic** - Share mining/placement code with Player class\n- **Non-Blocking Network** - KADI communication doesn't freeze game\n- **Broker-Centralized Architecture** - No MCP spawning in SimpleMiner code\n- **MCP Tool Naming** - lowercase_with_underscores (e.g., `simpleminer_spawn_agent`)\n\n---\n\n## Table of Contents\n\n1. [System Architecture Overview](#1-system-architecture-overview)\n2. [Agent Class Design](#2-agent-class-design)\n3. [Agent Command System](#3-agent-command-system)\n4. [Agent Vision System](#4-agent-vision-system)\n5. [KADI WebSocket Integration](#5-kadi-websocket-integration)\n6. [TypeScript Agent Framework](#6-typescript-agent-framework)\n7. [Data Flow Diagrams](#7-data-flow-diagrams)\n8. [Implementation Strategy](#8-implementation-strategy)\n\n---\n\n## 1. System Architecture Overview\n\n### Component Architecture\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚      TypeScript Agents (DigitalOcean)       â”‚\nâ”‚   MinerAgent.ts, BuilderAgent.ts            â”‚\nâ”‚   Uses @kadi.build/core (KadiClient)        â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                    â†“â†‘ WebSocket (KADI Protocol)\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚         KADI Broker (localhost:8080)        â”‚\nâ”‚   - Tool discovery & routing                â”‚\nâ”‚   - Ed25519 authentication                  â”‚\nâ”‚   - Network isolation (global, simpleminer) â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                    â†“â†‘ WebSocket\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚    KADIWebSocketSubsystem (Engine)          â”‚\nâ”‚   - RegisterTools() - 7 MCP tools           â”‚\nâ”‚   - SetToolInvokeCallback()                 â”‚\nâ”‚   - SendToolResult() / SendToolError()      â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                    â†“â†‘\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚         SimpleMiner Game Logic              â”‚\nâ”‚   Agent, AgentCommand, AgentVision          â”‚\nâ”‚   World::OnKADIToolInvoke()                 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n### Entity Hierarchy\n\n```\nEntity (base class)\nâ”œâ”€â”€ Player\nâ”œâ”€â”€ ItemEntity\nâ””â”€â”€ Agent (new) - Autonomous AI-controlled entity\n```\n\n### KADI Connection States (7-State Flow)\n\nBased on Engine's KADIWebSocketSubsystem implementation:\n\n```\nDISCONNECTED â”€â”€Connect()â”€â”€â†’ CONNECTING\n                               â†“ (WebSocket open)\n                          CONNECTED\n                               â†“ (send hello)\n                        AUTHENTICATING\n                               â†“ (Ed25519 signature)\n                        AUTHENTICATED\n                               â†“ (RegisterTools())\n                     REGISTERING_TOOLS\n                               â†“ (tools registered)\n                            READY âœ…\n```\n\n**State Transitions:**\n- `DISCONNECTED`: Not connected to broker\n- `CONNECTING`: WebSocket connection in progress\n- `CONNECTED`: WebSocket open, not authenticated\n- `AUTHENTICATING`: Sending Ed25519 authentication\n- `AUTHENTICATED`: Authentication complete\n- `REGISTERING_TOOLS`: Sending tool registration\n- `READY`: Fully operational, can receive tool calls\n\n### Data Flow: Spawning Agent via KADI\n\n```\nClaude Desktop: \"Spawn a miner agent at (100, 100, 70)\"\n     â†“\nTypeScript Agent (MinerAgent.ts):\n  const simpleminer = await client.load('simpleminer', 'broker');\n  const result = await simpleminer.simpleminer_spawn_agent({\n    name: \"MinerBot\",\n    x: 100, y: 100, z: 70\n  });\n     â†“\nKADI Broker: Route to SimpleMiner (network: simpleminer)\n     â†“\nKADIWebSocketSubsystem: Receive JSON-RPC request\n     â†“\nGame::OnKADIToolInvoke(requestId, \"simpleminer_spawn_agent\", {...})\n     â†“\nWorld::SpawnAgent(\"MinerBot\", Vec3(100, 100, 70))\n     â†“\nAgent* agent = new Agent(\"MinerBot\", agentID, position);\n     â†“\ng_kadiWebSocket->SendToolResult(requestId, {{\"agent_id\", agentID}});\n     â†“\nTypeScript Agent receives result: { agent_id: 1234567890 }\n```\n\n---\n\n## 2. Agent Class Design\n\n### Class Definition\n\n**File:** `Code/Game/Gameplay/Agent.hpp`\n\n```cpp\n#pragma once\n#include \"Entity.hpp\"\n#include \"Game/Framework/Inventory.hpp\"\n#include \"Game/Framework/AgentCommand.hpp\"\n#include <string>\n#include <queue>\n#include <vector>\n\n//-----------------------------------------------------------------------------------------------\n// Agent - AI-controlled entity with inventory and command queue\n//\n// Extends Entity to provide:\n// - 36-slot inventory (same as Player)\n// - Command queue for autonomous actions (MOVE, MINE, PLACE, CRAFT, WAIT)\n// - Vision system for querying nearby blocks\n// - Command execution state machine\n//\n// Design Notes:\n// - Shares mining/placement logic with Player (via World methods)\n// - No goal-based AI (commands come from TypeScript agents via KADI)\n// - Command queue processed one command per Update() call\n// - Non-blocking: Failed commands are removed, agent continues\n//\nclass Agent : public Entity\n{\npublic:\n    // Constructor\n    Agent(std::string const& name, uint64_t agentID, Vec3 const& position);\n    virtual ~Agent();\n\n    // Entity Interface\n    virtual void Update(float deltaSeconds) override;\n    virtual void Render() const override;\n    virtual EntityType GetEntityType() const override { return EntityType::AGENT; }\n\n    // Agent Identity\n    std::string const& GetName() const { return m_agentName; }\n    uint64_t GetAgentID() const { return m_agentID; }\n\n    // Command Queue\n    void QueueCommand(AgentCommand* command);\n    bool HasPendingCommands() const { return !m_commandQueue.empty(); }\n    int GetCommandQueueSize() const { return static_cast<int>(m_commandQueue.size()); }\n    void ClearCommandQueue(); // For emergency stops\n\n    // Inventory Access\n    Inventory& GetInventory() { return m_inventory; }\n    Inventory const& GetInventory() const { return m_inventory; }\n\n    // Vision System\n    struct BlockInfo {\n        IntVec3 blockCoords;  // World coordinates\n        uint16_t blockID;     // BlockRegistry ID\n        std::string blockName; // Human-readable name (e.g., \"Stone\", \"Oak_Log\")\n    };\n\n    std::vector<BlockInfo> GetNearbyBlocks(float radius) const;\n    std::vector<Entity*> GetNearbyEntities(float radius) const;\n\n    // Command Execution State\n    bool IsExecutingCommand() const { return m_currentCommand != nullptr; }\n    std::string GetCurrentCommandType() const;\n\nprivate:\n    // Agent Identity\n    std::string m_agentName;          // Unique name (e.g., \"MinerBot\")\n    uint64_t m_agentID;               // Unique ID from KADI\n\n    // Inventory\n    Inventory m_inventory;            // 36 slots (matches Player)\n\n    // Command System\n    std::queue<AgentCommand*> m_commandQueue;\n    AgentCommand* m_currentCommand = nullptr;\n\n    // Command Execution\n    void ProcessCommandQueue(float deltaSeconds);\n    void ExecuteCurrentCommand(float deltaSeconds);\n    void CompleteCurrentCommand();\n};\n```\n\n### Implementation Details\n\n**File:** `Code/Game/Gameplay/Agent.cpp`\n\n**Key Methods:**\n\n#### Constructor\n```cpp\nAgent::Agent(std::string const& name, uint64_t agentID, Vec3 const& position)\n    : Entity(position)\n    , m_agentName(name)\n    , m_agentID(agentID)\n    , m_inventory(36) // 36 slots, matches Player\n{\n    // Agent rendering: Green wireframe cube (2x2x2 blocks tall)\n    // (Reuse Entity rendering system)\n}\n```\n\n#### Update()\n```cpp\nvoid Agent::Update(float deltaSeconds)\n{\n    Entity::Update(deltaSeconds);  // Physics, collision, etc.\n    ProcessCommandQueue(deltaSeconds);\n}\n\nvoid Agent::ProcessCommandQueue(float deltaSeconds)\n{\n    // If no current command, dequeue next command\n    if (m_currentCommand == nullptr && !m_commandQueue.empty()) {\n        m_currentCommand = m_commandQueue.front();\n        m_commandQueue.pop();\n        m_currentCommand->Start(); // Initialize command state\n    }\n\n    // Execute current command\n    if (m_currentCommand != nullptr) {\n        ExecuteCurrentCommand(deltaSeconds);\n    }\n}\n\nvoid Agent::ExecuteCurrentCommand(float deltaSeconds)\n{\n    eCommandStatus status = m_currentCommand->Execute(deltaSeconds, this);\n\n    if (status == eCommandStatus::COMPLETED) {\n        CompleteCurrentCommand();\n    } else if (status == eCommandStatus::FAILED) {\n        // Log failure and move to next command\n        g_theConsole->PrintString(Rgba8::RED, Stringf(\"Agent '%s': Command failed: %s\",\n            m_agentName.c_str(), m_currentCommand->GetFailureReason().c_str()));\n        CompleteCurrentCommand();\n    }\n    // Status IN_PROGRESS: Continue executing next frame\n}\n\nvoid Agent::CompleteCurrentCommand()\n{\n    delete m_currentCommand;\n    m_currentCommand = nullptr;\n}\n```\n\n#### Vision System\n```cpp\nstd::vector<Agent::BlockInfo> Agent::GetNearbyBlocks(float radius) const\n{\n    std::vector<BlockInfo> blocks;\n\n    // Query all blocks within radius\n    int radiusBlocks = static_cast<int>(radius) + 1;\n    IntVec3 centerCoords = IntVec3(m_position);\n\n    for (int x = -radiusBlocks; x <= radiusBlocks; ++x) {\n        for (int y = -radiusBlocks; y <= radiusBlocks; ++y) {\n            for (int z = -radiusBlocks; z <= radiusBlocks; ++z) {\n                IntVec3 coords = centerCoords + IntVec3(x, y, z);\n\n                // Check distance\n                Vec3 blockCenter = Vec3(coords) + Vec3(0.5f, 0.5f, 0.5f);\n                float dist = GetDistance3D(m_position, blockCenter);\n                if (dist > radius) continue;\n\n                // Get block from World\n                Block block = m_world->GetBlock(coords);\n                if (block.IsAir()) continue;\n\n                BlockInfo info;\n                info.blockCoords = coords;\n                info.blockID = block.GetBlockID();\n                info.blockName = g_blockRegistry->GetBlockName(block.GetBlockID());\n                blocks.push_back(info);\n            }\n        }\n    }\n\n    return blocks;\n}\n\nstd::vector<Entity*> Agent::GetNearbyEntities(float radius) const\n{\n    std::vector<Entity*> entities;\n\n    for (Entity* entity : m_world->GetAllEntities()) {\n        if (entity == this) continue; // Skip self\n\n        float dist = GetDistance3D(m_position, entity->GetPosition());\n        if (dist <= radius) {\n            entities.push_back(entity);\n        }\n    }\n\n    return entities;\n}\n```\n\n---\n\n## 3. Agent Command System\n\n### Command Base Class\n\n**File:** `Code/Game/Framework/AgentCommand.hpp`\n\n```cpp\n#pragma once\n#include \"Engine/Core/Vec3.hpp\"\n#include <string>\n\n// Forward declarations\nclass Agent;\nclass World;\n\n//-----------------------------------------------------------------------------------------------\n// Command Status\nenum class eCommandStatus : uint8_t\n{\n    NOT_STARTED,  // Command not started yet\n    IN_PROGRESS,  // Command actively executing\n    COMPLETED,    // Command successfully finished\n    FAILED        // Command failed (invalid target, unreachable, etc.)\n};\n\n//-----------------------------------------------------------------------------------------------\n// AgentCommand - Abstract base class for agent actions\n//\n// All commands implement:\n// - Start() - Initialize command state\n// - Execute() - Perform one frame of work, return status\n// - GetType() - Return command type as string\n// - GetFailureReason() - Return reason if status == FAILED\n//\nclass AgentCommand\n{\npublic:\n    virtual ~AgentCommand() = default;\n\n    // Command lifecycle\n    virtual void Start() = 0;\n    virtual eCommandStatus Execute(float deltaSeconds, Agent* agent) = 0;\n\n    // Command metadata\n    virtual std::string GetType() const = 0;\n    std::string GetFailureReason() const { return m_failureReason; }\n\nprotected:\n    eCommandStatus m_status = eCommandStatus::NOT_STARTED;\n    std::string m_failureReason;\n};\n```\n\n### Command Implementations\n\n#### 1. MoveCommand\n\n```cpp\nclass MoveCommand : public AgentCommand\n{\npublic:\n    MoveCommand(Vec3 const& targetPosition, float moveSpeed = 4.0f);\n\n    virtual void Start() override;\n    virtual eCommandStatus Execute(float deltaSeconds, Agent* agent) override;\n    virtual std::string GetType() const override { return \"MOVE\"; }\n\nprivate:\n    Vec3 m_targetPosition;\n    float m_moveSpeed; // Blocks per second (Player uses 4.0f)\n\n    static constexpr float ARRIVAL_THRESHOLD = 0.5f; // Within 0.5 blocks\n};\n\n// Implementation\neCommandStatus MoveCommand::Execute(float deltaSeconds, Agent* agent)\n{\n    Vec3 currentPos = agent->GetPosition();\n    Vec3 toTarget = m_targetPosition - currentPos;\n    float distanceRemaining = toTarget.GetLength();\n\n    // Check arrival\n    if (distanceRemaining < ARRIVAL_THRESHOLD) {\n        return eCommandStatus::COMPLETED;\n    }\n\n    // Move towards target\n    Vec3 moveDirection = toTarget.GetNormalized();\n    float moveDistance = m_moveSpeed * deltaSeconds;\n\n    if (moveDistance > distanceRemaining) {\n        moveDistance = distanceRemaining; // Don't overshoot\n    }\n\n    Vec3 newPos = currentPos + (moveDirection * moveDistance);\n    agent->SetPosition(newPos);\n\n    // Check collision (reuse Player physics)\n    if (agent->IsCollidingWithWorld()) {\n        m_failureReason = \"Collision with terrain\";\n        return eCommandStatus::FAILED;\n    }\n\n    return eCommandStatus::IN_PROGRESS;\n}\n```\n\n#### 2. MineCommand\n\n```cpp\nclass MineCommand : public AgentCommand\n{\npublic:\n    MineCommand(IntVec3 const& blockCoords);\n\n    virtual void Start() override;\n    virtual eCommandStatus Execute(float deltaSeconds, Agent* agent) override;\n    virtual std::string GetType() const override { return \"MINE\"; }\n\nprivate:\n    IntVec3 m_blockCoords;\n    float m_miningProgress = 0.0f;  // 0.0 to 1.0\n    float m_miningDuration = 0.0f;  // Seconds (from block definition)\n\n    static constexpr float MAX_MINING_DISTANCE = 5.0f; // Same as Player\n};\n\n// Implementation\nvoid MineCommand::Start()\n{\n    m_status = eCommandStatus::IN_PROGRESS;\n    m_miningProgress = 0.0f;\n}\n\neCommandStatus MineCommand::Execute(float deltaSeconds, Agent* agent)\n{\n    // Check distance\n    Vec3 blockCenter = Vec3(m_blockCoords) + Vec3(0.5f, 0.5f, 0.5f);\n    float distance = GetDistance3D(agent->GetPosition(), blockCenter);\n    if (distance > MAX_MINING_DISTANCE) {\n        m_failureReason = \"Block out of range\";\n        return eCommandStatus::FAILED;\n    }\n\n    // Get block\n    World* world = agent->GetWorld();\n    Block block = world->GetBlock(m_blockCoords);\n    if (block.IsAir()) {\n        m_failureReason = \"Block already mined\";\n        return eCommandStatus::COMPLETED; // Treat as success\n    }\n\n    // Calculate mining duration (if not calculated yet)\n    if (m_miningDuration == 0.0f) {\n        BlockDefinition const& blockDef = g_blockRegistry->GetBlockDefinition(block.GetBlockID());\n        m_miningDuration = blockDef.GetMiningDuration();\n    }\n\n    // Update progress\n    m_miningProgress += deltaSeconds / m_miningDuration;\n\n    if (m_miningProgress >= 1.0f) {\n        // Break block and spawn ItemEntity\n        world->BreakBlock(m_blockCoords, agent->GetPosition());\n        return eCommandStatus::COMPLETED;\n    }\n\n    return eCommandStatus::IN_PROGRESS;\n}\n```\n\n#### 3. PlaceCommand\n\n```cpp\nclass PlaceCommand : public AgentCommand\n{\npublic:\n    PlaceCommand(IntVec3 const& blockCoords, uint16_t itemID);\n\n    virtual void Start() override;\n    virtual eCommandStatus Execute(float deltaSeconds, Agent* agent) override;\n    virtual std::string GetType() const override { return \"PLACE\"; }\n\nprivate:\n    IntVec3 m_blockCoords;\n    uint16_t m_itemID; // ItemRegistry ID (must be a block item)\n\n    static constexpr float MAX_PLACEMENT_DISTANCE = 5.0f;\n};\n\n// Implementation\neCommandStatus PlaceCommand::Execute(float deltaSeconds, Agent* agent)\n{\n    UNUSED(deltaSeconds);\n\n    // Check distance\n    Vec3 blockCenter = Vec3(m_blockCoords) + Vec3(0.5f, 0.5f, 0.5f);\n    float distance = GetDistance3D(agent->GetPosition(), blockCenter);\n    if (distance > MAX_PLACEMENT_DISTANCE) {\n        m_failureReason = \"Block position out of range\";\n        return eCommandStatus::FAILED;\n    }\n\n    // Check agent has the item\n    Inventory& inv = agent->GetInventory();\n    int slotIndex = inv.FindItemSlot(m_itemID);\n    if (slotIndex == -1) {\n        m_failureReason = \"Item not in inventory\";\n        return eCommandStatus::FAILED;\n    }\n\n    // Get corresponding block ID from ItemRegistry\n    ItemDefinition const& itemDef = g_itemRegistry->GetItemDefinition(m_itemID);\n    if (itemDef.GetBlockID() == 0) {\n        m_failureReason = \"Item is not a placeable block\";\n        return eCommandStatus::FAILED;\n    }\n\n    // Attempt placement (reuse Player placement logic)\n    World* world = agent->GetWorld();\n    bool placed = world->PlaceBlock(m_blockCoords, itemDef.GetBlockID());\n\n    if (placed) {\n        // Remove item from inventory\n        inv.RemoveItemFromSlot(slotIndex, 1);\n        return eCommandStatus::COMPLETED;\n    } else {\n        m_failureReason = \"Block placement failed (occupied or invalid)\";\n        return eCommandStatus::FAILED;\n    }\n}\n```\n\n#### 4. CraftCommand\n\n```cpp\nclass CraftCommand : public AgentCommand\n{\npublic:\n    CraftCommand(uint16_t recipeID);\n\n    virtual void Start() override;\n    virtual eCommandStatus Execute(float deltaSeconds, Agent* agent) override;\n    virtual std::string GetType() const override { return \"CRAFT\"; }\n\nprivate:\n    uint16_t m_recipeID; // RecipeRegistry ID\n};\n\n// Implementation (instant crafting, no duration)\neCommandStatus CraftCommand::Execute(float deltaSeconds, Agent* agent)\n{\n    UNUSED(deltaSeconds);\n\n    // Get recipe\n    RecipeDefinition const& recipe = g_recipeRegistry->GetRecipeDefinition(m_recipeID);\n\n    // Check ingredients\n    Inventory& inv = agent->GetInventory();\n    if (!inv.HasIngredients(recipe.GetIngredients())) {\n        m_failureReason = \"Missing ingredients\";\n        return eCommandStatus::FAILED;\n    }\n\n    // Remove ingredients\n    inv.RemoveIngredients(recipe.GetIngredients());\n\n    // Add result\n    ItemStack result = recipe.GetResult();\n    bool added = inv.AddItem(result);\n\n    if (!added) {\n        m_failureReason = \"Inventory full (cannot add result)\";\n        // TODO: Should we return ingredients? (Edge case handling)\n        return eCommandStatus::FAILED;\n    }\n\n    return eCommandStatus::COMPLETED;\n}\n```\n\n#### 5. WaitCommand\n\n```cpp\nclass WaitCommand : public AgentCommand\n{\npublic:\n    WaitCommand(float duration); // Duration in seconds\n\n    virtual void Start() override;\n    virtual eCommandStatus Execute(float deltaSeconds, Agent* agent) override;\n    virtual std::string GetType() const override { return \"WAIT\"; }\n\nprivate:\n    float m_duration;\n    float m_elapsedTime = 0.0f;\n};\n\n// Implementation\nvoid WaitCommand::Start()\n{\n    m_status = eCommandStatus::IN_PROGRESS;\n    m_elapsedTime = 0.0f;\n}\n\neCommandStatus WaitCommand::Execute(float deltaSeconds, Agent* agent)\n{\n    UNUSED(agent);\n\n    m_elapsedTime += deltaSeconds;\n\n    if (m_elapsedTime >= m_duration) {\n        return eCommandStatus::COMPLETED;\n    }\n\n    return eCommandStatus::IN_PROGRESS;\n}\n```\n\n---\n\n## 4. Agent Vision System\n\n### Vision System Design\n\nThe vision system allows agents to query their environment without direct access to World's internal data structures.\n\n**Key Methods:**\n\n```cpp\n// In Agent class\nstd::vector<BlockInfo> GetNearbyBlocks(float radius) const;\nstd::vector<Entity*> GetNearbyEntities(float radius) const;\n```\n\n**BlockInfo Structure:**\n\n```cpp\nstruct BlockInfo {\n    IntVec3 blockCoords;    // World coordinates\n    uint16_t blockID;       // BlockRegistry ID\n    std::string blockName;  // Human-readable name (e.g., \"Stone\", \"Diamond_Ore\")\n};\n```\n\n**Use Case Example:**\n\n```typescript\n// TypeScript Agent: Find nearest diamond ore\nconst visionResult = await simpleminer.simpleminer_get_nearby_blocks({\n  agent_id: agentID,\n  radius: 10.0\n});\n\nconst diamondOre = visionResult.blocks.find(b => b.block_name === \"Diamond_Ore\");\nif (diamondOre) {\n  // Queue MOVE command to diamond ore\n  await simpleminer.simpleminer_queue_command({\n    agent_id: agentID,\n    command_type: \"MOVE\",\n    params: diamondOre.block_coords\n  });\n\n  // Queue MINE command\n  await simpleminer.simpleminer_queue_command({\n    agent_id: agentID,\n    command_type: \"MINE\",\n    params: { block_coords: diamondOre.block_coords }\n  });\n}\n```\n\n---\n\n## 5. KADI WebSocket Integration\n\n### KADIWebSocketSubsystem API\n\nBased on Engine's `KADIWebSocketSubsystem` (see `Engine\\Code\\Engine\\Network\\CLAUDE.md`):\n\n**Key Methods:**\n\n```cpp\n// Lifecycle\nvoid Startup();\nvoid Shutdown();\nvoid BeginFrame();\nvoid EndFrame();\n\n// Connection Management\nvoid Connect(std::string const& brokerUrl, std::string const& publicKey, std::string const& privateKey);\nvoid Disconnect();\nbool IsConnected() const;\neKADIConnectionState GetConnectionState() const;\n\n// Tool Registration (MCP Tools)\nvoid RegisterTools(nlohmann::json const& tools);\nvoid SendToolResult(int requestId, nlohmann::json const& result);\nvoid SendToolError(int requestId, std::string const& errorMessage);\n\n// Event System\nvoid SubscribeToEvents(std::vector<std::string> const& channels);\nvoid PublishEvent(std::string const& channel, nlohmann::json const& data);\n\n// Callback Registration\nvoid SetToolInvokeCallback(KADIToolInvokeCallback callback);\nvoid SetEventDeliveryCallback(KADIEventDeliveryCallback callback);\nvoid SetConnectionStateCallback(KADIConnectionStateCallback callback);\n```\n\n**Callback Types:**\n\n```cpp\nusing KADIToolInvokeCallback = std::function<void(int requestId, std::string const& toolName, nlohmann::json const& arguments)>;\nusing KADIEventDeliveryCallback = std::function<void(std::string const& channel, nlohmann::json const& data)>;\nusing KADIConnectionStateCallback = std::function<void(eKADIConnectionState oldState, eKADIConnectionState newState)>;\n```\n\n### MCP Tool Registration\n\n**File:** `Code/Game/Gameplay/Game.cpp` (Startup)\n\n**Tool Naming Convention:** `lowercase_with_underscores` (e.g., `simpleminer_spawn_agent`)\n\n```cpp\nvoid Game::InitializeKADI()\n{\n    // Get KADIWebSocketSubsystem from Engine\n    g_kadiWebSocket = g_theEngine->GetKADIWebSocketSubsystem();\n    if (!g_kadiWebSocket) {\n        g_theConsole->PrintString(Rgba8::RED, \"KADI WebSocket subsystem not available\");\n        return;\n    }\n\n    // Set tool invoke callback\n    g_kadiWebSocket->SetToolInvokeCallback([this](int requestId, std::string const& toolName, nlohmann::json const& arguments) {\n        this->OnKADIToolInvoke(requestId, toolName, arguments);\n    });\n\n    // Register 7 MCP tools\n    nlohmann::json tools = nlohmann::json::array();\n\n    // Tool 1: simpleminer_spawn_agent\n    tools.push_back({\n        {\"name\", \"simpleminer_spawn_agent\"},\n        {\"description\", \"Spawn a new AI agent at specified position\"},\n        {\"inputSchema\", {\n            {\"type\", \"object\"},\n            {\"properties\", {\n                {\"name\", {{\"type\", \"string\"}, {\"description\", \"Agent name (e.g., 'MinerBot')\"}}},\n                {\"x\", {{\"type\", \"number\"}, {\"description\", \"X world coordinate\"}}},\n                {\"y\", {{\"type\", \"number\"}, {\"description\", \"Y world coordinate\"}}},\n                {\"z\", {{\"type\", \"number\"}, {\"description\", \"Z world coordinate\"}}}\n            }},\n            {\"required\", nlohmann::json::array({\"name\", \"x\", \"y\", \"z\"})}\n        }}\n    });\n\n    // Tool 2: simpleminer_queue_command\n    tools.push_back({\n        {\"name\", \"simpleminer_queue_command\"},\n        {\"description\", \"Queue a command for an agent (MOVE, MINE, PLACE, CRAFT, WAIT)\"},\n        {\"inputSchema\", {\n            {\"type\", \"object\"},\n            {\"properties\", {\n                {\"agent_id\", {{\"type\", \"number\"}, {\"description\", \"Agent ID\"}}},\n                {\"command_type\", {{\"type\", \"string\"}, {\"enum\", nlohmann::json::array({\"MOVE\", \"MINE\", \"PLACE\", \"CRAFT\", \"WAIT\"})}}},\n                {\"params\", {{\"type\", \"object\"}, {\"description\", \"Command-specific parameters\"}}}\n            }},\n            {\"required\", nlohmann::json::array({\"agent_id\", \"command_type\", \"params\"})}\n        }}\n    });\n\n    // Tool 3: simpleminer_get_nearby_blocks\n    tools.push_back({\n        {\"name\", \"simpleminer_get_nearby_blocks\"},\n        {\"description\", \"Query blocks near an agent\"},\n        {\"inputSchema\", {\n            {\"type\", \"object\"},\n            {\"properties\", {\n                {\"agent_id\", {{\"type\", \"number\"}}},\n                {\"radius\", {{\"type\", \"number\"}, {\"description\", \"Search radius in blocks\"}}}\n            }},\n            {\"required\", nlohmann::json::array({\"agent_id\", \"radius\"})}\n        }}\n    });\n\n    // Tool 4: simpleminer_get_agent_inventory\n    tools.push_back({\n        {\"name\", \"simpleminer_get_agent_inventory\"},\n        {\"description\", \"Get agent's inventory contents\"},\n        {\"inputSchema\", {\n            {\"type\", \"object\"},\n            {\"properties\", {\n                {\"agent_id\", {{\"type\", \"number\"}}}\n            }},\n            {\"required\", nlohmann::json::array({\"agent_id\"})}\n        }}\n    });\n\n    // Tool 5: simpleminer_get_agent_status\n    tools.push_back({\n        {\"name\", \"simpleminer_get_agent_status\"},\n        {\"description\", \"Get agent position, current command, queue size\"},\n        {\"inputSchema\", {\n            {\"type\", \"object\"},\n            {\"properties\", {\n                {\"agent_id\", {{\"type\", \"number\"}}}\n            }},\n            {\"required\", nlohmann::json::array({\"agent_id\"})}\n        }}\n    });\n\n    // Tool 6: simpleminer_list_agents\n    tools.push_back({\n        {\"name\", \"simpleminer_list_agents\"},\n        {\"description\", \"List all active agents in the world\"},\n        {\"inputSchema\", {\n            {\"type\", \"object\"},\n            {\"properties\", {}}\n        }}\n    });\n\n    // Tool 7: simpleminer_despawn_agent\n    tools.push_back({\n        {\"name\", \"simpleminer_despawn_agent\"},\n        {\"description\", \"Remove an agent from the world\"},\n        {\"inputSchema\", {\n            {\"type\", \"object\"},\n            {\"properties\", {\n                {\"agent_id\", {{\"type\", \"number\"}}}\n            }},\n            {\"required\", nlohmann::json::array({\"agent_id\"})}\n        }}\n    });\n\n    // Register tools with broker\n    g_kadiWebSocket->RegisterTools(tools);\n\n    // Generate Ed25519 key pair at runtime (following ProtogameJS3D pattern)\n    sEd25519KeyPair keyPair;\n    if (!KADIAuthenticationUtility::GenerateKeyPair(keyPair)) {\n        g_theConsole->PrintString(Rgba8::RED, \"KADI: Failed to generate Ed25519 key pair\");\n        return;\n    }\n\n    // Convert keys to base64 strings for broker authentication\n    std::string publicKey = keyPair.GetPublicKeyBase64();\n    std::string privateKey = keyPair.GetPrivateKeyBase64();\n\n    g_theConsole->PrintString(Rgba8::CYAN, \"KADI: Ed25519 key pair generated successfully\");\n\n    // Connect to KADI broker\n    std::string brokerUrl = \"ws://localhost:8080/ws\";\n    g_kadiWebSocket->Connect(brokerUrl, publicKey, privateKey);\n\n    g_theConsole->PrintString(Rgba8::GREEN, \"KADI WebSocket initialized, connecting to broker...\");\n}\n```\n\n### Tool Invocation Handler\n\n**File:** `Code/Game/Gameplay/Game.cpp`\n\n```cpp\nvoid Game::OnKADIToolInvoke(int requestId, std::string const& toolName, nlohmann::json const& arguments)\n{\n    // Dispatch to appropriate handler\n    if (toolName == \"simpleminer_spawn_agent\") {\n        HandleSpawnAgent(requestId, arguments);\n    }\n    else if (toolName == \"simpleminer_queue_command\") {\n        HandleQueueCommand(requestId, arguments);\n    }\n    else if (toolName == \"simpleminer_get_nearby_blocks\") {\n        HandleGetNearbyBlocks(requestId, arguments);\n    }\n    else if (toolName == \"simpleminer_get_agent_inventory\") {\n        HandleGetAgentInventory(requestId, arguments);\n    }\n    else if (toolName == \"simpleminer_get_agent_status\") {\n        HandleGetAgentStatus(requestId, arguments);\n    }\n    else if (toolName == \"simpleminer_list_agents\") {\n        HandleListAgents(requestId, arguments);\n    }\n    else if (toolName == \"simpleminer_despawn_agent\") {\n        HandleDespawnAgent(requestId, arguments);\n    }\n    else {\n        // Unknown tool\n        g_kadiWebSocket->SendToolError(requestId, \"Unknown tool: \" + toolName);\n    }\n}\n\nvoid Game::HandleSpawnAgent(int requestId, nlohmann::json const& arguments)\n{\n    try {\n        // Parse arguments\n        std::string name = arguments[\"name\"];\n        float x = arguments[\"x\"];\n        float y = arguments[\"y\"];\n        float z = arguments[\"z\"];\n\n        // Spawn agent\n        uint64_t agentID = m_world->SpawnAgent(name, Vec3(x, y, z));\n\n        // Send result\n        nlohmann::json result = {\n            {\"agent_id\", agentID},\n            {\"position\", {{\"x\", x}, {\"y\", y}, {\"z\", z}}},\n            {\"name\", name}\n        };\n        g_kadiWebSocket->SendToolResult(requestId, result);\n    }\n    catch (std::exception const& e) {\n        g_kadiWebSocket->SendToolError(requestId, std::string(\"Failed to spawn agent: \") + e.what());\n    }\n}\n\nvoid Game::HandleQueueCommand(int requestId, nlohmann::json const& arguments)\n{\n    try {\n        uint64_t agentID = arguments[\"agent_id\"];\n        std::string commandType = arguments[\"command_type\"];\n        nlohmann::json params = arguments[\"params\"];\n\n        // Find agent\n        Agent* agent = m_world->FindAgentByID(agentID);\n        if (!agent) {\n            g_kadiWebSocket->SendToolError(requestId, \"Agent not found\");\n            return;\n        }\n\n        // Create command based on type\n        AgentCommand* command = nullptr;\n\n        if (commandType == \"MOVE\") {\n            Vec3 target(params[\"x\"], params[\"y\"], params[\"z\"]);\n            command = new MoveCommand(target);\n        }\n        else if (commandType == \"MINE\") {\n            IntVec3 coords(params[\"x\"], params[\"y\"], params[\"z\"]);\n            command = new MineCommand(coords);\n        }\n        else if (commandType == \"PLACE\") {\n            IntVec3 coords(params[\"x\"], params[\"y\"], params[\"z\"]);\n            uint16_t itemID = params[\"item_id\"];\n            command = new PlaceCommand(coords, itemID);\n        }\n        else if (commandType == \"CRAFT\") {\n            uint16_t recipeID = params[\"recipe_id\"];\n            command = new CraftCommand(recipeID);\n        }\n        else if (commandType == \"WAIT\") {\n            float duration = params[\"duration\"];\n            command = new WaitCommand(duration);\n        }\n        else {\n            g_kadiWebSocket->SendToolError(requestId, \"Unknown command type: \" + commandType);\n            return;\n        }\n\n        // Queue command\n        agent->QueueCommand(command);\n\n        // Send result\n        nlohmann::json result = {\n            {\"success\", true},\n            {\"queue_size\", agent->GetCommandQueueSize()}\n        };\n        g_kadiWebSocket->SendToolResult(requestId, result);\n    }\n    catch (std::exception const& e) {\n        g_kadiWebSocket->SendToolError(requestId, std::string(\"Failed to queue command: \") + e.what());\n    }\n}\n\nvoid Game::HandleGetNearbyBlocks(int requestId, nlohmann::json const& arguments)\n{\n    try {\n        uint64_t agentID = arguments[\"agent_id\"];\n        float radius = arguments[\"radius\"];\n\n        Agent* agent = m_world->FindAgentByID(agentID);\n        if (!agent) {\n            g_kadiWebSocket->SendToolError(requestId, \"Agent not found\");\n            return;\n        }\n\n        // Get nearby blocks\n        std::vector<Agent::BlockInfo> blocks = agent->GetNearbyBlocks(radius);\n\n        // Convert to JSON\n        nlohmann::json blocksJson = nlohmann::json::array();\n        for (auto const& block : blocks) {\n            blocksJson.push_back({\n                {\"block_coords\", {{\"x\", block.blockCoords.x}, {\"y\", block.blockCoords.y}, {\"z\", block.blockCoords.z}}},\n                {\"block_id\", block.blockID},\n                {\"block_name\", block.blockName}\n            });\n        }\n\n        nlohmann::json result = {\n            {\"blocks\", blocksJson},\n            {\"count\", blocks.size()}\n        };\n        g_kadiWebSocket->SendToolResult(requestId, result);\n    }\n    catch (std::exception const& e) {\n        g_kadiWebSocket->SendToolError(requestId, std::string(\"Failed to get nearby blocks: \") + e.what());\n    }\n}\n\n// Similar implementations for HandleGetAgentInventory, HandleGetAgentStatus, HandleListAgents, HandleDespawnAgent\n```\n\n---\n\n## 6. TypeScript Agent Framework\n\n### Example: MinerAgent\n\n**File:** `agents/simpleminer/MinerAgent.ts`\n\nBased on `template-agent-typescript` structure:\n\n```typescript\n/**\n * MinerAgent - Autonomous mining agent for SimpleMiner\n *\n * Capabilities:\n * - Find nearest diamond ore using vision system\n * - Navigate to ore location\n * - Mine ore and collect drops\n * - Return to home position\n */\n\nimport 'dotenv/config';\nimport { KadiClient } from '@kadi.build/core';\n\n// Configuration\nconst BROKER_URL = process.env.KADI_BROKER_URL || 'ws://localhost:8080';\nconst AGENT_NAME = 'miner-agent';\nconst NETWORKS = ['global', 'simpleminer'];\n\n// Mining constants\nconst VISION_RADIUS = 20.0;\nconst HOME_POSITION = { x: 0, y: 0, z: 70 };\nconst MINING_TARGETS = ['Diamond_Ore', 'Iron_Ore', 'Coal_Ore'];\n\nasync function main() {\n    // Create KADI client\n    const client = new KadiClient({\n        name: AGENT_NAME,\n        broker: BROKER_URL,\n        networks: NETWORKS\n    });\n\n    // Connect to broker\n    await client.connect();\n    console.log(`âœ… Connected to KADI broker at ${BROKER_URL}`);\n\n    // Load SimpleMiner tools\n    const simpleminer = await client.load('simpleminer', 'broker');\n    console.log(`âœ… Loaded SimpleMiner tools`);\n\n    // Spawn agent in game\n    const spawnResult = await simpleminer.simpleminer_spawn_agent({\n        name: 'MinerBot',\n        x: HOME_POSITION.x,\n        y: HOME_POSITION.y,\n        z: HOME_POSITION.z\n    });\n\n    const agentID = spawnResult.agent_id;\n    console.log(`âœ… Spawned agent with ID: ${agentID}`);\n\n    // Main mining loop\n    while (true) {\n        try {\n            // Get nearby blocks\n            const visionResult = await simpleminer.simpleminer_get_nearby_blocks({\n                agent_id: agentID,\n                radius: VISION_RADIUS\n            });\n\n            // Find nearest valuable ore\n            const targetOre = visionResult.blocks.find((block: any) =>\n                MINING_TARGETS.includes(block.block_name)\n            );\n\n            if (targetOre) {\n                console.log(`ğŸ¯ Found ${targetOre.block_name} at (${targetOre.block_coords.x}, ${targetOre.block_coords.y}, ${targetOre.block_coords.z})`);\n\n                // Move to ore\n                await simpleminer.simpleminer_queue_command({\n                    agent_id: agentID,\n                    command_type: 'MOVE',\n                    params: {\n                        x: targetOre.block_coords.x + 0.5,\n                        y: targetOre.block_coords.y + 0.5,\n                        z: targetOre.block_coords.z\n                    }\n                });\n\n                // Mine ore\n                await simpleminer.simpleminer_queue_command({\n                    agent_id: agentID,\n                    command_type: 'MINE',\n                    params: {\n                        x: targetOre.block_coords.x,\n                        y: targetOre.block_coords.y,\n                        z: targetOre.block_coords.z\n                    }\n                });\n\n                console.log(`â›ï¸ Queued mining commands`);\n            } else {\n                console.log(`ğŸ” No ores found nearby, waiting...`);\n\n                // Wait 5 seconds before next scan\n                await simpleminer.simpleminer_queue_command({\n                    agent_id: agentID,\n                    command_type: 'WAIT',\n                    params: { duration: 5.0 }\n                });\n            }\n\n            // Check agent status\n            const status = await simpleminer.simpleminer_get_agent_status({\n                agent_id: agentID\n            });\n\n            console.log(`ğŸ“Š Agent status: Position (${status.position.x}, ${status.position.y}, ${status.position.z}), Queue: ${status.queue_size} commands`);\n\n            // Wait for commands to execute\n            await new Promise(resolve => setTimeout(resolve, 3000));\n\n        } catch (error) {\n            console.error(`âŒ Error: ${error}`);\n            await new Promise(resolve => setTimeout(resolve, 5000));\n        }\n    }\n}\n\n// Graceful shutdown\nprocess.on('SIGINT', async () => {\n    console.log('\\nğŸ›‘ Shutting down MinerAgent...');\n    process.exit(0);\n});\n\nmain().catch(console.error);\n```\n\n### Example: BuilderAgent\n\n**File:** `agents/simpleminer/BuilderAgent.ts`\n\n```typescript\n/**\n * BuilderAgent - Automated construction agent\n *\n * Capabilities:\n * - Build simple structures (walls, floors, pillars)\n * - Manage inventory for construction materials\n * - Follow blueprint commands from Claude Desktop\n */\n\nimport 'dotenv/config';\nimport { KadiClient } from '@kadi.build/core';\n\nconst BROKER_URL = process.env.KADI_BROKER_URL || 'ws://localhost:8080';\nconst AGENT_NAME = 'builder-agent';\n\ninterface BuildTask {\n    type: 'wall' | 'floor' | 'pillar';\n    material: string; // e.g., \"Stone\", \"Oak_Planks\"\n    start: { x: number; y: number; z: number };\n    end: { x: number; y: number; z: number };\n}\n\nasync function buildWall(simpleminer: any, agentID: number, task: BuildTask) {\n    const { start, end, material } = task;\n\n    // Get material item ID (simplified - would query ItemRegistry in production)\n    const materialID = getMaterialID(material);\n\n    // Build wall column by column\n    for (let x = start.x; x <= end.x; x++) {\n        for (let z = start.z; z <= end.z; z++) {\n            // Move to position\n            await simpleminer.simpleminer_queue_command({\n                agent_id: agentID,\n                command_type: 'MOVE',\n                params: { x: x + 0.5, y: start.y, z: z }\n            });\n\n            // Place block\n            await simpleminer.simpleminer_queue_command({\n                agent_id: agentID,\n                command_type: 'PLACE',\n                params: { x, y: start.y, z, item_id: materialID }\n            });\n        }\n    }\n\n    console.log(`âœ… Wall built from (${start.x}, ${start.y}, ${start.z}) to (${end.x}, ${end.y}, ${end.z})`);\n}\n\nfunction getMaterialID(materialName: string): number {\n    // Map material names to item IDs\n    // In production, this would query SimpleMiner's ItemRegistry via MCP tool\n    const materials: { [key: string]: number } = {\n        'Stone': 1,\n        'Dirt': 2,\n        'Oak_Planks': 10,\n        'Cobblestone': 15\n    };\n    return materials[materialName] || 1;\n}\n\n// Main function would set up similar pattern to MinerAgent\nasync function main() {\n    const client = new KadiClient({\n        name: AGENT_NAME,\n        broker: BROKER_URL,\n        networks: ['global', 'simpleminer']\n    });\n\n    await client.connect();\n    console.log(`âœ… BuilderAgent connected to KADI broker`);\n\n    const simpleminer = await client.load('simpleminer', 'broker');\n\n    // Spawn builder agent\n    const spawnResult = await simpleminer.simpleminer_spawn_agent({\n        name: 'BuilderBot',\n        x: 0, y: 0, z: 70\n    });\n\n    const agentID = spawnResult.agent_id;\n    console.log(`âœ… Spawned BuilderBot with ID: ${agentID}`);\n\n    // Example: Build a simple wall\n    await buildWall(simpleminer, agentID, {\n        type: 'wall',\n        material: 'Stone',\n        start: { x: 10, y: 70, z: 10 },\n        end: { x: 20, y: 70, z: 10 }\n    });\n}\n\nmain().catch(console.error);\n```\n\n---\n\n## 7. Data Flow Diagrams\n\n### Spawning Agent Flow\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  Claude Desktop    â”‚ User: \"Spawn MinerBot at (100, 100, 70)\"\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n          â†“ (Claude API processes request)\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ TypeScript Agent   â”‚ MinerAgent.ts calls:\nâ”‚  (MinerAgent.ts)   â”‚ simpleminer.simpleminer_spawn_agent({name, x, y, z})\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n          â†“ (KadiClient sends JSON-RPC request)\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚   KADI Broker      â”‚ Routes to SimpleMiner (network: simpleminer)\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n          â†“ (WebSocket JSON-RPC message)\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ KADIWebSocketSub   â”‚ Receives request, parses JSON\nâ”‚     (Engine)       â”‚ Invokes SetToolInvokeCallback\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n          â†“\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Game::OnKADI       â”‚ OnKADIToolInvoke(requestId, \"simpleminer_spawn_agent\", args)\nâ”‚   ToolInvoke       â”‚ Dispatches to HandleSpawnAgent()\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n          â†“\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  World::           â”‚ SpawnAgent(name, position)\nâ”‚  SpawnAgent        â”‚ Creates new Agent* entity\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n          â†“\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  Agent*            â”‚ new Agent(name, agentID, position)\nâ”‚  Constructor       â”‚ Initialize inventory, command queue\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n          â†“\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Game::             â”‚ SendToolResult(requestId, {agent_id: 1234})\nâ”‚ SendToolResult     â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n          â†“ (WebSocket response)\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚   KADI Broker      â”‚ Routes response to TypeScript Agent\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n          â†“\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ TypeScript Agent   â”‚ Receives { agent_id: 1234 }\nâ”‚  (MinerAgent.ts)   â”‚ Stores agentID for future commands\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n### Command Execution Flow\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ TypeScript Agent   â”‚ Calls: simpleminer.simpleminer_queue_command({\nâ”‚  (MinerAgent.ts)   â”‚   agent_id: 1234,\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   command_type: \"MINE\",\n          â†“              params: {x: 105, y: 100, z: 70}\n          â†“            })\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚   KADI Broker      â”‚ Routes to SimpleMiner\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n          â†“\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Game::             â”‚ HandleQueueCommand(requestId, args)\nâ”‚ OnKADIToolInvoke   â”‚ Finds agent by ID\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ Creates MineCommand(IntVec3(105, 100, 70))\n          â†“\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  Agent::           â”‚ QueueCommand(command)\nâ”‚  QueueCommand      â”‚ Adds to m_commandQueue\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n          â†“\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Game::             â”‚ SendToolResult(requestId, {success: true})\nâ”‚ SendToolResult     â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n(Later, during Update loop...)\n\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  Agent::Update     â”‚ Calls ProcessCommandQueue(deltaSeconds)\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n          â†“\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  Agent::           â”‚ If no current command, dequeue next\nâ”‚  ProcessCommand    â”‚ m_currentCommand = m_commandQueue.front()\nâ”‚  Queue             â”‚ m_currentCommand->Start()\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n          â†“\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  MineCommand::     â”‚ Execute(deltaSeconds, agent)\nâ”‚  Execute           â”‚ Increment m_miningProgress\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ If progress >= 1.0:\n          â†“              - World::BreakBlock()\n          â†“              - return COMPLETED\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  Agent::           â”‚ If status == COMPLETED:\nâ”‚  ExecuteCommand    â”‚   CompleteCurrentCommand()\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   delete m_currentCommand\n          â†“              m_currentCommand = nullptr\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  Next Update()     â”‚ Dequeue next command from queue\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n### Vision System Flow\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ TypeScript Agent   â”‚ Calls: simpleminer.simpleminer_get_nearby_blocks({\nâ”‚  (MinerAgent.ts)   â”‚   agent_id: 1234,\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   radius: 20.0\n          â†“            })\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚   KADI Broker      â”‚ Routes to SimpleMiner\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n          â†“\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Game::             â”‚ HandleGetNearbyBlocks(requestId, args)\nâ”‚ OnKADIToolInvoke   â”‚ Finds agent by ID\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ Calls agent->GetNearbyBlocks(radius)\n          â†“\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  Agent::           â”‚ GetNearbyBlocks(20.0)\nâ”‚  GetNearbyBlocks   â”‚ Iterate all blocks within 20 block radius\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ For each block:\n          â†“              - Check distance\n          â†“              - Get Block from World\n          â†“              - Query BlockRegistry for name\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  Return            â”‚ std::vector<BlockInfo>\nâ”‚  BlockInfo[]       â”‚ Each entry: {coords, blockID, blockName}\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n          â†“\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Game::             â”‚ Convert to JSON array\nâ”‚ Handle...Blocks    â”‚ SendToolResult(requestId, {blocks: [...], count: 42})\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n          â†“\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ TypeScript Agent   â”‚ Receives { blocks: [{block_name: \"Diamond_Ore\", ...}], count: 42 }\nâ”‚  (MinerAgent.ts)   â”‚ Find nearest Diamond_Ore\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ Queue MOVE and MINE commands\n```\n\n---\n\n## 8. Implementation Strategy\n\n### Phase 1: Agent Entity and Command System (Week 4, Days 1-2)\n\n**Tasks:**\n\n1. **Create Agent class** (`Agent.hpp`, `Agent.cpp`)\n   - Extend Entity base class\n   - Add inventory (36 slots)\n   - Add command queue (std::queue<AgentCommand*>)\n   - Implement Update() with command processing\n   - Implement Render() (green wireframe cube)\n\n2. **Create AgentCommand base class and implementations**\n   - `AgentCommand.hpp` - Base class with virtual Execute()\n   - `MoveCommand` - Navigate to position\n   - `MineCommand` - Progressive block breaking\n   - `PlaceCommand` - Block placement with inventory check\n   - `CraftCommand` - Recipe execution\n   - `WaitCommand` - Timer-based delay\n\n3. **Add Agent vision system**\n   - `GetNearbyBlocks(radius)` - Query blocks within radius\n   - `GetNearbyEntities(radius)` - Query entities within radius\n\n4. **Update World class**\n   - `SpawnAgent(name, position)` â†’ `uint64_t agentID`\n   - `FindAgentByID(agentID)` â†’ `Agent*`\n   - `DespawnAgent(agentID)` - Remove from entity list\n   - Track agents in `std::map<uint64_t, Agent*> m_agents`\n\n**Testing:**\n- Spawn agent via console command: `/spawn_agent MinerBot 100 100 70`\n- Queue commands via console: `/queue_command 1234 MOVE 105 100 70`\n- Verify command execution (agent moves to target)\n\n---\n\n### Phase 2: KADI WebSocket Integration (Week 4, Days 3-4)\n\n**Tasks:**\n\n1. **Initialize KADIWebSocketSubsystem in Game::Startup()**\n   - Get subsystem from Engine: `g_theEngine->GetKADIWebSocketSubsystem()`\n   - Set tool invoke callback: `SetToolInvokeCallback(...)`\n   - Generate Ed25519 key pair at runtime: `KADIAuthenticationUtility::GenerateKeyPair()`\n   - Connect to broker: `Connect(\"ws://localhost:8080/ws\", publicKey, privateKey)`\n\n2. **Register 7 MCP tools**\n   - Create nlohmann::json array with tool schemas\n   - Call `RegisterTools(tools)`\n   - Tools:\n     1. `simpleminer_spawn_agent`\n     2. `simpleminer_queue_command`\n     3. `simpleminer_get_nearby_blocks`\n     4. `simpleminer_get_agent_inventory`\n     5. `simpleminer_get_agent_status`\n     6. `simpleminer_list_agents`\n     7. `simpleminer_despawn_agent`\n\n3. **Implement tool handlers**\n   - `Game::OnKADIToolInvoke(requestId, toolName, arguments)`\n   - Dispatch to 7 handler functions:\n     - `HandleSpawnAgent()` - World::SpawnAgent(), send result\n     - `HandleQueueCommand()` - Create command, queue, send result\n     - `HandleGetNearbyBlocks()` - agent->GetNearbyBlocks(), convert to JSON\n     - `HandleGetAgentInventory()` - Serialize inventory to JSON\n     - `HandleGetAgentStatus()` - Return position, current command, queue size\n     - `HandleListAgents()` - List all active agents\n     - `HandleDespawnAgent()` - World::DespawnAgent(), send confirmation\n\n4. **Handle connection states**\n   - Monitor eKADIConnectionState transitions\n   - Print status messages (CONNECTED, AUTHENTICATED, READY)\n   - Handle disconnections gracefully (don't crash game)\n\n**Testing:**\n- Manually send JSON-RPC request via WebSocket client\n- Verify tool registration appears in KADI broker dashboard\n- Test spawning agent via KADI tool call\n- Test queuing commands via KADI tool call\n\n---\n\n### Phase 3: TypeScript Agent Framework (Week 4, Days 5-7)\n\n**Tasks:**\n\n1. **Set up TypeScript agent project**\n   - Copy `template-agent-typescript` structure\n   - Create `agents/simpleminer/` directory\n   - Install dependencies: `@kadi.build/core`, `dotenv`\n   - Configure `.env` file with `KADI_BROKER_URL` and `KADI_NETWORK`\n\n2. **Implement MinerAgent.ts**\n   - Connect to KADI broker using KadiClient\n   - Load SimpleMiner tools: `client.load('simpleminer', 'broker')`\n   - Spawn agent: `simpleminer.simpleminer_spawn_agent({...})`\n   - Implement mining loop:\n     - Get nearby blocks\n     - Find diamond ore\n     - Queue MOVE command\n     - Queue MINE command\n     - Wait for execution\n   - Add error handling and logging\n\n3. **Implement BuilderAgent.ts**\n   - Similar setup to MinerAgent\n   - Implement `buildWall()` function\n   - Queue PLACE commands in sequence\n   - Manage inventory (check material availability)\n\n4. **Create agent deployment script**\n   - Deploy to DigitalOcean droplet (or run locally for testing)\n   - Set up systemd service for auto-restart\n   - Configure environment variables\n\n5. **Test end-to-end flow**\n   - Claude Desktop â†’ TypeScript Agent â†’ KADI Broker â†’ SimpleMiner â†’ Agent execution\n   - Verify agent spawns, moves, mines blocks\n   - Verify vision system returns nearby blocks\n   - Verify inventory updates after mining\n\n**Testing:**\n- Run MinerAgent.ts locally: `npm run dev`\n- Ask Claude Desktop: \"Spawn a mining agent and find diamond ore\"\n- Verify agent appears in SimpleMiner world\n- Verify agent moves to ore and mines it\n- Verify TypeScript logs show successful execution\n\n---\n\n### Phase 4: Integration and Polish (Week 4, Day 7)\n\n**Tasks:**\n\n1. **Error handling improvements**\n   - Handle agent not found errors gracefully\n   - Handle invalid command parameters (out of range, missing items)\n   - Add timeout handling for stuck commands\n\n2. **Performance optimization**\n   - Limit vision system queries (cache results for 1 second)\n   - Limit command queue size (max 100 commands)\n   - Throttle KADI message rate (max 10 requests/second)\n\n3. **Documentation**\n   - Write `agents/simpleminer/README.md` with setup instructions\n   - Document MCP tool schemas\n   - Add JSDoc comments to TypeScript agents\n\n4. **Final testing**\n   - Test all 7 MCP tools\n   - Test all 5 command types\n   - Test error cases (invalid agent ID, out of range, etc.)\n   - Test concurrent TypeScript agents (MinerAgent + BuilderAgent)\n\n---\n\n### Implementation Files Checklist\n\n**New Files:**\n\n```\nCode/Game/Gameplay/Agent.hpp                     # Agent entity class\nCode/Game/Gameplay/Agent.cpp                     # Agent implementation\nCode/Game/Framework/AgentCommand.hpp             # Command base class + implementations\nCode/Game/Framework/AgentCommand.cpp             # Command implementations\nagents/simpleminer/MinerAgent.ts                 # TypeScript mining agent\nagents/simpleminer/BuilderAgent.ts               # TypeScript building agent\nagents/simpleminer/package.json                  # TypeScript dependencies\nagents/simpleminer/.env.template                 # Environment config template\nagents/simpleminer/README.md                     # Setup documentation\n```\n\n**Modified Files:**\n\n```\nCode/Game/Gameplay/Game.hpp                      # Add KADI initialization\nCode/Game/Gameplay/Game.cpp                      # Implement tool handlers\nCode/Game/Gameplay/World.hpp                     # Add SpawnAgent, FindAgentByID\nCode/Game/Gameplay/World.cpp                     # Agent management\nCode/Game/Framework/GameCommon.hpp               # Add Agent-related constants\n.gitignore                                       # Ignore kadi_private.key\n```\n\n---\n\n### Dependencies and Prerequisites\n\n**Prerequisites from A7-Core:**\n- âœ… Registry<T> template (BlockRegistry, ItemRegistry, RecipeRegistry)\n- âœ… Inventory class with 36-slot storage\n- âœ… ItemStack structure (itemID, quantity, durability)\n- âœ… ItemEntity with magnetic pickup\n- âœ… World::BreakBlock() - Progressive mining logic\n- âœ… World::PlaceBlock() - Block placement validation\n- âœ… RecipeDefinition with GetIngredients() and GetResult()\n\n**External Dependencies:**\n- âœ… Engine KADIWebSocketSubsystem (already implemented in Engine)\n- âœ… KADI Broker running at `ws://localhost:8080` (separate process)\n- âœ… nlohmann/json library (already in Engine/Code/ThirdParty/json/)\n- â³ @kadi.build/core npm package (for TypeScript agents)\n- â³ template-agent-typescript repository (reference implementation)\n\n---\n\n## Conclusion\n\nThis revised design document provides a complete technical architecture for A7-AI's AI agent framework, aligned with the ProtogameJS3D reference implementation and Engine's KADIWebSocketSubsystem. Key revisions include:\n\n1. âœ… **Naming Corrections:**\n   - Renamed `AIAgent` â†’ `Agent` throughout\n   - Changed MCP tool naming from `SimpleMiner_Spawn_Agent` â†’ `simpleminer_spawn_agent`\n\n2. âœ… **Architecture Alignment:**\n   - Broker-centralized pattern (no MCP spawning in game code)\n   - Ed25519 authentication with public/private keys\n   - 7-state connection flow (DISCONNECTED â†’ READY)\n   - Tool registration via nlohmann::json schemas\n\n3. âœ… **TypeScript Integration:**\n   - KadiClient usage pattern from template-agent-typescript\n   - Zod schema validation (handled by broker)\n   - Event-driven architecture support\n   - Cross-language tool loading (`client.load()`)\n\nThe implementation follows SOLID principles, reuses existing Player logic for mining/placement, and provides a clean separation between game logic and AI control. The design is ready for approval and implementation in Week 4 of Assignment 7.\n\n**Estimated Implementation Time:** 7 days (Week 4)\n**Lines of Code:** ~2,000 lines (C++ Agent framework) + ~500 lines (TypeScript agents)\n**Testing Time:** 2 days (integrated with A7-Core and A7-UI testing)\n",
  "fileStats": {
    "size": 58609,
    "lines": 1711,
    "lastModified": "2025-11-29T04:37:50.869Z"
  },
  "comments": []
}