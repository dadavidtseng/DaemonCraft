{
  "id": "snapshot_1764294263365_h2buyy1k4",
  "approvalId": "approval_1764294263321_o6k9ca5k5",
  "approvalTitle": "A7-Core design.md - Foundation Systems Architecture",
  "version": 1,
  "timestamp": "2025-11-28T01:44:23.365Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Assignment 7-Core: Design Document\r\n# Foundation Systems (Registry, Inventory, Mining, Placement)\r\n\r\n**Version:** 1.0\r\n**Date:** 2025-11-27\r\n**Status:** Design Phase\r\n**Dependencies:** None (first spec in A7 sequence)\r\n\r\n---\r\n\r\n## Executive Summary\r\n\r\nThis design document provides the technical architecture for A7-Core's implementation of foundational gameplay systems. The design covers:\r\n\r\n1. **Rendering Bug Fix** - Fix hidden surface removal at chunk boundaries\r\n2. **Registry System** - Generic Registry<T> template with JSON loading\r\n3. **Inventory System** - 36-slot Minecraft-style item storage\r\n4. **Mining & Placement** - Progressive block breaking with tool durability\r\n5. **Basic HUD** - Hotbar widget (bottom-center, Minecraft-style)\r\n\r\n**Design Philosophy:**\r\n- **Minecraft Implementation Fidelity** - Follow Minecraft patterns exactly\r\n- **KISS Over YAGNI** - Simple, working implementations for tight deadline (12/12)\r\n- **JSON-First** - All data uses nlohmann/json library\r\n- **SOLID Principles** - Clean separation, dependency injection, const correctness\r\n\r\n---\r\n\r\n## Table of Contents\r\n\r\n1. [Rendering Bug Fix](#1-rendering-bug-fix)\r\n2. [System Architecture Overview](#2-system-architecture-overview)\r\n3. [Registry System Design](#3-registry-system-design)\r\n4. [Inventory System Design](#4-inventory-system-design)\r\n5. [Mining & Placement Mechanics](#5-mining--placement-mechanics)\r\n6. [Basic HUD Design](#6-basic-hud-design)\r\n7. [Data Flow Diagrams](#7-data-flow-diagrams)\r\n8. [Class Hierarchies](#8-class-hierarchies)\r\n9. [JSON Schema Definitions](#9-json-schema-definitions)\r\n10. [Implementation Strategy](#10-implementation-strategy)\r\n\r\n---\r\n\r\n## 1. Rendering Bug Fix\r\n\r\n### Problem Analysis\r\n\r\n**Issue:** Block faces are incorrectly hidden at chunk boundaries when neighboring chunks are not loaded.\r\n\r\n**Root Cause Location:** `Chunk.cpp:3616-3633` in `IsFaceVisible()` function\r\n\r\n```cpp\r\n// CURRENT (BUGGY) CODE:\r\nbool Chunk::IsFaceVisible(BlockIterator const& blockIter, IntVec3 const& faceDirection) const\r\n{\r\n    BlockIterator neighborIter = blockIter.GetNeighbor(faceDirection);\r\n\r\n    if (!neighborIter.IsValid())\r\n    {\r\n        IntVec3 currentCoords = blockIter.GetLocalCoords();\r\n        IntVec3 neighborCoords = currentCoords + faceDirection;\r\n        int worldZ = neighborCoords.z;\r\n\r\n        if (worldZ < 0 || worldZ >= CHUNK_SIZE_Z)\r\n        {\r\n            return true;  // At vertical world boundaries\r\n        }\r\n\r\n        return false;  // ❌ BUG: Assumes unloaded chunk = opaque\r\n    }\r\n\r\n    Block* neighborBlock = neighborIter.GetBlock();\r\n    if (!neighborBlock) return false;\r\n\r\n    sBlockDefinition* neighborDef = sBlockDefinition::GetDefinitionByIndex(neighborBlock->m_typeIndex);\r\n    if (!neighborDef) return false;\r\n\r\n    return !neighborDef->IsOpaque();\r\n}\r\n```\r\n\r\n**Problem:** When `neighborIter.IsValid()` returns `false` (horizontal chunk boundary with unloaded neighbor), the function returns `false`, hiding the face. This is incorrect because unloaded chunks at horizontal boundaries are usually **AIR** (especially near surface).\r\n\r\n### Solution Design\r\n\r\n**Strategy:** Conservative rendering with intelligent defaults\r\n\r\n**Key Insight:** When neighbor chunk is not loaded, assume it's **TRANSPARENT** (air) rather than opaque, then hide the face later when the chunk loads if it's actually solid.\r\n\r\n**Rationale:**\r\n- **Visual Quality**: Better to show extra faces temporarily than hide visible ones\r\n- **Minecraft Behavior**: Minecraft renders chunk boundaries optimistically\r\n- **Performance**: Extra faces only rendered at chunk edges (small overhead ~16-32 quads per edge)\r\n- **Correctness**: Face will be properly hidden once neighbor chunk activates\r\n\r\n### Implementation\r\n\r\n**File:** `SimpleMiner\\Code\\Game\\Framework\\Chunk.cpp`\r\n**Function:** `Chunk::IsFaceVisible()` (lines 3607-3656)\r\n\r\n```cpp\r\n// FIXED CODE:\r\nbool Chunk::IsFaceVisible(BlockIterator const& blockIter, IntVec3 const& faceDirection) const\r\n{\r\n    BlockIterator neighborIter = blockIter.GetNeighbor(faceDirection);\r\n\r\n    // ✅ FIX: If neighbor is invalid (unloaded chunk), assume TRANSPARENT (air)\r\n    if (!neighborIter.IsValid())\r\n    {\r\n        IntVec3 currentCoords = blockIter.GetLocalCoords();\r\n        IntVec3 neighborCoords = currentCoords + faceDirection;\r\n        int worldZ = neighborCoords.z;\r\n\r\n        // Vertical world boundaries (top/bottom of world)\r\n        if (worldZ < 0 || worldZ >= CHUNK_SIZE_Z)\r\n        {\r\n            return true;  // At vertical boundaries, render face\r\n        }\r\n\r\n        // ✅ FIX: Horizontal chunk boundary - assume neighbor is AIR (transparent)\r\n        // Rationale: Better to render extra faces temporarily than hide visible ones\r\n        return true;  // Changed from false to true\r\n    }\r\n\r\n    // Rest of function unchanged\r\n    Block* neighborBlock = neighborIter.GetBlock();\r\n    if (!neighborBlock) return false;\r\n\r\n    sBlockDefinition* neighborDef = sBlockDefinition::GetDefinitionByIndex(neighborBlock->m_typeIndex);\r\n    if (!neighborDef) return false;\r\n\r\n    return !neighborDef->IsOpaque();\r\n}\r\n```\r\n\r\n**Change Summary:**\r\n- **Line 3632**: Changed `return false;` to `return true;`\r\n- **Added comments** explaining the fix rationale\r\n\r\n### Verification Strategy\r\n\r\n**Test Cases:**\r\n1. **Surface Chunk Boundaries**: Stand at edge of loaded chunks, verify surface blocks show all visible faces\r\n2. **Underground Cave Boundaries**: Dig cave spanning chunks, verify cave walls are continuous\r\n3. **Building Across Chunks**: Place blocks spanning chunk boundaries, verify no missing faces\r\n4. **Chunk Load/Unload Cycle**: Move far from chunk, return, verify mesh rebuilds correctly\r\n\r\n---\r\n\r\n## 2. System Architecture Overview\r\n\r\n### Layer Architecture\r\n\r\n```\r\n┌─────────────────────────────────────────────────┐\r\n│           UI Layer (Basic HUD)                  │\r\n│     HotbarWidget, Crosshair (WidgetSubsystem)   │\r\n└─────────────────────────────────────────────────┘\r\n                     ↓↑\r\n┌─────────────────────────────────────────────────┐\r\n│         Gameplay Layer (Player, World)          │\r\n│   Player.hpp, World.hpp, ItemEntity.hpp         │\r\n└─────────────────────────────────────────────────┘\r\n                     ↓↑\r\n┌─────────────────────────────────────────────────┐\r\n│        Core Systems (Registry, Inventory)       │\r\n│  Registry<T>, Inventory, ItemStack, Mining      │\r\n└─────────────────────────────────────────────────┘\r\n                     ↓↑\r\n┌─────────────────────────────────────────────────┐\r\n│      Engine Layer (Renderer, Input, Audio)      │\r\n│   WidgetSubsystem, Renderer, InputSystem        │\r\n└─────────────────────────────────────────────────┘\r\n```\r\n\r\n### Component Dependency Graph\r\n\r\n```\r\nApp → World → Player → Inventory → ItemStack\r\n                  ↓\r\n              ItemEntity → ItemStack\r\n                  ↓\r\n              Chunk → Block → BlockDefinition ← BlockRegistry\r\n                                                         ↑\r\n                                                  Registry<T>\r\n                                                         ↑\r\nItemRegistry ← Registry<T>\r\nRecipeRegistry ← Registry<T>\r\n\r\nWidgetSubsystem → HotbarWidget → Player (inventory query)\r\n```\r\n\r\n### Module Boundaries\r\n\r\n- **Engine → Game (One-Way Dependency)**:\r\n  - **RULE**: Game code can `#include` Engine headers\r\n  - **RULE**: Engine code **CANNOT** `#include` Game headers\r\n  - **RATIONALE**: Engine is reusable, Game is project-specific\r\n\r\n---\r\n\r\n## 3. Registry System Design\r\n\r\n### Generic Registry Template\r\n\r\n**File:** `SimpleMiner\\Code\\Game\\Definition\\Registry.hpp`\r\n\r\n```cpp\r\ntemplate <typename T>\r\nclass Registry\r\n{\r\npublic:\r\n    // Registration\r\n    void Register(std::string const& name, T* object);\r\n\r\n    // Lookup\r\n    uint16_t GetID(std::string const& name) const;\r\n    T* Get(uint16_t id) const;\r\n    T* Get(std::string const& name) const;\r\n\r\n    // Iteration\r\n    size_t GetCount() const;\r\n    std::vector<T*> const& GetAll() const;\r\n\r\nprivate:\r\n    std::vector<T*> m_objects;                           // ID → Object (index = ID)\r\n    std::map<std::string, uint16_t> m_nameToID;          // Name → ID (case-insensitive)\r\n    mutable std::shared_mutex m_mutex;                   // Thread-safe read access\r\n};\r\n```\r\n\r\n**Key Design Decisions:**\r\n\r\n1. **Header-Only Template**: All implementation in `.hpp` for template instantiation\r\n2. **ID Assignment**: Sequential (index in vector = ID)\r\n3. **Thread Safety**: `std::shared_mutex` for concurrent reads, exclusive writes\r\n4. **Case-Insensitive**: Convert names to lowercase for lookup\r\n5. **O(1) Lookup**: Vector index for ID→Object, map for Name→ID\r\n\r\n### Block Registry Migration\r\n\r\n**Old System** (XML, static vector):\r\n```cpp\r\n// OLD BlockDefinition.cpp:\r\nstatic std::vector<sBlockDefinition*> s_definitions;\r\n```\r\n\r\n**New System** (JSON, Registry):\r\n```cpp\r\n// NEW BlockRegistry.hpp:\r\nclass BlockRegistry : public Registry<BlockDefinition>\r\n{\r\npublic:\r\n    static BlockRegistry& GetInstance();  // Singleton\r\n    void LoadFromJSON(std::string const& filePath);\r\n};\r\n```\r\n\r\n**JSON Format** (`Run/Data/Definitions/BlockDefinitions.json`):\r\n```json\r\n{\r\n  \"blocks\": [\r\n    {\r\n      \"name\": \"air\",\r\n      \"visible\": false,\r\n      \"solid\": false,\r\n      \"opaque\": false,\r\n      \"hardness\": 0.0\r\n    },\r\n    {\r\n      \"name\": \"stone\",\r\n      \"visible\": true,\r\n      \"solid\": true,\r\n      \"opaque\": true,\r\n      \"topSprite\": [1, 0],\r\n      \"sideSprite\": [1, 0],\r\n      \"bottomSprite\": [1, 0],\r\n      \"indoorLighting\": 0.0,\r\n      \"hardness\": 1.5\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n**Migration Strategy:**\r\n1. Keep BlockDefinition class unchanged (same properties)\r\n2. Replace `s_definitions` with `BlockRegistry::GetInstance()`\r\n3. `Block::GetDefinition()` calls `BlockRegistry::GetInstance().Get(m_typeIndex)`\r\n4. Load JSON at startup, preserve loading order for chunk compatibility\r\n\r\n### Item Registry\r\n\r\n**File:** `SimpleMiner\\Code\\Game\\Definition\\ItemDefinition.hpp`\r\n\r\n```cpp\r\nenum class eItemType\r\n{\r\n    RESOURCE,    // Crafting materials (e.g., stick, coal)\r\n    TOOL,        // Tools with durability (e.g., pickaxe, axe)\r\n    BLOCK,       // Placeable blocks (e.g., stone_block, wood_block)\r\n    CONSUMABLE   // Food, potions (future)\r\n};\r\n\r\nclass ItemDefinition\r\n{\r\npublic:\r\n    std::string m_name;             // \"stone_block\"\r\n    std::string m_displayName;      // \"Stone\"\r\n    eItemType m_type;               // BLOCK, TOOL, RESOURCE\r\n\r\n    // Visual\r\n    IntVec2 m_spriteCoords;         // Texture atlas coordinates (16×16 grid)\r\n\r\n    // Stacking\r\n    uint8_t m_maxStackSize;         // 64 for blocks, 1 for tools, 16 for some items\r\n\r\n    // Block Items\r\n    uint16_t m_blockTypeID;         // BlockRegistry ID (if type == BLOCK)\r\n\r\n    // Tool Items\r\n    float m_miningSpeed;            // Multiplier for mining (e.g., 2.0 for wooden pickaxe)\r\n    uint16_t m_maxDurability;       // Uses before breaking (e.g., 60 for wooden tools)\r\n};\r\n```\r\n\r\n**JSON Format** (`Run/Data/Definitions/ItemDefinitions.json`):\r\n```json\r\n{\r\n  \"items\": [\r\n    {\r\n      \"name\": \"stone_block\",\r\n      \"displayName\": \"Stone\",\r\n      \"type\": \"block\",\r\n      \"blockType\": \"stone\",\r\n      \"maxStackSize\": 64,\r\n      \"spriteCoords\": [1, 0]\r\n    },\r\n    {\r\n      \"name\": \"wooden_pickaxe\",\r\n      \"displayName\": \"Wooden Pickaxe\",\r\n      \"type\": \"tool\",\r\n      \"miningSpeed\": 2.0,\r\n      \"maxDurability\": 60,\r\n      \"maxStackSize\": 1,\r\n      \"spriteCoords\": [0, 3]\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n### Recipe Registry\r\n\r\n**File:** `SimpleMiner\\Code\\Game\\Definition\\Recipe.hpp`\r\n\r\n```cpp\r\nenum class eRecipeType\r\n{\r\n    SHAPED,      // Pattern matters (e.g., 4 planks in 2×2 → crafting table)\r\n    SHAPELESS    // Pattern doesn't matter (e.g., 1 log → 4 planks)\r\n};\r\n\r\nclass Recipe\r\n{\r\npublic:\r\n    uint16_t m_recipeID;                    // Unique ID in RecipeRegistry\r\n    eRecipeType m_type;                     // SHAPED or SHAPELESS\r\n\r\n    // Shaped Recipe\r\n    std::array<uint16_t, 4> m_pattern;      // 2×2 grid (itemID, 0 = empty)\r\n\r\n    // Shapeless Recipe\r\n    std::vector<uint16_t> m_ingredients;    // List of itemIDs (unordered)\r\n\r\n    // Output\r\n    uint16_t m_outputItemID;                // ItemRegistry ID\r\n    uint8_t m_outputQuantity;               // Crafted item count\r\n\r\n    // Matching\r\n    bool Matches(std::array<uint16_t, 4> const& craftingGrid) const;\r\n};\r\n```\r\n\r\n**JSON Format** (`Run/Data/Definitions/Recipes.json`):\r\n```json\r\n{\r\n  \"recipes\": [\r\n    {\r\n      \"type\": \"shaped\",\r\n      \"pattern\": [\r\n        [\"planks\", \"planks\"],\r\n        [\"planks\", \"planks\"]\r\n      ],\r\n      \"result\": {\r\n        \"item\": \"crafting_table\",\r\n        \"count\": 1\r\n      }\r\n    },\r\n    {\r\n      \"type\": \"shapeless\",\r\n      \"ingredients\": [\"log\"],\r\n      \"result\": {\r\n        \"item\": \"planks\",\r\n        \"count\": 4\r\n      }\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n---\r\n\r\n## 4. Inventory System Design\r\n\r\n### ItemStack Data Structure\r\n\r\n**File:** `SimpleMiner\\Code\\Game\\Gameplay\\ItemStack.hpp`\r\n\r\n```cpp\r\nstruct ItemStack\r\n{\r\n    uint16_t itemID;       // ItemRegistry ID (0 = empty)\r\n    uint8_t quantity;      // 1-255 (Minecraft uses 1-64 typically)\r\n    uint16_t durability;   // For tools (0 = broken)\r\n\r\n    // Methods\r\n    bool IsEmpty() const { return itemID == 0 || quantity == 0; }\r\n    bool CanMergeWith(ItemStack const& other) const;\r\n    bool IsFull() const;  // quantity >= maxStackSize\r\n\r\n    // Stack manipulation\r\n    void Add(uint8_t amount);\r\n    uint8_t Take(uint8_t amount);  // Returns amount taken\r\n    void Clear() { itemID = 0; quantity = 0; durability = 0; }\r\n};\r\n```\r\n\r\n**Size:** 6 bytes total (pass by value is efficient)\r\n\r\n**Design Decisions:**\r\n- **Small struct**: Pass by value for function parameters\r\n- **Empty representation**: itemID = 0 or quantity = 0\r\n- **Durability**: Only used for tools (ignored for blocks/resources)\r\n\r\n### Inventory Class\r\n\r\n**File:** `SimpleMiner\\Code\\Game\\Gameplay\\Inventory.hpp`\r\n\r\n```cpp\r\nclass Inventory\r\n{\r\npublic:\r\n    static constexpr int MAIN_SLOT_COUNT = 27;     // 3 rows × 9 columns\r\n    static constexpr int HOTBAR_SLOT_COUNT = 9;    // Bottom row\r\n    static constexpr int TOTAL_SLOT_COUNT = 36;    // Main + Hotbar\r\n\r\n    // Access\r\n    ItemStack& GetSlot(int slotIndex);             // 0-35\r\n    ItemStack& GetMainSlot(int index);             // 0-26\r\n    ItemStack& GetHotbarSlot(int index);           // 0-8\r\n\r\n    // Hotbar\r\n    int GetSelectedHotbarSlot() const;             // 0-8\r\n    void SetSelectedHotbarSlot(int slot);          // 1-9 keys\r\n    ItemStack& GetSelectedItemStack();\r\n\r\n    // Operations\r\n    bool AddItem(ItemStack const& item);           // Find empty/matching slot\r\n    bool RemoveItem(uint16_t itemID, uint8_t quantity);\r\n    void SwapSlots(int slot1, int slot2);\r\n    bool MergeSlots(int sourceSlot, int destSlot);\r\n\r\n    // Serialization\r\n    void SaveToJSON(Json::Value& root) const;\r\n    void LoadFromJSON(Json::Value const& root);\r\n\r\nprivate:\r\n    std::array<ItemStack, TOTAL_SLOT_COUNT> m_slots;  // 0-26 main, 27-35 hotbar\r\n    int m_selectedHotbarSlot = 0;                     // 0-8\r\n};\r\n```\r\n\r\n**Layout:**\r\n```\r\nSlots 0-26: Main Inventory (3 rows × 9 columns)\r\n┌─┬─┬─┬─┬─┬─┬─┬─┬─┐\r\n│0│1│2│3│4│5│6│7│8│\r\n├─┼─┼─┼─┼─┼─┼─┼─┼─┤\r\n│9│...      ...│17│\r\n├─┼─┼─┼─┼─┼─┼─┼─┼─┤\r\n│18│...     ...│26│\r\n└─┴─┴─┴─┴─┴─┴─┴─┴─┘\r\n\r\nSlots 27-35: Hotbar (bottom row, visible in HUD)\r\n┌─┬─┬─┬─┬─┬─┬─┬─┬─┐\r\n│27│28│29│30│31│32│33│34│35│\r\n└─┴─┴─┴─┴─┴─┴─┴─┴─┘\r\n```\r\n\r\n**AddItem Algorithm** (Minecraft behavior):\r\n1. Find existing slot with same itemID (not full)\r\n2. Merge with existing stack (up to maxStackSize)\r\n3. If excess, find empty slot and create new stack\r\n4. Repeat until all added or inventory full\r\n5. Return true if all added, false if partial/failed\r\n\r\n### ItemEntity Class\r\n\r\n**File:** `SimpleMiner\\Code\\Game\\Gameplay\\ItemEntity.hpp`\r\n\r\n```cpp\r\nclass ItemEntity : public Entity\r\n{\r\npublic:\r\n    // Constructor\r\n    ItemEntity(Vec3 const& position, ItemStack const& item);\r\n\r\n    // Entity Overrides\r\n    virtual void Update(float deltaSeconds) override;\r\n    virtual void Render() const override;\r\n\r\n    // Item Properties\r\n    ItemStack const& GetItemStack() const { return m_item; }\r\n    void SetItemStack(ItemStack const& item) { m_item = item; }\r\n\r\n    // Pickup\r\n    bool CanBePickedUp() const;               // Checks cooldown\r\n    void OnPickedUp();                        // Called when added to inventory\r\n\r\n    // Stacking\r\n    bool CanStackWith(ItemEntity const& other) const;\r\n    void MergeWith(ItemEntity& other);        // Combine quantities, destroy other\r\n\r\nprivate:\r\n    ItemStack m_item;                         // What item this represents\r\n    float m_pickupCooldown = 0.5f;            // Time after spawn before can pickup\r\n    float m_magnetRadius = 3.0f;              // Blocks distance for magnetic pull\r\n    float m_despawnTimer = 300.0f;            // 5 minutes (Minecraft standard)\r\n\r\n    void ApplyMagneticPull(float deltaSeconds);  // Pull toward nearby player\r\n};\r\n```\r\n\r\n**Magnetic Pickup** (Minecraft mechanic):\r\n```cpp\r\nvoid ItemEntity::ApplyMagneticPull(float deltaSeconds)\r\n{\r\n    Player* player = World::GetInstance()->GetPlayer();\r\n    Vec3 toPlayer = player->GetPosition() - m_position;\r\n    float distance = toPlayer.GetLength();\r\n\r\n    if (distance < m_magnetRadius && CanBePickedUp())\r\n    {\r\n        Vec3 pullDir = toPlayer.GetNormalized();\r\n        float pullSpeed = 5.0f;  // Blocks/second\r\n        m_velocity += pullDir * pullSpeed * deltaSeconds;\r\n    }\r\n}\r\n```\r\n\r\n**Item Stacking in World** (Minecraft behavior):\r\n- When ItemEntity spawns, check for nearby ItemEntity of same type\r\n- If found within 1 block radius, merge quantities, destroy duplicate entity\r\n- Prevents clutter from mass block breaking\r\n\r\n---\r\n\r\n## 5. Mining & Placement Mechanics\r\n\r\n### Progressive Block Breaking\r\n\r\n**File:** `SimpleMiner\\Code\\Game\\Gameplay\\Player.cpp`\r\n\r\n**Mining State Machine:**\r\n```cpp\r\nenum class eMiningState\r\n{\r\n    IDLE,               // Not mining\r\n    MINING,             // Holding left mouse, progress increasing\r\n    BROKEN              // Block just broke, spawn ItemEntity this frame\r\n};\r\n\r\nclass Player\r\n{\r\nprivate:\r\n    eMiningState m_miningState = eMiningState::IDLE;\r\n    IntVec3 m_targetBlockCoords;        // Block being mined\r\n    float m_miningProgress = 0.0f;      // 0.0 to 1.0\r\n    float m_breakTime = 0.0f;           // Seconds to break (depends on hardness, tool)\r\n};\r\n```\r\n\r\n**Break Time Formula** (Minecraft-based):\r\n```cpp\r\nfloat Player::CalculateBreakTime(Block const& block, ItemStack const& tool)\r\n{\r\n    BlockDefinition* blockDef = BlockRegistry::GetInstance().Get(block.m_typeIndex);\r\n    float hardness = blockDef->m_hardness;  // e.g., 1.5 for stone\r\n\r\n    float toolEffectiveness = 1.0f;  // Hand mining\r\n    if (!tool.IsEmpty())\r\n    {\r\n        ItemDefinition* toolDef = ItemRegistry::GetInstance().Get(tool.itemID);\r\n        if (toolDef->m_type == eItemType::TOOL)\r\n        {\r\n            toolEffectiveness = toolDef->m_miningSpeed;  // e.g., 2.0 for wooden pickaxe\r\n        }\r\n    }\r\n\r\n    float breakTime = hardness / toolEffectiveness;\r\n    return breakTime;\r\n}\r\n```\r\n\r\n**Mining Update Loop:**\r\n```cpp\r\nvoid Player::UpdateMining(float deltaSeconds)\r\n{\r\n    if (m_miningState == eMiningState::IDLE)\r\n    {\r\n        if (g_inputSystem->IsKeyDown(MOUSE_LEFT))\r\n        {\r\n            RaycastResult result = RaycastToBlock(6.0f);  // 6 block range\r\n            if (result.hit)\r\n            {\r\n                m_targetBlockCoords = result.blockCoords;\r\n                m_miningProgress = 0.0f;\r\n                m_breakTime = CalculateBreakTime(result.block, GetSelectedItemStack());\r\n                m_miningState = eMiningState::MINING;\r\n            }\r\n        }\r\n    }\r\n    else if (m_miningState == eMiningState::MINING)\r\n    {\r\n        // Check cancel conditions\r\n        if (!g_inputSystem->IsKeyDown(MOUSE_LEFT) ||\r\n            !IsBlockInView(m_targetBlockCoords, 6.0f))\r\n        {\r\n            m_miningState = eMiningState::IDLE;\r\n            m_miningProgress = 0.0f;\r\n            return;\r\n        }\r\n\r\n        // Increment progress\r\n        m_miningProgress += deltaSeconds / m_breakTime;\r\n\r\n        // Check completion\r\n        if (m_miningProgress >= 1.0f)\r\n        {\r\n            BreakBlock(m_targetBlockCoords);\r\n            m_miningState = eMiningState::BROKEN;\r\n        }\r\n    }\r\n    else if (m_miningState == eMiningState::BROKEN)\r\n    {\r\n        // Reset next frame\r\n        m_miningState = eMiningState::IDLE;\r\n        m_miningProgress = 0.0f;\r\n    }\r\n}\r\n```\r\n\r\n**Visual Crack Overlay** (10 stages, 0-9):\r\n```cpp\r\nvoid Player::RenderMiningProgress() const\r\n{\r\n    if (m_miningState != eMiningState::MINING) return;\r\n\r\n    int crackStage = (int)(m_miningProgress * 10.0f);  // 0-9\r\n    crackStage = Clamp(crackStage, 0, 9);\r\n\r\n    // Render crack texture overlay at target block position\r\n    Texture* crackTexture = g_renderer->GetTexture(\"Data/Images/Cracks.png\");\r\n    IntVec2 spriteCoords(crackStage, 0);  // Crack stages in horizontal strip\r\n\r\n    // Draw crack on all 6 faces of target block\r\n    DrawBlockOverlay(m_targetBlockCoords, crackTexture, spriteCoords);\r\n}\r\n```\r\n\r\n**Tool Durability:**\r\n```cpp\r\nvoid Player::BreakBlock(IntVec3 const& coords)\r\n{\r\n    // Remove block from world\r\n    m_world->SetBlock(coords, BLOCK_AIR);\r\n\r\n    // Spawn ItemEntity with block drop\r\n    Vec3 spawnPos = Vec3((float)coords.x + 0.5f, (float)coords.y + 0.5f, (float)coords.z + 0.5f);\r\n    ItemStack droppedItem = GetBlockDropItem(coords);  // e.g., GRASS → DIRT\r\n    m_world->SpawnItemEntity(spawnPos, droppedItem);\r\n\r\n    // Decrease tool durability\r\n    ItemStack& tool = GetSelectedItemStack();\r\n    if (!tool.IsEmpty() && tool.durability > 0)\r\n    {\r\n        tool.durability--;\r\n        if (tool.durability == 0)\r\n        {\r\n            tool.Clear();  // Tool broke, remove from inventory\r\n        }\r\n    }\r\n\r\n    // Rebuild chunk mesh\r\n    Chunk* chunk = m_world->GetChunkAtWorldCoords(coords);\r\n    chunk->SetDirty();\r\n}\r\n```\r\n\r\n### Block Placement\r\n\r\n**Placement Raycast:**\r\n```cpp\r\nRaycastResult Player::RaycastForPlacement(float maxDistance)\r\n{\r\n    Ray ray(m_cameraPosition, m_cameraForward);\r\n    RaycastResult result = m_world->Raycast(ray, maxDistance);\r\n\r\n    if (result.hit)\r\n    {\r\n        // Calculate placement position (adjacent to hit face)\r\n        result.placementCoords = result.blockCoords + result.hitNormal;\r\n    }\r\n\r\n    return result;\r\n}\r\n```\r\n\r\n**Placement Validation:**\r\n```cpp\r\nbool Player::CanPlaceBlock(IntVec3 const& coords)\r\n{\r\n    // Check 1: Position not occupied by solid block\r\n    Block* existingBlock = m_world->GetBlock(coords);\r\n    if (existingBlock && existingBlock->IsSolid()) return false;\r\n\r\n    // Check 2: Player not intersecting placed block position\r\n    AABB3 blockAABB = AABB3::MakeFromMinMaxInts(coords, coords + IntVec3(1,1,1));\r\n    if (blockAABB.IsPointInside(m_position)) return false;\r\n\r\n    // Check 3: Within reach (6 blocks)\r\n    float distance = (Vec3(coords) - m_position).GetLength();\r\n    if (distance > 6.0f) return false;\r\n\r\n    return true;\r\n}\r\n```\r\n\r\n**Placement Logic:**\r\n```cpp\r\nvoid Player::UpdatePlacement()\r\n{\r\n    if (g_inputSystem->WasKeyJustPressed(MOUSE_RIGHT))\r\n    {\r\n        RaycastResult result = RaycastForPlacement(6.0f);\r\n        if (!result.hit) return;\r\n\r\n        IntVec3 placeCoords = result.placementCoords;\r\n        if (!CanPlaceBlock(placeCoords)) return;\r\n\r\n        // Get selected item from hotbar\r\n        ItemStack& item = GetSelectedItemStack();\r\n        if (item.IsEmpty()) return;\r\n\r\n        ItemDefinition* itemDef = ItemRegistry::GetInstance().Get(item.itemID);\r\n        if (itemDef->m_type != eItemType::BLOCK) return;\r\n\r\n        // Place block\r\n        uint16_t blockType = itemDef->m_blockTypeID;\r\n        m_world->SetBlock(placeCoords, blockType);\r\n\r\n        // Consume item\r\n        item.Take(1);\r\n\r\n        // Rebuild chunk mesh\r\n        Chunk* chunk = m_world->GetChunkAtWorldCoords(placeCoords);\r\n        chunk->SetDirty();\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 6. Basic HUD Design\r\n\r\n### HotbarWidget Class\r\n\r\n**File:** `SimpleMiner\\Code\\Game\\UI\\HotbarWidget.hpp`\r\n\r\n```cpp\r\nclass HotbarWidget : public IWidget\r\n{\r\npublic:\r\n    HotbarWidget();\r\n\r\n    // IWidget Interface\r\n    virtual void Update(float deltaSeconds) override;\r\n    virtual void Render() const override;\r\n    virtual bool OnMouseEvent(MouseEvent const& event) override;\r\n    virtual bool OnKeyEvent(KeyEvent const& event) override;\r\n\r\n    // Configuration\r\n    void SetPlayer(Player* player) { m_player = player; }\r\n\r\nprivate:\r\n    Player* m_player = nullptr;\r\n\r\n    // Layout\r\n    Vec2 m_position;          // Bottom-center of screen\r\n    Vec2 m_slotSize;          // 18×18 pixels per slot (16px item + 1px padding)\r\n    Vec2 m_backgroundSize;    // 182×22 pixels (Minecraft hotbar)\r\n\r\n    // Textures\r\n    Texture* m_backgroundTexture = nullptr;  // Gray GUI background\r\n    Texture* m_selectionTexture = nullptr;   // White border for selected slot\r\n    Texture* m_itemSpriteSheet = nullptr;    // Item icons (16×16 grid)\r\n\r\n    // Rendering\r\n    void RenderBackground() const;\r\n    void RenderSlots() const;\r\n    void RenderSelection() const;\r\n    void RenderItemIcon(int slotIndex, ItemStack const& item) const;\r\n    void RenderItemQuantity(int slotIndex, uint8_t quantity) const;\r\n};\r\n```\r\n\r\n**Hotbar Layout (Minecraft style):**\r\n```\r\n┌────────────────────────────────────────────────┐\r\n│  [0] [1] [2] [3] [4] [5] [6] [7] [8]          │\r\n│   1   2   3   4   5   6   7   8   9  (keys)   │\r\n└────────────────────────────────────────────────┘\r\nBottom-center of screen (centered horizontally)\r\n```\r\n\r\n**Rendering Pipeline:**\r\n```cpp\r\nvoid HotbarWidget::Render() const\r\n{\r\n    if (!m_player) return;\r\n\r\n    // 1. Render background (gray GUI texture)\r\n    RenderBackground();\r\n\r\n    // 2. Render selection highlight (white border around selected slot)\r\n    RenderSelection();\r\n\r\n    // 3. Render item icons and quantities for each slot\r\n    Inventory& inventory = m_player->GetInventory();\r\n    for (int i = 0; i < 9; i++)\r\n    {\r\n        ItemStack const& item = inventory.GetHotbarSlot(i);\r\n        if (!item.IsEmpty())\r\n        {\r\n            RenderItemIcon(i, item);\r\n            if (item.quantity > 1)\r\n            {\r\n                RenderItemQuantity(i, item.quantity);\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**Item Icon Rendering:**\r\n```cpp\r\nvoid HotbarWidget::RenderItemIcon(int slotIndex, ItemStack const& item) const\r\n{\r\n    ItemDefinition* itemDef = ItemRegistry::GetInstance().Get(item.itemID);\r\n    if (!itemDef) return;\r\n\r\n    // Calculate slot position\r\n    Vec2 slotPos = m_position + Vec2(slotIndex * 20.0f, 0.0f);  // 20px spacing\r\n\r\n    // Get sprite coordinates from item definition\r\n    IntVec2 spriteCoords = itemDef->m_spriteCoords;  // e.g., (1, 0) for stone\r\n\r\n    // Render 16×16 item icon from sprite sheet\r\n    AABB2 uvs = GetUVsForSpriteCoords(spriteCoords, IntVec2(16, 16));  // 16×16 grid\r\n    g_renderer->DrawTexturedQuad(slotPos, Vec2(16.0f, 16.0f), m_itemSpriteSheet, uvs);\r\n}\r\n```\r\n\r\n**Item Quantity Rendering:**\r\n```cpp\r\nvoid HotbarWidget::RenderItemQuantity(int slotIndex, uint8_t quantity) const\r\n{\r\n    // Render quantity text in bottom-right corner of slot (Minecraft style)\r\n    Vec2 slotPos = m_position + Vec2(slotIndex * 20.0f, 0.0f);\r\n    Vec2 textPos = slotPos + Vec2(12.0f, 2.0f);  // Bottom-right offset\r\n\r\n    std::string quantityText = std::to_string(quantity);\r\n    g_renderer->DrawText2D(textPos, quantityText, 8.0f, Rgba8::WHITE);\r\n}\r\n```\r\n\r\n### Crosshair Widget\r\n\r\n**Simple Rendering:**\r\n```cpp\r\nvoid RenderCrosshair()\r\n{\r\n    // Center of screen\r\n    Vec2 screenCenter = g_window->GetDimensions() * 0.5f;\r\n\r\n    // Draw white cross (5px lines)\r\n    g_renderer->DrawLine2D(screenCenter + Vec2(-5, 0), screenCenter + Vec2(5, 0), Rgba8::WHITE, 2.0f);\r\n    g_renderer->DrawLine2D(screenCenter + Vec2(0, -5), screenCenter + Vec2(0, 5), Rgba8::WHITE, 2.0f);\r\n}\r\n```\r\n\r\n---\r\n\r\n## 7. Data Flow Diagrams\r\n\r\n### Mining Flow\r\n```\r\nPlayer (left-click) → Raycast(6 blocks) → Hit Block\r\n       ↓\r\n   Update Mining Progress (deltaTime / breakTime)\r\n       ↓\r\n   Render Crack Overlay (progress * 10 stages)\r\n       ↓\r\n   Progress >= 1.0? → BreakBlock()\r\n       ↓\r\n   World::SetBlock(coords, AIR)\r\n       ↓\r\n   SpawnItemEntity(block drop)\r\n       ↓\r\n   Chunk::SetDirty() → Rebuild Mesh\r\n       ↓\r\n   Decrease Tool Durability\r\n```\r\n\r\n### Placement Flow\r\n```\r\nPlayer (right-click) → Raycast(6 blocks) → Hit Block\r\n       ↓\r\n   Calculate Placement Position (adjacent to hit face)\r\n       ↓\r\n   Validate Placement (not occupied, in reach, not inside player)\r\n       ↓\r\n   Get Selected ItemStack → Check if BLOCK type\r\n       ↓\r\n   World::SetBlock(coords, blockType)\r\n       ↓\r\n   ItemStack::Take(1) → Decrease quantity\r\n       ↓\r\n   Chunk::SetDirty() → Rebuild Mesh\r\n```\r\n\r\n### Item Pickup Flow\r\n```\r\nItemEntity (world) → Update() → ApplyMagneticPull()\r\n       ↓\r\n   Distance < 3 blocks? → Apply pull velocity toward player\r\n       ↓\r\n   Collision with Player? → Player::OnItemEntityPickup()\r\n       ↓\r\n   Inventory::AddItem(itemStack)\r\n       ↓\r\n   Success? → ItemEntity::OnPickedUp() → Destroy entity\r\n   Failed? → Item remains in world\r\n```\r\n\r\n---\r\n\r\n## 8. Class Hierarchies\r\n\r\n### Entity Inheritance\r\n```\r\nEntity (abstract)\r\n├── Player\r\n├── ItemEntity\r\n└── Prop (existing)\r\n```\r\n\r\n### Widget Inheritance\r\n```\r\nIWidget (Engine interface)\r\n└── HotbarWidget\r\n```\r\n\r\n### Definition Classes\r\n```\r\n[NO INHERITANCE]\r\n\r\nBlockDefinition (standalone)\r\nItemDefinition (standalone)\r\nRecipe (standalone)\r\n```\r\n\r\n---\r\n\r\n## 9. JSON Schema Definitions\r\n\r\n### BlockDefinitions.json\r\n```json\r\n{\r\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\r\n  \"type\": \"object\",\r\n  \"properties\": {\r\n    \"blocks\": {\r\n      \"type\": \"array\",\r\n      \"items\": {\r\n        \"type\": \"object\",\r\n        \"properties\": {\r\n          \"name\": { \"type\": \"string\" },\r\n          \"visible\": { \"type\": \"boolean\" },\r\n          \"solid\": { \"type\": \"boolean\" },\r\n          \"opaque\": { \"type\": \"boolean\" },\r\n          \"topSprite\": { \"type\": \"array\", \"items\": { \"type\": \"integer\" }, \"minItems\": 2, \"maxItems\": 2 },\r\n          \"sideSprite\": { \"type\": \"array\", \"items\": { \"type\": \"integer\" }, \"minItems\": 2, \"maxItems\": 2 },\r\n          \"bottomSprite\": { \"type\": \"array\", \"items\": { \"type\": \"integer\" }, \"minItems\": 2, \"maxItems\": 2 },\r\n          \"indoorLighting\": { \"type\": \"number\" },\r\n          \"hardness\": { \"type\": \"number\" }\r\n        },\r\n        \"required\": [\"name\", \"visible\", \"solid\", \"opaque\", \"hardness\"]\r\n      }\r\n    }\r\n  },\r\n  \"required\": [\"blocks\"]\r\n}\r\n```\r\n\r\n### ItemDefinitions.json\r\n```json\r\n{\r\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\r\n  \"type\": \"object\",\r\n  \"properties\": {\r\n    \"items\": {\r\n      \"type\": \"array\",\r\n      \"items\": {\r\n        \"type\": \"object\",\r\n        \"properties\": {\r\n          \"name\": { \"type\": \"string\" },\r\n          \"displayName\": { \"type\": \"string\" },\r\n          \"type\": { \"enum\": [\"resource\", \"tool\", \"block\", \"consumable\"] },\r\n          \"blockType\": { \"type\": \"string\" },\r\n          \"maxStackSize\": { \"type\": \"integer\", \"minimum\": 1, \"maximum\": 255 },\r\n          \"spriteCoords\": { \"type\": \"array\", \"items\": { \"type\": \"integer\" }, \"minItems\": 2, \"maxItems\": 2 },\r\n          \"miningSpeed\": { \"type\": \"number\" },\r\n          \"maxDurability\": { \"type\": \"integer\" }\r\n        },\r\n        \"required\": [\"name\", \"displayName\", \"type\", \"maxStackSize\", \"spriteCoords\"]\r\n      }\r\n    }\r\n  },\r\n  \"required\": [\"items\"]\r\n}\r\n```\r\n\r\n### Recipes.json\r\n```json\r\n{\r\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\r\n  \"type\": \"object\",\r\n  \"properties\": {\r\n    \"recipes\": {\r\n      \"type\": \"array\",\r\n      \"items\": {\r\n        \"type\": \"object\",\r\n        \"properties\": {\r\n          \"type\": { \"enum\": [\"shaped\", \"shapeless\"] },\r\n          \"pattern\": {\r\n            \"type\": \"array\",\r\n            \"items\": {\r\n              \"type\": \"array\",\r\n              \"items\": { \"type\": \"string\" },\r\n              \"minItems\": 2,\r\n              \"maxItems\": 2\r\n            },\r\n            \"minItems\": 2,\r\n            \"maxItems\": 2\r\n          },\r\n          \"ingredients\": {\r\n            \"type\": \"array\",\r\n            \"items\": { \"type\": \"string\" }\r\n          },\r\n          \"result\": {\r\n            \"type\": \"object\",\r\n            \"properties\": {\r\n              \"item\": { \"type\": \"string\" },\r\n              \"count\": { \"type\": \"integer\", \"minimum\": 1 }\r\n            },\r\n            \"required\": [\"item\", \"count\"]\r\n          }\r\n        },\r\n        \"required\": [\"type\", \"result\"]\r\n      }\r\n    }\r\n  },\r\n  \"required\": [\"recipes\"]\r\n}\r\n```\r\n\r\n---\r\n\r\n## 10. Implementation Strategy\r\n\r\n### Phase 1: Rendering Bug Fix (1-2 hours)\r\n1. Open `Chunk.cpp:3632`\r\n2. Change `return false;` to `return true;`\r\n3. Add comment explaining fix\r\n4. Test with chunk boundaries\r\n5. Verify no visual artifacts\r\n\r\n### Phase 2: Registry System (4-6 hours)\r\n1. Create `Registry<T>` template in `Definition/Registry.hpp`\r\n2. Migrate BlockDefinition to JSON (keep class unchanged)\r\n3. Implement `BlockRegistry::LoadFromJSON()`\r\n4. Create `ItemDefinition` class\r\n5. Create `ItemRegistry::LoadFromJSON()`\r\n6. Create `Recipe` class\r\n7. Create `RecipeRegistry::LoadFromJSON()`\r\n8. Test registry lookups (name→ID, ID→object)\r\n\r\n### Phase 3: Inventory System (6-8 hours)\r\n1. Create `ItemStack` struct\r\n2. Create `Inventory` class with 36 slots\r\n3. Add inventory to `Player` class\r\n4. Implement `Inventory::AddItem()` (Minecraft behavior)\r\n5. Create `ItemEntity` class (extends Entity)\r\n6. Implement magnetic pickup\r\n7. Test item pickup and inventory filling\r\n\r\n### Phase 4: Mining & Placement (8-10 hours)\r\n1. Implement progressive mining in `Player::UpdateMining()`\r\n2. Add crack overlay rendering\r\n3. Implement `BreakBlock()` with ItemEntity spawning\r\n4. Add tool durability system\r\n5. Implement placement raycast\r\n6. Implement `CanPlaceBlock()` validation\r\n7. Implement `UpdatePlacement()` logic\r\n8. Test mining and placement mechanics\r\n\r\n### Phase 5: Basic HUD (4-6 hours)\r\n1. Create `HotbarWidget` class (extends IWidget)\r\n2. Load hotbar background texture\r\n3. Implement slot rendering\r\n4. Implement item icon rendering\r\n5. Implement quantity text rendering\r\n6. Implement selection highlight\r\n7. Add crosshair rendering\r\n8. Test hotbar with inventory changes\r\n\r\n### Total Estimated Time: 23-32 hours (1-2 weeks)\r\n\r\n---\r\n\r\n**Next Steps:**\r\n1. Approve this design.md via spec-workflow\r\n2. Create tasks.md breaking down implementation into specific tasks\r\n3. Begin Phase 1 (Rendering Bug Fix)\r\n4. Proceed sequentially through phases\r\n",
  "fileStats": {
    "size": 36013,
    "lines": 1156,
    "lastModified": "2025-11-28T01:24:15.170Z"
  },
  "comments": []
}